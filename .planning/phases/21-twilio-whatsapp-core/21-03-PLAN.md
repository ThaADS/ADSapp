# Plan 21-03: Webhook Handler

## Objective
Create webhook handler to process incoming Twilio WhatsApp messages and status updates.

## Requirements Addressed
- **TWWA-02**: Incoming WhatsApp messages via Twilio appear in unified inbox within 30 seconds

## Files to Create

### 1. `src/lib/integrations/twilio-whatsapp/webhook-handler.ts`

```typescript
/**
 * Twilio WhatsApp Webhook Handler
 * Purpose: Process incoming messages and status updates from Twilio
 * Date: 2026-02-03
 */

import crypto from 'crypto'
import { createServiceRoleClient } from '@/lib/supabase/server'
import { validateTwilioSignature, getAuthTokenForConnection } from './client'
import type {
  TwilioWhatsAppWebhookPayload,
  TwilioWhatsAppInboundMessage,
  TwilioWhatsAppStatusUpdate,
  TwilioWhatsAppMessageStatus,
} from '@/types/twilio-whatsapp'

// =============================================================================
// Types
// =============================================================================

export interface WebhookProcessResult {
  success: boolean
  messageId?: string
  error?: string
  isDuplicate?: boolean
}

// =============================================================================
// Payload Parsing
// =============================================================================

/**
 * Parse Twilio webhook payload into structured format
 */
export function parseWebhookPayload(
  params: Record<string, string>
): TwilioWhatsAppWebhookPayload {
  return {
    MessageSid: params.MessageSid || params.SmsSid || '',
    SmsSid: params.SmsSid,
    AccountSid: params.AccountSid || '',
    From: params.From || '',
    To: params.To || '',
    Body: params.Body,
    NumMedia: params.NumMedia,
    MediaUrl0: params.MediaUrl0,
    MediaContentType0: params.MediaContentType0,
    MediaUrl1: params.MediaUrl1,
    MediaContentType1: params.MediaContentType1,
    MessageStatus: params.MessageStatus as TwilioWhatsAppMessageStatus,
    ErrorCode: params.ErrorCode,
    ErrorMessage: params.ErrorMessage,
    ProfileName: params.ProfileName,
    WaId: params.WaId,
    Forwarded: params.Forwarded,
    FrequentlyForwarded: params.FrequentlyForwarded,
    ApiVersion: params.ApiVersion,
    SmsStatus: params.SmsStatus,
  }
}

/**
 * Extract phone number from whatsapp: prefix
 */
function extractPhoneNumber(whatsappNumber: string): string {
  return whatsappNumber.replace(/^whatsapp:/, '')
}

/**
 * Parse inbound message from payload
 */
function parseInboundMessage(
  payload: TwilioWhatsAppWebhookPayload
): TwilioWhatsAppInboundMessage {
  const numMedia = parseInt(payload.NumMedia || '0', 10)
  const mediaUrls: string[] = []
  const mediaContentTypes: string[] = []

  // Extract up to 10 media items
  for (let i = 0; i < numMedia && i < 10; i++) {
    const urlKey = `MediaUrl${i}` as keyof TwilioWhatsAppWebhookPayload
    const typeKey = `MediaContentType${i}` as keyof TwilioWhatsAppWebhookPayload
    if (payload[urlKey]) {
      mediaUrls.push(payload[urlKey] as string)
      mediaContentTypes.push((payload[typeKey] as string) || 'application/octet-stream')
    }
  }

  return {
    messageSid: payload.MessageSid,
    accountSid: payload.AccountSid,
    from: extractPhoneNumber(payload.From),
    to: extractPhoneNumber(payload.To),
    body: payload.Body || '',
    numMedia,
    mediaUrls,
    mediaContentTypes,
    profileName: payload.ProfileName,
    waId: payload.WaId,
    timestamp: new Date(),
  }
}

/**
 * Parse status update from payload
 */
function parseStatusUpdate(
  payload: TwilioWhatsAppWebhookPayload
): TwilioWhatsAppStatusUpdate | null {
  if (!payload.MessageStatus) {
    return null
  }

  return {
    messageSid: payload.MessageSid,
    status: payload.MessageStatus,
    errorCode: payload.ErrorCode,
    errorMessage: payload.ErrorMessage,
    timestamp: new Date(),
  }
}

// =============================================================================
// Idempotency
// =============================================================================

/**
 * Check if webhook event has already been processed
 */
async function checkIdempotency(
  messageSid: string,
  eventType: 'message' | 'status',
  payloadHash: string
): Promise<{ isDuplicate: boolean; eventId?: string }> {
  const supabase = createServiceRoleClient()

  const { data, error } = await supabase
    .from('twilio_whatsapp_webhook_events')
    .select('id, status')
    .eq('message_sid', messageSid)
    .eq('event_type', eventType)
    .single()

  if (error && error.code !== 'PGRST116') {
    // PGRST116 = not found, which is expected for new events
    console.error('Error checking idempotency:', error)
  }

  if (data) {
    return { isDuplicate: true, eventId: data.id }
  }

  // Create new event record
  const { data: newEvent, error: insertError } = await supabase
    .from('twilio_whatsapp_webhook_events')
    .insert({
      message_sid: messageSid,
      event_type: eventType,
      payload_hash: payloadHash,
      status: 'pending',
    })
    .select('id')
    .single()

  if (insertError) {
    // Duplicate key error means another request beat us
    if (insertError.code === '23505') {
      return { isDuplicate: true }
    }
    throw insertError
  }

  return { isDuplicate: false, eventId: newEvent.id }
}

/**
 * Mark webhook event as processed
 */
async function markEventProcessed(
  eventId: string,
  success: boolean,
  errorMessage?: string
): Promise<void> {
  const supabase = createServiceRoleClient()

  await supabase
    .from('twilio_whatsapp_webhook_events')
    .update({
      status: success ? 'processed' : 'failed',
      processed_at: new Date().toISOString(),
      error_message: errorMessage,
    })
    .eq('id', eventId)
}

/**
 * Generate hash of payload for idempotency
 */
function hashPayload(params: Record<string, string>): string {
  const sortedKeys = Object.keys(params).sort()
  const data = sortedKeys.map(k => `${k}=${params[k]}`).join('&')
  return crypto.createHash('sha256').update(data).digest('hex')
}

// =============================================================================
// Connection Lookup
// =============================================================================

/**
 * Find connection by WhatsApp number
 */
async function findConnectionByNumber(
  whatsappNumber: string
): Promise<{ id: string; organizationId: string; authToken: string } | null> {
  const supabase = createServiceRoleClient()

  const { data, error } = await supabase
    .from('twilio_whatsapp_connections')
    .select('id, organization_id, twilio_auth_token_hash')
    .eq('whatsapp_number', whatsappNumber)
    .eq('is_active', true)
    .single()

  if (error || !data) {
    return null
  }

  // Decrypt auth token
  const authToken = await getAuthTokenForConnection(data.id)
  if (!authToken) {
    return null
  }

  return {
    id: data.id,
    organizationId: data.organization_id,
    authToken,
  }
}

// =============================================================================
// Conversation Management
// =============================================================================

/**
 * Get or create conversation for incoming message
 */
async function getOrCreateConversation(
  organizationId: string,
  contactPhone: string,
  profileName?: string
): Promise<{ conversationId: string; contactId: string }> {
  const supabase = createServiceRoleClient()

  // First, find or create contact
  let { data: contact } = await supabase
    .from('contacts')
    .select('id')
    .eq('organization_id', organizationId)
    .eq('whatsapp_id', contactPhone)
    .single()

  if (!contact) {
    // Create new contact
    const { data: newContact, error: contactError } = await supabase
      .from('contacts')
      .insert({
        organization_id: organizationId,
        whatsapp_id: contactPhone,
        phone_number: contactPhone,
        name: profileName || contactPhone,
        source: 'twilio_whatsapp',
      })
      .select('id')
      .single()

    if (contactError) {
      throw new Error(`Failed to create contact: ${contactError.message}`)
    }
    contact = newContact
  }

  // Find or create conversation
  let { data: conversation } = await supabase
    .from('conversations')
    .select('id')
    .eq('organization_id', organizationId)
    .eq('contact_id', contact.id)
    .eq('channel', 'twilio_whatsapp')
    .single()

  if (!conversation) {
    // Create new conversation
    const { data: newConversation, error: convError } = await supabase
      .from('conversations')
      .insert({
        organization_id: organizationId,
        contact_id: contact.id,
        channel: 'twilio_whatsapp',
        status: 'open',
        last_message_at: new Date().toISOString(),
      })
      .select('id')
      .single()

    if (convError) {
      throw new Error(`Failed to create conversation: ${convError.message}`)
    }
    conversation = newConversation
  }

  return {
    conversationId: conversation.id,
    contactId: contact.id,
  }
}

// =============================================================================
// Message Processing
// =============================================================================

/**
 * Process incoming WhatsApp message
 */
export async function processIncomingMessage(
  message: TwilioWhatsAppInboundMessage,
  connectionId: string,
  organizationId: string
): Promise<WebhookProcessResult> {
  const supabase = createServiceRoleClient()

  try {
    // Get or create conversation
    const { conversationId, contactId } = await getOrCreateConversation(
      organizationId,
      message.from,
      message.profileName
    )

    // Determine content type
    let contentType = 'text'
    let mediaUrl: string | undefined
    let mediaType: string | undefined

    if (message.numMedia > 0 && message.mediaUrls.length > 0) {
      contentType = 'media'
      mediaUrl = message.mediaUrls[0]
      mediaType = message.mediaContentTypes[0]
    }

    // Insert message
    const { data: newMessage, error } = await supabase
      .from('messages')
      .insert({
        conversation_id: conversationId,
        organization_id: organizationId,
        channel: 'twilio_whatsapp',
        channel_message_id: message.messageSid,
        direction: 'inbound',
        content: message.body,
        content_type: contentType,
        media_url: mediaUrl,
        media_type: mediaType,
        sender_type: 'contact',
        sender_id: contactId,
        status: 'delivered',
        metadata: {
          twilio_account_sid: message.accountSid,
          profile_name: message.profileName,
          wa_id: message.waId,
          from: message.from,
          to: message.to,
          num_media: message.numMedia,
          media_urls: message.mediaUrls,
          media_content_types: message.mediaContentTypes,
        },
      })
      .select('id')
      .single()

    if (error) {
      throw new Error(`Failed to insert message: ${error.message}`)
    }

    // Update conversation last_message_at
    await supabase
      .from('conversations')
      .update({
        last_message_at: new Date().toISOString(),
        unread_count: supabase.rpc('increment', { row_count: 1 }),
      })
      .eq('id', conversationId)

    return {
      success: true,
      messageId: newMessage.id,
    }
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    }
  }
}

/**
 * Process status callback (sent, delivered, read, failed)
 */
export async function processStatusCallback(
  statusUpdate: TwilioWhatsAppStatusUpdate
): Promise<WebhookProcessResult> {
  const supabase = createServiceRoleClient()

  try {
    // Map Twilio status to our status
    const statusMap: Record<TwilioWhatsAppMessageStatus, string> = {
      queued: 'pending',
      sending: 'pending',
      sent: 'sent',
      delivered: 'delivered',
      read: 'read',
      failed: 'failed',
      undelivered: 'failed',
    }

    const mappedStatus = statusMap[statusUpdate.status] || 'pending'

    // Update message status
    const updateData: Record<string, unknown> = {
      status: mappedStatus,
      updated_at: new Date().toISOString(),
    }

    if (mappedStatus === 'delivered') {
      updateData.delivered_at = statusUpdate.timestamp.toISOString()
    }

    if (mappedStatus === 'read') {
      updateData.read_at = statusUpdate.timestamp.toISOString()
    }

    if (mappedStatus === 'failed') {
      updateData.error_code = statusUpdate.errorCode
      updateData.error_message = statusUpdate.errorMessage
    }

    const { data, error } = await supabase
      .from('messages')
      .update(updateData)
      .eq('channel_message_id', statusUpdate.messageSid)
      .select('id')
      .single()

    if (error) {
      // Message might not exist yet (race condition) or already deleted
      if (error.code === 'PGRST116') {
        return { success: true } // Ignore, not an error
      }
      throw new Error(`Failed to update message status: ${error.message}`)
    }

    return {
      success: true,
      messageId: data?.id,
    }
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    }
  }
}

// =============================================================================
// Main Handler
// =============================================================================

/**
 * Main webhook handler entry point
 */
export async function handleTwilioWhatsAppWebhook(
  params: Record<string, string>,
  signature: string,
  url: string
): Promise<WebhookProcessResult> {
  // Parse payload
  const payload = parseWebhookPayload(params)

  // Determine which number received this
  const toNumber = extractPhoneNumber(payload.To)
  const fromNumber = extractPhoneNumber(payload.From)

  // Find connection (for incoming, To is our number; for status callbacks, From is our number)
  let connection = await findConnectionByNumber(toNumber)
  if (!connection) {
    connection = await findConnectionByNumber(fromNumber)
  }

  if (!connection) {
    return {
      success: false,
      error: 'No active connection found for this WhatsApp number',
    }
  }

  // Validate signature
  const isValid = validateTwilioSignature(signature, url, params, connection.authToken)
  if (!isValid) {
    return {
      success: false,
      error: 'Invalid webhook signature',
    }
  }

  // Determine event type
  const isStatusCallback = !!payload.MessageStatus && !payload.Body
  const eventType = isStatusCallback ? 'status' : 'message'

  // Check idempotency
  const payloadHash = hashPayload(params)
  const { isDuplicate, eventId } = await checkIdempotency(
    payload.MessageSid,
    eventType,
    payloadHash
  )

  if (isDuplicate) {
    return { success: true, isDuplicate: true }
  }

  if (!eventId) {
    return { success: false, error: 'Failed to create event record' }
  }

  try {
    let result: WebhookProcessResult

    if (isStatusCallback) {
      const statusUpdate = parseStatusUpdate(payload)
      if (statusUpdate) {
        result = await processStatusCallback(statusUpdate)
      } else {
        result = { success: true } // No status to process
      }
    } else {
      const inboundMessage = parseInboundMessage(payload)
      result = await processIncomingMessage(
        inboundMessage,
        connection.id,
        connection.organizationId
      )
    }

    await markEventProcessed(eventId, result.success, result.error)
    return result
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    await markEventProcessed(eventId, false, errorMessage)
    return { success: false, error: errorMessage }
  }
}
```

## Verification

1. Unit test payload parsing
2. Test idempotency with duplicate webhooks
3. Test conversation get-or-create logic
4. Test status update processing
5. Integration test with mock Twilio webhooks

## Dependencies

- Plan 21-01 (database schema)
- Plan 21-02 (client library)
- Existing `messages` table
- Existing `conversations` table
- Existing `contacts` table

## Success Criteria

- [ ] Incoming messages create new messages in database
- [ ] Messages are linked to correct conversation
- [ ] New contacts are created automatically
- [ ] Duplicate webhooks are handled via idempotency
- [ ] Status callbacks update message status
- [ ] Webhook signature is validated
- [ ] Errors are logged and tracked
