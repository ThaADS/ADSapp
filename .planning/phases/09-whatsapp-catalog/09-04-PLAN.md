---
phase: 09-whatsapp-catalog
plan: 04
type: execute
wave: 3
depends_on: ["09-02", "09-03"]
files_modified:
  - src/components/messaging/ProductCard.tsx
  - src/components/messaging/ProductPicker.tsx
  - src/components/messaging/ProductMessageComposer.tsx
autonomous: true

must_haves:
  truths:
    - "ProductPicker displays products with search and selection"
    - "ProductCard shows product image, name, price, and availability"
    - "ProductMessageComposer integrates with message input"
  artifacts:
    - path: "src/components/messaging/ProductCard.tsx"
      provides: "Product card display component"
      exports: ["ProductCard"]
    - path: "src/components/messaging/ProductPicker.tsx"
      provides: "Product selection modal"
      exports: ["ProductPicker"]
    - path: "src/components/messaging/ProductMessageComposer.tsx"
      provides: "Product message composition"
      exports: ["ProductMessageComposer"]
  key_links:
    - from: "src/components/messaging/ProductPicker.tsx"
      to: "src/app/api/whatsapp/products/route.ts"
      via: "fetch /api/whatsapp/products"
---

<objective>
Create UI components for selecting and sending product messages.

Purpose: Provide an intuitive interface for agents to browse products and send them to customers in conversations.

Output:
- ProductCard component for displaying individual products
- ProductPicker modal for searching and selecting products
- ProductMessageComposer for composing product messages
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/09-whatsapp-catalog/09-RESEARCH.md (Part 5: UI Components Design)

Existing UI patterns:
@src/components/ui/button.tsx
@src/components/ui/dialog.tsx
@src/components/ui/input.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProductCard component</name>
  <files>src/components/messaging/ProductCard.tsx</files>
  <action>
Create ProductCard component:

```tsx
'use client'

import * as React from 'react'
import Image from 'next/image'
import { Check, Package } from 'lucide-react'
import { cn } from '@/lib/utils'
import type { WhatsAppProduct } from '@/types/whatsapp-catalog'

export interface ProductCardProps {
  product: WhatsAppProduct
  selected: boolean
  selectionMode: 'single' | 'multi'
  onToggle: () => void
  disabled?: boolean
}

export function ProductCard({
  product,
  selected,
  selectionMode,
  onToggle,
  disabled = false
}: ProductCardProps) {
  // Format price
  const formatPrice = (amount: number | null, currency: string) => {
    if (amount === null) return 'Price not set'
    const formatter = new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: currency || 'USD'
    })
    // Amount is in cents
    return formatter.format(amount / 100)
  }

  // Availability badge colors
  const availabilityColors: Record<string, string> = {
    'in stock': 'bg-green-100 text-green-800',
    'out of stock': 'bg-red-100 text-red-800',
    'preorder': 'bg-yellow-100 text-yellow-800',
    'available for order': 'bg-blue-100 text-blue-800'
  }

  return (
    <div
      className={cn(
        'relative flex flex-col border rounded-lg overflow-hidden cursor-pointer transition-all',
        selected ? 'border-primary ring-2 ring-primary/20' : 'border-border hover:border-primary/50',
        disabled && 'opacity-50 cursor-not-allowed'
      )}
      onClick={() => !disabled && onToggle()}
      role={selectionMode === 'single' ? 'radio' : 'checkbox'}
      aria-checked={selected}
      tabIndex={disabled ? -1 : 0}
      onKeyDown={(e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault()
          if (!disabled) onToggle()
        }
      }}
    >
      {/* Selection indicator */}
      <div
        className={cn(
          'absolute top-2 right-2 z-10 w-5 h-5 rounded-full border-2 flex items-center justify-center transition-colors',
          selected
            ? 'bg-primary border-primary text-primary-foreground'
            : 'bg-background border-muted-foreground/30'
        )}
      >
        {selected && <Check className="w-3 h-3" />}
      </div>

      {/* Product image */}
      <div className="relative aspect-square bg-muted">
        {product.image_url ? (
          <Image
            src={product.image_url}
            alt={product.name}
            fill
            className="object-cover"
            sizes="(max-width: 768px) 50vw, 25vw"
          />
        ) : (
          <div className="w-full h-full flex items-center justify-center">
            <Package className="w-12 h-12 text-muted-foreground" />
          </div>
        )}
      </div>

      {/* Product info */}
      <div className="p-3 flex-1 flex flex-col gap-1">
        {/* Name */}
        <h4 className="font-medium text-sm line-clamp-2" title={product.name}>
          {product.name}
        </h4>

        {/* Price */}
        <p className="text-base font-semibold text-primary">
          {formatPrice(product.price_amount, product.price_currency)}
        </p>

        {/* Availability */}
        <span
          className={cn(
            'text-xs px-2 py-0.5 rounded-full w-fit',
            availabilityColors[product.availability] || 'bg-gray-100 text-gray-800'
          )}
        >
          {product.availability}
        </span>

        {/* Brand (if available) */}
        {product.brand && (
          <p className="text-xs text-muted-foreground mt-1">{product.brand}</p>
        )}
      </div>
    </div>
  )
}

export default ProductCard
```
  </action>
  <verify>
Run: `npm run type-check`
Component should compile without errors.
  </verify>
  <done>
src/components/messaging/ProductCard.tsx exists with selection states and product display.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ProductPicker component</name>
  <files>src/components/messaging/ProductPicker.tsx</files>
  <action>
Create ProductPicker modal component:

```tsx
'use client'

import * as React from 'react'
import { useState, useEffect, useCallback } from 'react'
import { Search, X, Loader2, ShoppingBag } from 'lucide-react'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { ProductCard } from './ProductCard'
import type { WhatsAppProduct, ProductsListResponse } from '@/types/whatsapp-catalog'

export interface ProductPickerProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  mode: 'single' | 'multi'
  onSelect: (products: WhatsAppProduct[]) => void
  selectedProducts?: WhatsAppProduct[]
  maxProducts?: number
}

export function ProductPicker({
  open,
  onOpenChange,
  mode,
  onSelect,
  selectedProducts = [],
  maxProducts = 30
}: ProductPickerProps) {
  const [products, setProducts] = useState<WhatsAppProduct[]>([])
  const [selected, setSelected] = useState<Map<string, WhatsAppProduct>>(new Map())
  const [search, setSearch] = useState('')
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [hasMore, setHasMore] = useState(false)

  // Initialize selected from props
  useEffect(() => {
    if (open) {
      const map = new Map(selectedProducts.map(p => [p.id, p]))
      setSelected(map)
    }
  }, [open, selectedProducts])

  // Fetch products
  const fetchProducts = useCallback(async (searchQuery: string = '') => {
    setLoading(true)
    setError(null)

    try {
      const params = new URLSearchParams({
        limit: '50',
        offset: '0'
      })
      if (searchQuery) {
        params.set('search', searchQuery)
      }

      const response = await fetch(`/api/whatsapp/products?${params}`)

      if (!response.ok) {
        throw new Error('Failed to fetch products')
      }

      const data: ProductsListResponse = await response.json()
      setProducts(data.products)
      setHasMore(data.hasMore)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load products')
    } finally {
      setLoading(false)
    }
  }, [])

  // Fetch on open and search change
  useEffect(() => {
    if (open) {
      const timeoutId = setTimeout(() => {
        fetchProducts(search)
      }, 300) // Debounce search

      return () => clearTimeout(timeoutId)
    }
  }, [open, search, fetchProducts])

  // Toggle product selection
  const toggleProduct = (product: WhatsAppProduct) => {
    setSelected(prev => {
      const next = new Map(prev)

      if (mode === 'single') {
        // Single select - replace selection
        next.clear()
        next.set(product.id, product)
      } else {
        // Multi select - toggle
        if (next.has(product.id)) {
          next.delete(product.id)
        } else if (next.size < maxProducts) {
          next.set(product.id, product)
        }
      }

      return next
    })
  }

  // Confirm selection
  const handleConfirm = () => {
    onSelect(Array.from(selected.values()))
    onOpenChange(false)
  }

  // Clear selection
  const handleClear = () => {
    setSelected(new Map())
  }

  const selectedCount = selected.size
  const canSelect = mode === 'single' || selectedCount < maxProducts

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-4xl max-h-[80vh] flex flex-col">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <ShoppingBag className="w-5 h-5" />
            {mode === 'single' ? 'Select Product' : 'Select Products'}
          </DialogTitle>
        </DialogHeader>

        {/* Search bar */}
        <div className="relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-muted-foreground" />
          <Input
            placeholder="Search products..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            className="pl-9"
          />
          {search && (
            <button
              onClick={() => setSearch('')}
              className="absolute right-3 top-1/2 -translate-y-1/2"
            >
              <X className="w-4 h-4 text-muted-foreground hover:text-foreground" />
            </button>
          )}
        </div>

        {/* Selection count (multi-select only) */}
        {mode === 'multi' && (
          <div className="flex items-center justify-between text-sm">
            <span className="text-muted-foreground">
              {selectedCount} of {maxProducts} products selected
            </span>
            {selectedCount > 0 && (
              <Button variant="ghost" size="sm" onClick={handleClear}>
                Clear all
              </Button>
            )}
          </div>
        )}

        {/* Products grid */}
        <div className="flex-1 overflow-y-auto min-h-0">
          {loading && products.length === 0 ? (
            <div className="flex items-center justify-center py-12">
              <Loader2 className="w-8 h-8 animate-spin text-muted-foreground" />
            </div>
          ) : error ? (
            <div className="flex flex-col items-center justify-center py-12 text-center">
              <p className="text-destructive mb-2">{error}</p>
              <Button variant="outline" onClick={() => fetchProducts(search)}>
                Retry
              </Button>
            </div>
          ) : products.length === 0 ? (
            <div className="flex flex-col items-center justify-center py-12 text-center text-muted-foreground">
              <ShoppingBag className="w-12 h-12 mb-2" />
              <p>No products found</p>
              {search && <p className="text-sm">Try a different search term</p>}
            </div>
          ) : (
            <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 pb-4">
              {products.map((product) => (
                <ProductCard
                  key={product.id}
                  product={product}
                  selected={selected.has(product.id)}
                  selectionMode={mode}
                  onToggle={() => toggleProduct(product)}
                  disabled={!canSelect && !selected.has(product.id)}
                />
              ))}
            </div>
          )}
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
          <Button
            onClick={handleConfirm}
            disabled={selectedCount === 0}
          >
            {mode === 'single'
              ? 'Select Product'
              : `Select ${selectedCount} Product${selectedCount !== 1 ? 's' : ''}`
            }
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}

export default ProductPicker
```
  </action>
  <verify>
Run: `npm run type-check`
Component should compile with proper dialog and selection logic.
  </verify>
  <done>
src/components/messaging/ProductPicker.tsx exists with search, grid view, and selection modes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ProductMessageComposer component</name>
  <files>src/components/messaging/ProductMessageComposer.tsx</files>
  <action>
Create ProductMessageComposer component:

```tsx
'use client'

import * as React from 'react'
import { useState } from 'react'
import { ShoppingBag, Plus, X, Send, Loader2 } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Label } from '@/components/ui/label'
import { ProductPicker } from './ProductPicker'
import { ProductCard } from './ProductCard'
import type { WhatsAppProduct } from '@/types/whatsapp-catalog'

export interface ProductMessageComposerProps {
  conversationId: string
  onSuccess?: () => void
  onError?: (error: string) => void
}

type MessageType = 'single' | 'multi'

interface Section {
  id: string
  title: string
  products: WhatsAppProduct[]
}

export function ProductMessageComposer({
  conversationId,
  onSuccess,
  onError
}: ProductMessageComposerProps) {
  const [messageType, setMessageType] = useState<MessageType>('single')
  const [pickerOpen, setPickerOpen] = useState(false)
  const [selectedProducts, setSelectedProducts] = useState<WhatsAppProduct[]>([])
  const [sections, setSections] = useState<Section[]>([
    { id: '1', title: 'Products', products: [] }
  ])
  const [bodyText, setBodyText] = useState('')
  const [footerText, setFooterText] = useState('')
  const [headerText, setHeaderText] = useState('')
  const [sending, setSending] = useState(false)

  // Get all selected products for multi-product mode
  const allSelectedProducts = messageType === 'single'
    ? selectedProducts
    : sections.flatMap(s => s.products)

  // Handle product selection from picker
  const handleProductSelect = (products: WhatsAppProduct[]) => {
    if (messageType === 'single') {
      setSelectedProducts(products)
    } else {
      // Add to current section being edited
      // For simplicity, add to first section
      setSections(prev => {
        const next = [...prev]
        next[0] = { ...next[0], products }
        return next
      })
    }
  }

  // Remove product
  const removeProduct = (productId: string) => {
    if (messageType === 'single') {
      setSelectedProducts(prev => prev.filter(p => p.id !== productId))
    } else {
      setSections(prev => prev.map(section => ({
        ...section,
        products: section.products.filter(p => p.id !== productId)
      })))
    }
  }

  // Add section (multi-product only)
  const addSection = () => {
    if (sections.length < 10) {
      setSections(prev => [
        ...prev,
        { id: String(Date.now()), title: `Section ${prev.length + 1}`, products: [] }
      ])
    }
  }

  // Remove section
  const removeSection = (sectionId: string) => {
    if (sections.length > 1) {
      setSections(prev => prev.filter(s => s.id !== sectionId))
    }
  }

  // Update section title
  const updateSectionTitle = (sectionId: string, title: string) => {
    setSections(prev => prev.map(s =>
      s.id === sectionId ? { ...s, title } : s
    ))
  }

  // Send message
  const handleSend = async () => {
    if (allSelectedProducts.length === 0) return

    setSending(true)

    try {
      if (messageType === 'single') {
        // Send single product message
        const response = await fetch('/api/whatsapp/messages/product', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            conversation_id: conversationId,
            product_retailer_id: selectedProducts[0].retailer_id,
            body_text: bodyText || undefined,
            footer_text: footerText || undefined
          })
        })

        if (!response.ok) {
          const error = await response.json()
          throw new Error(error.error || 'Failed to send message')
        }
      } else {
        // Send multi-product message
        const response = await fetch('/api/whatsapp/messages/product-list', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            conversation_id: conversationId,
            header_text: headerText,
            body_text: bodyText,
            footer_text: footerText || undefined,
            sections: sections
              .filter(s => s.products.length > 0)
              .map(s => ({
                title: s.title,
                product_retailer_ids: s.products.map(p => p.retailer_id)
              }))
          })
        })

        if (!response.ok) {
          const error = await response.json()
          throw new Error(error.error || 'Failed to send message')
        }
      }

      // Reset form
      setSelectedProducts([])
      setSections([{ id: '1', title: 'Products', products: [] }])
      setBodyText('')
      setFooterText('')
      setHeaderText('')

      onSuccess?.()
    } catch (error) {
      onError?.(error instanceof Error ? error.message : 'Failed to send message')
    } finally {
      setSending(false)
    }
  }

  const canSend = messageType === 'single'
    ? selectedProducts.length === 1
    : allSelectedProducts.length > 0 && headerText.trim() && bodyText.trim()

  return (
    <div className="flex flex-col gap-4 p-4 border rounded-lg bg-card">
      {/* Message type toggle */}
      <div className="flex gap-2">
        <Button
          variant={messageType === 'single' ? 'default' : 'outline'}
          size="sm"
          onClick={() => {
            setMessageType('single')
            setSections([{ id: '1', title: 'Products', products: [] }])
          }}
        >
          Single Product
        </Button>
        <Button
          variant={messageType === 'multi' ? 'default' : 'outline'}
          size="sm"
          onClick={() => {
            setMessageType('multi')
            setSelectedProducts([])
          }}
        >
          Product List
        </Button>
      </div>

      {/* Header text (multi-product only) */}
      {messageType === 'multi' && (
        <div className="space-y-2">
          <Label htmlFor="header">Header (required)</Label>
          <Input
            id="header"
            placeholder="Browse our products"
            value={headerText}
            onChange={(e) => setHeaderText(e.target.value)}
          />
        </div>
      )}

      {/* Body text */}
      <div className="space-y-2">
        <Label htmlFor="body">
          {messageType === 'single' ? 'Message (optional)' : 'Body (required)'}
        </Label>
        <Textarea
          id="body"
          placeholder="Check out this amazing product!"
          value={bodyText}
          onChange={(e) => setBodyText(e.target.value.slice(0, 1024))}
          rows={2}
        />
        <p className="text-xs text-muted-foreground">{bodyText.length}/1024</p>
      </div>

      {/* Footer text */}
      <div className="space-y-2">
        <Label htmlFor="footer">Footer (optional)</Label>
        <Input
          id="footer"
          placeholder="Reply to order"
          value={footerText}
          onChange={(e) => setFooterText(e.target.value.slice(0, 60))}
        />
        <p className="text-xs text-muted-foreground">{footerText.length}/60</p>
      </div>

      {/* Selected products display */}
      {messageType === 'single' ? (
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <Label>Product</Label>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setPickerOpen(true)}
            >
              <Plus className="w-4 h-4 mr-1" />
              {selectedProducts.length > 0 ? 'Change' : 'Select'}
            </Button>
          </div>

          {selectedProducts.length > 0 && (
            <div className="relative w-48">
              <ProductCard
                product={selectedProducts[0]}
                selected={false}
                selectionMode="single"
                onToggle={() => {}}
              />
              <button
                onClick={() => removeProduct(selectedProducts[0].id)}
                className="absolute -top-2 -right-2 p-1 bg-destructive text-destructive-foreground rounded-full"
              >
                <X className="w-3 h-3" />
              </button>
            </div>
          )}
        </div>
      ) : (
        <div className="space-y-4">
          {sections.map((section, index) => (
            <div key={section.id} className="space-y-2 p-3 border rounded-md">
              <div className="flex items-center gap-2">
                <Input
                  placeholder="Section title"
                  value={section.title}
                  onChange={(e) => updateSectionTitle(section.id, e.target.value)}
                  className="flex-1"
                />
                {sections.length > 1 && (
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={() => removeSection(section.id)}
                  >
                    <X className="w-4 h-4" />
                  </Button>
                )}
              </div>

              <div className="flex flex-wrap gap-2">
                {section.products.map((product) => (
                  <div key={product.id} className="relative">
                    <div className="w-24 h-24 border rounded overflow-hidden">
                      {product.image_url ? (
                        <img
                          src={product.image_url}
                          alt={product.name}
                          className="w-full h-full object-cover"
                        />
                      ) : (
                        <div className="w-full h-full flex items-center justify-center bg-muted">
                          <ShoppingBag className="w-6 h-6 text-muted-foreground" />
                        </div>
                      )}
                    </div>
                    <button
                      onClick={() => removeProduct(product.id)}
                      className="absolute -top-1 -right-1 p-0.5 bg-destructive text-destructive-foreground rounded-full"
                    >
                      <X className="w-3 h-3" />
                    </button>
                  </div>
                ))}

                <Button
                  variant="outline"
                  className="w-24 h-24"
                  onClick={() => setPickerOpen(true)}
                  disabled={allSelectedProducts.length >= 30}
                >
                  <Plus className="w-6 h-6" />
                </Button>
              </div>

              <p className="text-xs text-muted-foreground">
                {section.products.length} products in section
              </p>
            </div>
          ))}

          {sections.length < 10 && (
            <Button variant="outline" onClick={addSection} className="w-full">
              <Plus className="w-4 h-4 mr-1" />
              Add Section
            </Button>
          )}

          <p className="text-sm text-muted-foreground text-center">
            {allSelectedProducts.length}/30 products total
          </p>
        </div>
      )}

      {/* Send button */}
      <Button
        onClick={handleSend}
        disabled={!canSend || sending}
        className="w-full"
      >
        {sending ? (
          <>
            <Loader2 className="w-4 h-4 mr-2 animate-spin" />
            Sending...
          </>
        ) : (
          <>
            <Send className="w-4 h-4 mr-2" />
            Send Product Message
          </>
        )}
      </Button>

      {/* Product picker modal */}
      <ProductPicker
        open={pickerOpen}
        onOpenChange={setPickerOpen}
        mode={messageType}
        onSelect={handleProductSelect}
        selectedProducts={allSelectedProducts}
        maxProducts={messageType === 'single' ? 1 : 30}
      />
    </div>
  )
}

export default ProductMessageComposer
```
  </action>
  <verify>
Run: `npm run type-check`
Run: `npm run lint`
  </verify>
  <done>
src/components/messaging/ProductMessageComposer.tsx exists with full composition UI.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. ProductCard displays product with image, name, price, availability
2. ProductPicker allows searching and selecting products
3. ProductMessageComposer supports single and multi-product modes
4. Multi-product supports up to 10 sections with 30 total products
5. `npm run type-check` passes
6. `npm run lint` passes
</verification>

<success_criteria>
- Products display clearly with image and price
- Search filters products in real-time
- Selection works in both single and multi modes
- Message composition includes header/body/footer
- Send button triggers appropriate API call
</success_criteria>

<output>
After completion, create `.planning/phases/09-whatsapp-catalog/09-04-SUMMARY.md`
</output>
