---
phase: 09-whatsapp-catalog
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/lib/whatsapp/enhanced-client.ts
  - src/lib/channels/adapters/whatsapp.ts
  - src/app/api/whatsapp/products/route.ts
  - src/app/api/whatsapp/messages/product/route.ts
  - src/app/api/whatsapp/messages/product-list/route.ts
autonomous: true

must_haves:
  truths:
    - "EnhancedWhatsAppClient can send single and multi-product messages"
    - "WhatsAppAdapter handles product rich content types"
    - "Products API returns paginated product list with search"
  artifacts:
    - path: "src/app/api/whatsapp/products/route.ts"
      provides: "Products list API"
    - path: "src/app/api/whatsapp/messages/product/route.ts"
      provides: "Single product message API"
    - path: "src/app/api/whatsapp/messages/product-list/route.ts"
      provides: "Multi-product message API"
  key_links:
    - from: "src/app/api/whatsapp/messages/product/route.ts"
      to: "src/lib/whatsapp/enhanced-client.ts"
      via: "sendProductMessage method"
---

<objective>
Add product messaging capabilities to WhatsApp client and create API routes.

Purpose: Enable sending single product and multi-product messages to contacts via the WhatsApp Business API.

Output:
- Extended WhatsApp client with product message methods
- Product listing API with search
- Single product message API
- Multi-product message API
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/09-whatsapp-catalog/09-RESEARCH.md (Part 2: Messages, Part 6: Integration)
@.planning/phases/09-whatsapp-catalog/09-01-SUMMARY.md

Existing code:
@src/lib/whatsapp/enhanced-client.ts
@src/lib/channels/adapters/whatsapp.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add product message methods to WhatsApp client</name>
  <files>src/lib/whatsapp/enhanced-client.ts</files>
  <action>
Add product messaging methods to EnhancedWhatsAppClient:

```typescript
import type { ProductSection } from '@/types/whatsapp-catalog'

/**
 * Send a single product message
 * @param phoneNumberId - Business phone number ID
 * @param to - Recipient phone number
 * @param catalogId - Catalog ID from Commerce Manager
 * @param productRetailerId - Product SKU/retailer ID
 * @param options - Optional body and footer text
 * @returns Message ID
 */
async sendProductMessage(
  phoneNumberId: string,
  to: string,
  catalogId: string,
  productRetailerId: string,
  options?: {
    bodyText?: string
    footerText?: string
  }
): Promise<string> {
  const payload: Record<string, unknown> = {
    messaging_product: 'whatsapp',
    recipient_type: 'individual',
    to,
    type: 'interactive',
    interactive: {
      type: 'product',
      action: {
        catalog_id: catalogId,
        product_retailer_id: productRetailerId
      }
    }
  }

  // Add optional body text
  if (options?.bodyText) {
    (payload.interactive as Record<string, unknown>).body = {
      text: options.bodyText.substring(0, 1024)  // Max 1024 chars
    }
  }

  // Add optional footer text
  if (options?.footerText) {
    (payload.interactive as Record<string, unknown>).footer = {
      text: options.footerText.substring(0, 60)  // Max 60 chars
    }
  }

  const response = await fetch(
    `https://graph.facebook.com/v21.0/${phoneNumberId}/messages`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    }
  )

  if (!response.ok) {
    const error = await response.json()
    throw new Error(`Failed to send product message: ${error.error?.message || response.statusText}`)
  }

  const data = await response.json()
  return data.messages[0].id
}

/**
 * Send a multi-product list message
 * @param phoneNumberId - Business phone number ID
 * @param to - Recipient phone number
 * @param catalogId - Catalog ID from Commerce Manager
 * @param sections - Product sections (max 10 sections, 30 products total)
 * @param options - Required header and body text
 * @returns Message ID
 */
async sendProductListMessage(
  phoneNumberId: string,
  to: string,
  catalogId: string,
  sections: ProductSection[],
  options: {
    headerText: string
    bodyText: string
    footerText?: string
  }
): Promise<string> {
  // Validate constraints
  if (sections.length > 10) {
    throw new Error('Maximum 10 sections allowed')
  }

  const totalProducts = sections.reduce(
    (sum, section) => sum + section.product_items.length,
    0
  )
  if (totalProducts > 30) {
    throw new Error('Maximum 30 products allowed across all sections')
  }

  const payload: Record<string, unknown> = {
    messaging_product: 'whatsapp',
    recipient_type: 'individual',
    to,
    type: 'interactive',
    interactive: {
      type: 'product_list',
      header: {
        type: 'text',
        text: options.headerText
      },
      body: {
        text: options.bodyText
      },
      action: {
        catalog_id: catalogId,
        sections: sections.map(section => ({
          title: section.title,
          product_items: section.product_items
        }))
      }
    }
  }

  // Add optional footer
  if (options.footerText) {
    (payload.interactive as Record<string, unknown>).footer = {
      text: options.footerText.substring(0, 60)
    }
  }

  const response = await fetch(
    `https://graph.facebook.com/v21.0/${phoneNumberId}/messages`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    }
  )

  if (!response.ok) {
    const error = await response.json()
    throw new Error(`Failed to send product list message: ${error.error?.message || response.statusText}`)
  }

  const data = await response.json()
  return data.messages[0].id
}

/**
 * Send a catalog storefront message (opens full catalog)
 * Note: Not available in India
 */
async sendCatalogMessage(
  phoneNumberId: string,
  to: string,
  options: {
    bodyText: string
    footerText?: string
    thumbnailProductRetailerId?: string
  }
): Promise<string> {
  const payload: Record<string, unknown> = {
    messaging_product: 'whatsapp',
    recipient_type: 'individual',
    to,
    type: 'interactive',
    interactive: {
      type: 'catalog_message',
      body: {
        text: options.bodyText
      },
      action: {
        name: 'catalog_message',
        parameters: options.thumbnailProductRetailerId
          ? { thumbnail_product_retailer_id: options.thumbnailProductRetailerId }
          : {}
      }
    }
  }

  if (options.footerText) {
    (payload.interactive as Record<string, unknown>).footer = {
      text: options.footerText.substring(0, 60)
    }
  }

  const response = await fetch(
    `https://graph.facebook.com/v21.0/${phoneNumberId}/messages`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    }
  )

  if (!response.ok) {
    const error = await response.json()
    throw new Error(`Failed to send catalog message: ${error.error?.message || response.statusText}`)
  }

  const data = await response.json()
  return data.messages[0].id
}
```
  </action>
  <verify>
Run: `npm run type-check`
  </verify>
  <done>
EnhancedWhatsAppClient has sendProductMessage, sendProductListMessage, and sendCatalogMessage methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create products list API route</name>
  <files>src/app/api/whatsapp/products/route.ts</files>
  <action>
Create API route for listing products:

```typescript
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import type { ProductsListResponse, WhatsAppProduct } from '@/types/whatsapp-catalog'

// GET - List products from catalog
export async function GET(request: Request) {
  try {
    const supabase = await createClient()

    // Verify authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get user's organization
    const { data: profile } = await supabase
      .from('profiles')
      .select('organization_id')
      .eq('id', user.id)
      .single()

    if (!profile?.organization_id) {
      return NextResponse.json({ error: 'No organization found' }, { status: 404 })
    }

    // Parse query parameters
    const { searchParams } = new URL(request.url)
    const search = searchParams.get('search') || ''
    const availability = searchParams.get('availability')
    const limit = Math.min(parseInt(searchParams.get('limit') || '50', 10), 100)
    const offset = parseInt(searchParams.get('offset') || '0', 10)

    // Build query
    let query = supabase
      .from('whatsapp_products')
      .select('*', { count: 'exact' })
      .eq('organization_id', profile.organization_id)
      .eq('is_active', true)

    // Search filter
    if (search) {
      query = query.or(`name.ilike.%${search}%,description.ilike.%${search}%`)
    }

    // Availability filter
    if (availability) {
      query = query.eq('availability', availability)
    }

    // Pagination
    query = query
      .order('name')
      .range(offset, offset + limit - 1)

    const { data: products, count, error } = await query

    if (error) {
      console.error('Error fetching products:', error)
      return NextResponse.json({ error: 'Failed to fetch products' }, { status: 500 })
    }

    const response: ProductsListResponse = {
      products: products || [],
      total: count || 0,
      hasMore: (count || 0) > offset + limit
    }

    return NextResponse.json(response)

  } catch (error) {
    console.error('Products API error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
```
  </action>
  <verify>
Run: `npm run type-check`
  </verify>
  <done>
src/app/api/whatsapp/products/route.ts exists with GET handler.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create single product message API route</name>
  <files>src/app/api/whatsapp/messages/product/route.ts</files>
  <action>
Create API route for sending single product messages:

```typescript
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { getWhatsAppClient } from '@/lib/whatsapp/enhanced-client'
import type { SendProductMessageRequest } from '@/types/whatsapp-catalog'

// POST - Send single product message
export async function POST(request: Request) {
  try {
    const supabase = await createClient()

    // Verify authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get user's profile
    const { data: profile } = await supabase
      .from('profiles')
      .select('organization_id')
      .eq('id', user.id)
      .single()

    if (!profile?.organization_id) {
      return NextResponse.json({ error: 'No organization found' }, { status: 404 })
    }

    // Parse request body
    const body: SendProductMessageRequest = await request.json()

    // Validate required fields
    if (!body.conversation_id || !body.product_retailer_id) {
      return NextResponse.json(
        { error: 'conversation_id and product_retailer_id are required' },
        { status: 400 }
      )
    }

    // Get conversation with contact info
    const { data: conversation, error: convError } = await supabase
      .from('conversations')
      .select(`
        id,
        contact_id,
        contacts (
          phone_number
        )
      `)
      .eq('id', body.conversation_id)
      .eq('organization_id', profile.organization_id)
      .single()

    if (convError || !conversation) {
      return NextResponse.json({ error: 'Conversation not found' }, { status: 404 })
    }

    const contact = conversation.contacts as { phone_number: string } | null
    if (!contact?.phone_number) {
      return NextResponse.json({ error: 'Contact has no phone number' }, { status: 400 })
    }

    // Get catalog config
    const { data: catalog, error: catalogError } = await supabase
      .from('whatsapp_catalogs')
      .select('catalog_id')
      .eq('organization_id', profile.organization_id)
      .single()

    if (catalogError || !catalog) {
      return NextResponse.json({ error: 'No catalog configured' }, { status: 400 })
    }

    // Get product to verify it exists
    const { data: product, error: productError } = await supabase
      .from('whatsapp_products')
      .select('id, retailer_id')
      .eq('organization_id', profile.organization_id)
      .eq('retailer_id', body.product_retailer_id)
      .eq('is_active', true)
      .single()

    if (productError || !product) {
      return NextResponse.json({ error: 'Product not found' }, { status: 404 })
    }

    // Get organization's WhatsApp config
    const { data: org } = await supabase
      .from('organizations')
      .select('whatsapp_phone_number_id')
      .eq('id', profile.organization_id)
      .single()

    if (!org?.whatsapp_phone_number_id) {
      return NextResponse.json({ error: 'WhatsApp not configured' }, { status: 400 })
    }

    // Send message
    const client = await getWhatsAppClient(profile.organization_id)
    const messageId = await client.sendProductMessage(
      org.whatsapp_phone_number_id,
      contact.phone_number,
      catalog.catalog_id,
      body.product_retailer_id,
      {
        bodyText: body.body_text,
        footerText: body.footer_text
      }
    )

    // Create message record
    const { data: message, error: msgError } = await supabase
      .from('messages')
      .insert({
        conversation_id: body.conversation_id,
        organization_id: profile.organization_id,
        direction: 'outbound',
        content: body.body_text || `Product: ${product.retailer_id}`,
        message_type: 'interactive',
        status: 'sent',
        whatsapp_message_id: messageId,
        sent_at: new Date().toISOString()
      })
      .select('id')
      .single()

    // Track product message
    await supabase
      .from('whatsapp_product_messages')
      .insert({
        organization_id: profile.organization_id,
        conversation_id: body.conversation_id,
        message_id: message?.id || null,
        message_type: 'single',
        product_ids: [product.id],
        retailer_ids: [product.retailer_id],
        catalog_id: catalog.catalog_id,
        body_text: body.body_text,
        footer_text: body.footer_text
      })

    return NextResponse.json({
      success: true,
      messageId,
      message_id: message?.id
    })

  } catch (error) {
    console.error('Product message API error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
```
  </action>
  <verify>
Run: `npm run type-check`
  </verify>
  <done>
src/app/api/whatsapp/messages/product/route.ts exists with POST handler.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create multi-product message API route</name>
  <files>src/app/api/whatsapp/messages/product-list/route.ts</files>
  <action>
Create API route for sending multi-product messages:

```typescript
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { getWhatsAppClient } from '@/lib/whatsapp/enhanced-client'
import type { SendProductListMessageRequest, ProductSection } from '@/types/whatsapp-catalog'

// POST - Send multi-product list message
export async function POST(request: Request) {
  try {
    const supabase = await createClient()

    // Verify authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get user's profile
    const { data: profile } = await supabase
      .from('profiles')
      .select('organization_id')
      .eq('id', user.id)
      .single()

    if (!profile?.organization_id) {
      return NextResponse.json({ error: 'No organization found' }, { status: 404 })
    }

    // Parse request body
    const body: SendProductListMessageRequest = await request.json()

    // Validate required fields
    if (!body.conversation_id || !body.header_text || !body.body_text || !body.sections?.length) {
      return NextResponse.json(
        { error: 'conversation_id, header_text, body_text, and sections are required' },
        { status: 400 }
      )
    }

    // Validate constraints
    if (body.sections.length > 10) {
      return NextResponse.json({ error: 'Maximum 10 sections allowed' }, { status: 400 })
    }

    const allProductIds = body.sections.flatMap(s => s.product_retailer_ids)
    if (allProductIds.length > 30) {
      return NextResponse.json({ error: 'Maximum 30 products allowed' }, { status: 400 })
    }

    // Get conversation with contact info
    const { data: conversation, error: convError } = await supabase
      .from('conversations')
      .select(`
        id,
        contact_id,
        contacts (
          phone_number
        )
      `)
      .eq('id', body.conversation_id)
      .eq('organization_id', profile.organization_id)
      .single()

    if (convError || !conversation) {
      return NextResponse.json({ error: 'Conversation not found' }, { status: 404 })
    }

    const contact = conversation.contacts as { phone_number: string } | null
    if (!contact?.phone_number) {
      return NextResponse.json({ error: 'Contact has no phone number' }, { status: 400 })
    }

    // Get catalog config
    const { data: catalog, error: catalogError } = await supabase
      .from('whatsapp_catalogs')
      .select('catalog_id')
      .eq('organization_id', profile.organization_id)
      .single()

    if (catalogError || !catalog) {
      return NextResponse.json({ error: 'No catalog configured' }, { status: 400 })
    }

    // Verify all products exist
    const { data: products, error: productsError } = await supabase
      .from('whatsapp_products')
      .select('id, retailer_id')
      .eq('organization_id', profile.organization_id)
      .in('retailer_id', allProductIds)
      .eq('is_active', true)

    if (productsError || !products || products.length !== allProductIds.length) {
      const foundIds = (products || []).map(p => p.retailer_id)
      const missingIds = allProductIds.filter(id => !foundIds.includes(id))
      return NextResponse.json(
        { error: `Products not found: ${missingIds.join(', ')}` },
        { status: 404 }
      )
    }

    // Get organization's WhatsApp config
    const { data: org } = await supabase
      .from('organizations')
      .select('whatsapp_phone_number_id')
      .eq('id', profile.organization_id)
      .single()

    if (!org?.whatsapp_phone_number_id) {
      return NextResponse.json({ error: 'WhatsApp not configured' }, { status: 400 })
    }

    // Convert sections format
    const sections: ProductSection[] = body.sections.map(section => ({
      title: section.title,
      product_items: section.product_retailer_ids.map(id => ({
        product_retailer_id: id
      }))
    }))

    // Send message
    const client = await getWhatsAppClient(profile.organization_id)
    const messageId = await client.sendProductListMessage(
      org.whatsapp_phone_number_id,
      contact.phone_number,
      catalog.catalog_id,
      sections,
      {
        headerText: body.header_text,
        bodyText: body.body_text,
        footerText: body.footer_text
      }
    )

    // Create message record
    const { data: message, error: msgError } = await supabase
      .from('messages')
      .insert({
        conversation_id: body.conversation_id,
        organization_id: profile.organization_id,
        direction: 'outbound',
        content: body.body_text,
        message_type: 'interactive',
        status: 'sent',
        whatsapp_message_id: messageId,
        sent_at: new Date().toISOString()
      })
      .select('id')
      .single()

    // Track product message
    const productMap = new Map(products.map(p => [p.retailer_id, p.id]))
    await supabase
      .from('whatsapp_product_messages')
      .insert({
        organization_id: profile.organization_id,
        conversation_id: body.conversation_id,
        message_id: message?.id || null,
        message_type: 'multi',
        product_ids: allProductIds.map(id => productMap.get(id)),
        retailer_ids: allProductIds,
        catalog_id: catalog.catalog_id,
        header_text: body.header_text,
        body_text: body.body_text,
        footer_text: body.footer_text,
        sections: body.sections
      })

    return NextResponse.json({
      success: true,
      messageId,
      message_id: message?.id,
      products_sent: allProductIds.length
    })

  } catch (error) {
    console.error('Product list message API error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
```
  </action>
  <verify>
Run: `npm run type-check`
Run: `npm run lint`
  </verify>
  <done>
src/app/api/whatsapp/messages/product-list/route.ts exists with POST handler.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. EnhancedWhatsAppClient has all product message methods
2. GET /api/whatsapp/products returns paginated products
3. POST /api/whatsapp/messages/product sends single product message
4. POST /api/whatsapp/messages/product-list sends multi-product message
5. Product messages are tracked in whatsapp_product_messages table
6. `npm run type-check` passes
7. `npm run lint` passes
</verification>

<success_criteria>
- Single product messages send via WhatsApp API
- Multi-product messages send with sections
- Products can be searched and filtered
- Message tracking captures all sent product messages
</success_criteria>

<output>
After completion, create `.planning/phases/09-whatsapp-catalog/09-03-SUMMARY.md`
</output>
