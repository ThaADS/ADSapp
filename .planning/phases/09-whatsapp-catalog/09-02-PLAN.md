---
phase: 09-whatsapp-catalog
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/lib/whatsapp/enhanced-client.ts
  - src/lib/whatsapp/catalog-sync.ts
  - src/app/api/whatsapp/catalog/route.ts
  - src/app/api/whatsapp/catalog/sync/route.ts
autonomous: true

must_haves:
  truths:
    - "EnhancedWhatsAppClient has getCatalogProducts method"
    - "CatalogSyncService syncs products from Meta to database"
    - "API routes allow configuring and syncing catalogs"
  artifacts:
    - path: "src/lib/whatsapp/catalog-sync.ts"
      provides: "Catalog sync service"
      exports: ["CatalogSyncService", "syncCatalog"]
    - path: "src/app/api/whatsapp/catalog/route.ts"
      provides: "Catalog configuration API"
    - path: "src/app/api/whatsapp/catalog/sync/route.ts"
      provides: "Catalog sync trigger API"
  key_links:
    - from: "src/lib/whatsapp/catalog-sync.ts"
      to: "src/lib/whatsapp/enhanced-client.ts"
      via: "getWhatsAppClient import"
---

<objective>
Build catalog sync service that fetches products from Meta Commerce Manager.

Purpose: Enable organizations to sync their WhatsApp Business catalog products into ADSapp for use in product messaging.

Output:
- Extended WhatsApp client with catalog methods
- CatalogSyncService for product syncing
- API routes for catalog configuration and sync
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/09-whatsapp-catalog/09-RESEARCH.md (Part 2: API, Part 6: Integration)
@.planning/phases/09-whatsapp-catalog/09-01-SUMMARY.md

Existing code:
@src/lib/whatsapp/enhanced-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend EnhancedWhatsAppClient with catalog methods</name>
  <files>src/lib/whatsapp/enhanced-client.ts</files>
  <action>
Add catalog-related methods to EnhancedWhatsAppClient:

1. **Import types** at top:
   ```typescript
   import type { MetaCatalogProductsResponse, MetaCatalogProduct } from '@/types/whatsapp-catalog'
   ```

2. **Add getCatalogProducts method**:
   ```typescript
   /**
    * Get products from a Meta Commerce Manager catalog
    * @param catalogId - The catalog ID from Commerce Manager
    * @param limit - Number of products to fetch (default 50)
    * @param after - Pagination cursor for next page
    */
   async getCatalogProducts(
     catalogId: string,
     limit: number = 50,
     after?: string
   ): Promise<MetaCatalogProductsResponse> {
     const fields = 'id,retailer_id,name,description,price,currency,availability,image_url,url,brand,category'
     let url = `https://graph.facebook.com/v21.0/${catalogId}/products?fields=${fields}&limit=${limit}`

     if (after) {
       url += `&after=${after}`
     }

     const response = await fetch(url, {
       headers: {
         'Authorization': `Bearer ${this.accessToken}`
       }
     })

     if (!response.ok) {
       const error = await response.json()
       throw new Error(`Failed to fetch catalog products: ${error.error?.message || response.statusText}`)
     }

     return response.json()
   }

   /**
    * Get all products from catalog with automatic pagination
    * @param catalogId - The catalog ID from Commerce Manager
    * @param maxProducts - Maximum products to fetch (default 1000)
    */
   async getAllCatalogProducts(
     catalogId: string,
     maxProducts: number = 1000
   ): Promise<MetaCatalogProduct[]> {
     const allProducts: MetaCatalogProduct[] = []
     let cursor: string | undefined

     while (allProducts.length < maxProducts) {
       const response = await this.getCatalogProducts(catalogId, 50, cursor)
       allProducts.push(...response.data)

       if (!response.paging?.next) {
         break
       }
       cursor = response.paging.cursors.after
     }

     return allProducts.slice(0, maxProducts)
   }
   ```

3. **Add getLinkedCatalogs method** (get catalogs linked to WABA):
   ```typescript
   /**
    * Get catalogs linked to the WhatsApp Business Account
    * @param wabaId - WhatsApp Business Account ID
    */
   async getLinkedCatalogs(wabaId: string): Promise<{ id: string; name: string }[]> {
     const url = `https://graph.facebook.com/v21.0/${wabaId}/product_catalogs`

     const response = await fetch(url, {
       headers: {
         'Authorization': `Bearer ${this.accessToken}`
       }
     })

     if (!response.ok) {
       const error = await response.json()
       throw new Error(`Failed to fetch linked catalogs: ${error.error?.message || response.statusText}`)
     }

     const data = await response.json()
     return data.data || []
   }
   ```
  </action>
  <verify>
Run: `npm run type-check`
New methods should compile without errors.
  </verify>
  <done>
EnhancedWhatsAppClient has getCatalogProducts, getAllCatalogProducts, and getLinkedCatalogs methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CatalogSyncService</name>
  <files>src/lib/whatsapp/catalog-sync.ts</files>
  <action>
Create catalog sync service:

```typescript
import { createClient } from '@/lib/supabase/server'
import { getWhatsAppClient } from './enhanced-client'
import type {
  WhatsAppCatalog,
  WhatsAppProduct,
  MetaCatalogProduct,
  CatalogSyncStatus
} from '@/types/whatsapp-catalog'

export interface SyncResult {
  success: boolean
  productsAdded: number
  productsUpdated: number
  productsRemoved: number
  errors: string[]
}

export class CatalogSyncService {
  private organizationId: string

  constructor(organizationId: string) {
    this.organizationId = organizationId
  }

  /**
   * Sync products from Meta Commerce Manager to database
   */
  async syncCatalog(): Promise<SyncResult> {
    const supabase = await createClient()
    const result: SyncResult = {
      success: false,
      productsAdded: 0,
      productsUpdated: 0,
      productsRemoved: 0,
      errors: []
    }

    try {
      // 1. Get catalog config
      const { data: catalog, error: catalogError } = await supabase
        .from('whatsapp_catalogs')
        .select('*')
        .eq('organization_id', this.organizationId)
        .single()

      if (catalogError || !catalog) {
        result.errors.push('No catalog configured for this organization')
        return result
      }

      // 2. Update sync status to 'syncing'
      await this.updateSyncStatus(catalog.id, 'syncing')

      // 3. Get WhatsApp client
      const client = await getWhatsAppClient(this.organizationId)

      // 4. Fetch all products from Meta
      const metaProducts = await client.getAllCatalogProducts(catalog.catalog_id)

      // 5. Get existing products
      const { data: existingProducts } = await supabase
        .from('whatsapp_products')
        .select('id, retailer_id')
        .eq('catalog_id', catalog.id)

      const existingMap = new Map(
        (existingProducts || []).map(p => [p.retailer_id, p.id])
      )
      const syncedRetailerIds = new Set<string>()

      // 6. Upsert products
      for (const metaProduct of metaProducts) {
        try {
          const productData = this.mapMetaProductToDb(metaProduct, catalog.id)
          syncedRetailerIds.add(metaProduct.retailer_id)

          if (existingMap.has(metaProduct.retailer_id)) {
            // Update existing
            const { error } = await supabase
              .from('whatsapp_products')
              .update({
                ...productData,
                synced_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
              })
              .eq('id', existingMap.get(metaProduct.retailer_id))

            if (error) {
              result.errors.push(`Failed to update ${metaProduct.retailer_id}: ${error.message}`)
            } else {
              result.productsUpdated++
            }
          } else {
            // Insert new
            const { error } = await supabase
              .from('whatsapp_products')
              .insert({
                ...productData,
                organization_id: this.organizationId,
                catalog_id: catalog.id
              })

            if (error) {
              result.errors.push(`Failed to add ${metaProduct.retailer_id}: ${error.message}`)
            } else {
              result.productsAdded++
            }
          }
        } catch (err) {
          result.errors.push(`Error processing ${metaProduct.retailer_id}: ${err}`)
        }
      }

      // 7. Mark removed products as inactive
      for (const [retailerId, productId] of existingMap) {
        if (!syncedRetailerIds.has(retailerId)) {
          const { error } = await supabase
            .from('whatsapp_products')
            .update({ is_active: false, updated_at: new Date().toISOString() })
            .eq('id', productId)

          if (!error) {
            result.productsRemoved++
          }
        }
      }

      // 8. Update catalog with sync success
      await this.updateSyncStatus(catalog.id, 'success', null, metaProducts.length)

      result.success = true
      return result

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      result.errors.push(errorMessage)

      // Update catalog with sync error
      const { data: catalog } = await supabase
        .from('whatsapp_catalogs')
        .select('id')
        .eq('organization_id', this.organizationId)
        .single()

      if (catalog) {
        await this.updateSyncStatus(catalog.id, 'error', errorMessage)
      }

      return result
    }
  }

  private mapMetaProductToDb(meta: MetaCatalogProduct, catalogId: string): Partial<WhatsAppProduct> {
    return {
      meta_product_id: meta.id,
      retailer_id: meta.retailer_id,
      name: meta.name,
      description: meta.description || null,
      price_amount: meta.price ? parseInt(meta.price, 10) : null,
      price_currency: meta.currency || 'USD',
      availability: (meta.availability as WhatsAppProduct['availability']) || 'in stock',
      image_url: meta.image_url || null,
      product_url: meta.url || null,
      brand: meta.brand || null,
      category: meta.category || null,
      raw_data: meta as unknown as Record<string, unknown>,
      is_active: true
    }
  }

  private async updateSyncStatus(
    catalogId: string,
    status: CatalogSyncStatus,
    error?: string | null,
    productCount?: number
  ): Promise<void> {
    const supabase = await createClient()

    const update: Partial<WhatsAppCatalog> = {
      sync_status: status,
      updated_at: new Date().toISOString()
    }

    if (status === 'success') {
      update.last_sync_at = new Date().toISOString()
      update.sync_error = null
    }

    if (error !== undefined) {
      update.sync_error = error
    }

    if (productCount !== undefined) {
      update.product_count = productCount
    }

    await supabase
      .from('whatsapp_catalogs')
      .update(update)
      .eq('id', catalogId)
  }
}

// Convenience function for one-off sync
export async function syncCatalog(organizationId: string): Promise<SyncResult> {
  const service = new CatalogSyncService(organizationId)
  return service.syncCatalog()
}
```
  </action>
  <verify>
Run: `npm run type-check`
Service should compile without errors.
  </verify>
  <done>
src/lib/whatsapp/catalog-sync.ts exists with CatalogSyncService and syncCatalog function.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create catalog configuration API route</name>
  <files>src/app/api/whatsapp/catalog/route.ts</files>
  <action>
Create API route for catalog configuration:

```typescript
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { QueryValidators } from '@/lib/supabase/server'
import type { CatalogConfigRequest, WhatsAppCatalog } from '@/types/whatsapp-catalog'

// GET - Get organization's catalog configuration
export async function GET() {
  try {
    const supabase = await createClient()

    // Verify authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get user's organization
    const { data: profile } = await supabase
      .from('profiles')
      .select('organization_id')
      .eq('id', user.id)
      .single()

    if (!profile?.organization_id) {
      return NextResponse.json({ error: 'No organization found' }, { status: 404 })
    }

    // Get catalog config (RLS filters by organization)
    const { data: catalog, error } = await supabase
      .from('whatsapp_catalogs')
      .select('*')
      .eq('organization_id', profile.organization_id)
      .maybeSingle()

    if (error) {
      console.error('Error fetching catalog:', error)
      return NextResponse.json({ error: 'Failed to fetch catalog' }, { status: 500 })
    }

    return NextResponse.json({ catalog })

  } catch (error) {
    console.error('Catalog API error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

// POST - Configure catalog for organization
export async function POST(request: Request) {
  try {
    const supabase = await createClient()

    // Verify authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get user's profile with role
    const { data: profile } = await supabase
      .from('profiles')
      .select('organization_id, role')
      .eq('id', user.id)
      .single()

    if (!profile?.organization_id) {
      return NextResponse.json({ error: 'No organization found' }, { status: 404 })
    }

    // Check admin permission
    if (!['owner', 'admin'].includes(profile.role)) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    // Parse and validate request body
    const body: CatalogConfigRequest = await request.json()

    if (!body.catalog_id || typeof body.catalog_id !== 'string') {
      return NextResponse.json({ error: 'catalog_id is required' }, { status: 400 })
    }

    // Upsert catalog config
    const { data: catalog, error } = await supabase
      .from('whatsapp_catalogs')
      .upsert({
        organization_id: profile.organization_id,
        catalog_id: body.catalog_id,
        catalog_name: body.catalog_name || null,
        sync_status: 'pending',
        updated_at: new Date().toISOString()
      }, {
        onConflict: 'organization_id'
      })
      .select()
      .single()

    if (error) {
      console.error('Error saving catalog config:', error)
      return NextResponse.json({ error: 'Failed to save catalog configuration' }, { status: 500 })
    }

    return NextResponse.json({ catalog })

  } catch (error) {
    console.error('Catalog API error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

// DELETE - Remove catalog configuration
export async function DELETE() {
  try {
    const supabase = await createClient()

    // Verify authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get user's profile with role
    const { data: profile } = await supabase
      .from('profiles')
      .select('organization_id, role')
      .eq('id', user.id)
      .single()

    if (!profile?.organization_id) {
      return NextResponse.json({ error: 'No organization found' }, { status: 404 })
    }

    // Check admin permission
    if (!['owner', 'admin'].includes(profile.role)) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    // Delete catalog (cascades to products and messages)
    const { error } = await supabase
      .from('whatsapp_catalogs')
      .delete()
      .eq('organization_id', profile.organization_id)

    if (error) {
      console.error('Error deleting catalog:', error)
      return NextResponse.json({ error: 'Failed to delete catalog' }, { status: 500 })
    }

    return NextResponse.json({ success: true })

  } catch (error) {
    console.error('Catalog API error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
```
  </action>
  <verify>
Run: `npm run type-check`
Route should compile without errors.
  </verify>
  <done>
src/app/api/whatsapp/catalog/route.ts exists with GET, POST, DELETE handlers.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create catalog sync API route</name>
  <files>src/app/api/whatsapp/catalog/sync/route.ts</files>
  <action>
Create API route for triggering catalog sync:

```typescript
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { syncCatalog } from '@/lib/whatsapp/catalog-sync'
import type { CatalogSyncResponse } from '@/types/whatsapp-catalog'

// POST - Trigger catalog sync
export async function POST() {
  try {
    const supabase = await createClient()

    // Verify authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get user's profile with role
    const { data: profile } = await supabase
      .from('profiles')
      .select('organization_id, role')
      .eq('id', user.id)
      .single()

    if (!profile?.organization_id) {
      return NextResponse.json({ error: 'No organization found' }, { status: 404 })
    }

    // Check admin permission
    if (!['owner', 'admin'].includes(profile.role)) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    // Check if catalog is configured
    const { data: catalog } = await supabase
      .from('whatsapp_catalogs')
      .select('id, sync_status')
      .eq('organization_id', profile.organization_id)
      .single()

    if (!catalog) {
      return NextResponse.json({ error: 'No catalog configured' }, { status: 400 })
    }

    // Check if already syncing
    if (catalog.sync_status === 'syncing') {
      return NextResponse.json({ error: 'Sync already in progress' }, { status: 409 })
    }

    // Trigger sync
    const result = await syncCatalog(profile.organization_id)

    const response: CatalogSyncResponse = {
      success: result.success,
      products_synced: result.productsAdded + result.productsUpdated,
      errors: result.errors.length > 0 ? result.errors : undefined
    }

    return NextResponse.json(response)

  } catch (error) {
    console.error('Catalog sync API error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
```
  </action>
  <verify>
Run: `npm run type-check`
Run: `npm run lint`
  </verify>
  <done>
src/app/api/whatsapp/catalog/sync/route.ts exists with POST handler for sync trigger.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. EnhancedWhatsAppClient has catalog methods
2. CatalogSyncService can sync products
3. GET /api/whatsapp/catalog returns catalog config
4. POST /api/whatsapp/catalog saves catalog config
5. POST /api/whatsapp/catalog/sync triggers sync
6. `npm run type-check` passes
7. `npm run lint` passes
</verification>

<success_criteria>
- Catalog products can be fetched from Meta API
- Products are synced to database with proper organization isolation
- API routes handle authentication and authorization
- Sync status is tracked (pending/syncing/success/error)
</success_criteria>

<output>
After completion, create `.planning/phases/09-whatsapp-catalog/09-02-SUMMARY.md`
</output>
