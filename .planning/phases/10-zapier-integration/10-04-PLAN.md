---
phase: 10-zapier-integration
plan: 04
type: execute
wave: 1
depends_on: ["10-01", "10-02", "10-03"]
files_modified:
  - src/app/api/integrations/zapier/hooks/subscribe/route.ts
  - src/app/api/integrations/zapier/hooks/[id]/route.ts
  - src/lib/integrations/zapier/webhook-service.ts
  - src/lib/integrations/zapier/event-emitter.ts
  - src/lib/integrations/zapier/index.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Zapier can subscribe to message.received events via REST Hook"
    - "Zapier can subscribe to contact.created events via REST Hook"
    - "Zapier can unsubscribe from webhooks"
    - "Webhook deliveries are sent to target_url when events occur"
  artifacts:
    - path: "src/app/api/integrations/zapier/hooks/subscribe/route.ts"
      provides: "POST endpoint for REST Hook subscription"
      exports: ["POST"]
    - path: "src/app/api/integrations/zapier/hooks/[id]/route.ts"
      provides: "DELETE endpoint for unsubscribe"
      exports: ["DELETE"]
    - path: "src/lib/integrations/zapier/webhook-service.ts"
      provides: "Webhook delivery with retry logic"
      exports: ["WebhookService", "deliverWebhook", "processRetries"]
    - path: "src/lib/integrations/zapier/event-emitter.ts"
      provides: "Event emission for message/contact events"
      exports: ["emitZapierEvent", "ZapierEventEmitter"]
  key_links:
    - from: "subscribe/route.ts"
      to: "zapier_subscriptions table"
      via: "supabase insert"
      pattern: "supabase.*zapier_subscriptions.*insert"
    - from: "webhook-service.ts"
      to: "target_url"
      via: "fetch POST"
      pattern: "fetch.*POST.*target_url"
    - from: "event-emitter.ts"
      to: "webhook-service.ts"
      via: "deliverWebhook call"
      pattern: "deliverWebhook"
---

<objective>
Implement REST Hook trigger endpoints and webhook delivery system for Zapier integration

Purpose: Enable Zapier to subscribe to ADSapp events (new messages, new contacts) and receive real-time webhook notifications when those events occur. This closes Gap 1 from VERIFICATION.md (ZAP-02, ZAP-03, ZAP-06).

Output:
- REST Hook subscribe endpoint (POST /api/integrations/zapier/hooks/subscribe)
- Unsubscribe endpoint (DELETE /api/integrations/zapier/hooks/{id})
- Webhook delivery service with retry logic
- Event emitter that triggers webhook delivery
</objective>

<execution_context>
@C:\Users\info\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\info\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-zapier-integration/10-01-SUMMARY.md
@.planning/phases/10-zapier-integration/10-02-SUMMARY.md
@.planning/phases/10-zapier-integration/10-03-SUMMARY.md

# Key existing files to reference
@src/lib/integrations/zapier/middleware.ts
@src/lib/integrations/zapier/index.ts
@src/types/zapier.ts
@supabase/migrations/20260124_zapier_webhooks.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create REST Hook Subscribe Endpoint</name>
  <files>
    src/app/api/integrations/zapier/hooks/subscribe/route.ts
    src/app/api/integrations/zapier/hooks/[id]/route.ts
  </files>
  <action>
Create POST /api/integrations/zapier/hooks/subscribe endpoint:

1. Use withZapierMiddleware() wrapper with:
   - rateLimitType: 'subscribe' (10 req/min)
   - requiredScopes: ['triggers:write']

2. Parse request body matching SubscribeRequest type from src/types/zapier.ts:
   ```typescript
   interface SubscribeRequest {
     event: ZapierEventType  // 'message.received' | 'contact.created' | etc.
     hookUrl: string
     filters?: {
       tags?: { operator?: FilterOperator; values: string[] }
       segments?: string[]
     }
   }
   ```

3. Validate inputs:
   - event must be valid ZapierEventType
   - hookUrl must be valid HTTPS URL (Zapier always uses HTTPS)
   - filters are optional

4. Insert into zapier_subscriptions table using createServiceRoleClient():
   ```typescript
   const { data, error } = await supabase
     .from('zapier_subscriptions')
     .insert({
       organization_id: context.organizationId,
       user_id: context.userId,
       event_type: body.event,
       target_url: body.hookUrl,
       filter_tags: body.filters?.tags?.values,
       filter_segments: body.filters?.segments,
       filter_operator: body.filters?.tags?.operator || 'any_of',
       is_active: true
     })
     .select()
     .single()
   ```

5. Return SubscribeResponse:
   ```typescript
   { id, event, hookUrl: target_url, active: true, createdAt }
   ```

Create DELETE /api/integrations/zapier/hooks/[id] endpoint:

1. Use withZapierMiddleware() with:
   - rateLimitType: 'subscribe'
   - requiredScopes: ['triggers:write']

2. Extract subscription ID from URL params

3. Verify subscription belongs to user's organization:
   ```typescript
   const { data: subscription } = await supabase
     .from('zapier_subscriptions')
     .select('organization_id')
     .eq('id', subscriptionId)
     .single()

   if (subscription?.organization_id !== context.organizationId) {
     return createErrorResponse('not_found', 'Subscription not found', 404)
   }
   ```

4. Delete subscription (or mark inactive):
   ```typescript
   await supabase
     .from('zapier_subscriptions')
     .delete()
     .eq('id', subscriptionId)
   ```

5. Return 200 OK with empty body (REST Hook spec)
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit src/app/api/integrations/zapier/hooks/subscribe/route.ts
npx tsc --noEmit src/app/api/integrations/zapier/hooks/[id]/route.ts
```
  </verify>
  <done>
- POST /api/integrations/zapier/hooks/subscribe creates subscription in database
- DELETE /api/integrations/zapier/hooks/{id} removes subscription
- Both endpoints use withZapierMiddleware() for auth and rate limiting
- Inputs validated, errors return proper HTTP codes
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Webhook Delivery Service</name>
  <files>
    src/lib/integrations/zapier/webhook-service.ts
  </files>
  <action>
Create webhook-service.ts with the following components:

1. **WebhookService class** with methods:

```typescript
import { createServiceRoleClient } from '@/lib/supabase/server'
import type {
  WebhookPayload,
  ZapierEventType,
  WEBHOOK_RETRY_DELAYS,
  WEBHOOK_TIMEOUT,
  MAX_WEBHOOK_RETRIES
} from '@/types/zapier'

export class WebhookService {
  /**
   * Deliver webhook to target URL with retry logic
   */
  async deliverWebhook(
    subscriptionId: string,
    payload: WebhookPayload
  ): Promise<boolean> {
    const supabase = createServiceRoleClient()

    // Get subscription details
    const { data: subscription } = await supabase
      .from('zapier_subscriptions')
      .select('*')
      .eq('id', subscriptionId)
      .eq('is_active', true)
      .single()

    if (!subscription) return false

    // Create delivery record
    const { data: delivery } = await supabase
      .from('zapier_webhook_deliveries')
      .insert({
        subscription_id: subscriptionId,
        organization_id: subscription.organization_id,
        event_type: payload.event,
        event_id: payload.id,
        payload: payload,
        status: 'pending',
        attempt_count: 1
      })
      .select()
      .single()

    // Attempt delivery
    return this.attemptDelivery(delivery.id, subscription.target_url, payload)
  }

  /**
   * Attempt to POST payload to target URL
   */
  private async attemptDelivery(
    deliveryId: string,
    targetUrl: string,
    payload: WebhookPayload
  ): Promise<boolean> {
    const supabase = createServiceRoleClient()

    try {
      const controller = new AbortController()
      const timeoutId = setTimeout(() => controller.abort(), WEBHOOK_TIMEOUT)

      const response = await fetch(targetUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Hook-Secret': process.env.ZAPIER_WEBHOOK_SECRET || '',
          'User-Agent': 'ADSapp-Webhook/1.0'
        },
        body: JSON.stringify(payload),
        signal: controller.signal
      })

      clearTimeout(timeoutId)

      // Handle 410 Gone - deactivate subscription
      if (response.status === 410) {
        await this.deactivateSubscription(deliveryId)
        await this.markDeliveryAbandoned(deliveryId, 410, 'Subscription removed by Zapier')
        return false
      }

      // Success (2xx)
      if (response.ok) {
        await this.markDeliverySuccess(deliveryId, response.status)
        await this.updateSubscriptionTrigger(deliveryId)
        return true
      }

      // Failure - schedule retry
      await this.scheduleRetry(deliveryId, response.status)
      return false

    } catch (error) {
      await this.scheduleRetry(deliveryId, 0, error.message)
      return false
    }
  }

  /**
   * Mark delivery as successful
   */
  private async markDeliverySuccess(deliveryId: string, status: number) {
    const supabase = createServiceRoleClient()
    await supabase
      .from('zapier_webhook_deliveries')
      .update({
        status: 'delivered',
        response_status: status,
        delivered_at: new Date().toISOString()
      })
      .eq('id', deliveryId)
  }

  /**
   * Schedule retry with exponential backoff
   */
  private async scheduleRetry(deliveryId: string, status: number, errorMessage?: string) {
    const supabase = createServiceRoleClient()

    const { data: delivery } = await supabase
      .from('zapier_webhook_deliveries')
      .select('attempt_count, subscription_id')
      .eq('id', deliveryId)
      .single()

    const attemptCount = delivery?.attempt_count || 1

    if (attemptCount >= MAX_WEBHOOK_RETRIES) {
      // Max retries exceeded - abandon
      await supabase
        .from('zapier_webhook_deliveries')
        .update({
          status: 'abandoned',
          response_status: status,
          response_body: errorMessage
        })
        .eq('id', deliveryId)

      // Update subscription error count
      await supabase
        .from('zapier_subscriptions')
        .update({
          error_count: supabase.raw('error_count + 1'),
          last_error: errorMessage || `HTTP ${status}`,
          last_error_at: new Date().toISOString()
        })
        .eq('id', delivery?.subscription_id)

      return
    }

    // Calculate next retry time
    const delayMs = WEBHOOK_RETRY_DELAYS[attemptCount - 1] || 1800000
    const nextRetryAt = new Date(Date.now() + delayMs).toISOString()

    await supabase
      .from('zapier_webhook_deliveries')
      .update({
        status: 'pending',
        response_status: status,
        response_body: errorMessage,
        attempt_count: attemptCount + 1,
        next_retry_at: nextRetryAt
      })
      .eq('id', deliveryId)
  }

  /**
   * Deactivate subscription (410 response)
   */
  private async deactivateSubscription(deliveryId: string) {
    const supabase = createServiceRoleClient()
    const { data: delivery } = await supabase
      .from('zapier_webhook_deliveries')
      .select('subscription_id')
      .eq('id', deliveryId)
      .single()

    if (delivery) {
      await supabase
        .from('zapier_subscriptions')
        .update({ is_active: false })
        .eq('id', delivery.subscription_id)
    }
  }

  /**
   * Process pending retries (called by cron or worker)
   */
  async processRetries(): Promise<number> {
    const supabase = createServiceRoleClient()

    const { data: deliveries } = await supabase
      .from('zapier_webhook_deliveries')
      .select('id, subscription_id, payload')
      .eq('status', 'pending')
      .lte('next_retry_at', new Date().toISOString())
      .limit(100)

    let processed = 0
    for (const delivery of deliveries || []) {
      const { data: subscription } = await supabase
        .from('zapier_subscriptions')
        .select('target_url, is_active')
        .eq('id', delivery.subscription_id)
        .single()

      if (subscription?.is_active) {
        await this.attemptDelivery(delivery.id, subscription.target_url, delivery.payload)
        processed++
      }
    }

    return processed
  }
}

// Singleton instance
export const webhookService = new WebhookService()

// Convenience function
export async function deliverWebhook(subscriptionId: string, payload: WebhookPayload) {
  return webhookService.deliverWebhook(subscriptionId, payload)
}
```

Note: Use `createServiceRoleClient()` for all database operations since this is a system-level service that needs to bypass RLS.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit src/lib/integrations/zapier/webhook-service.ts
```
  </verify>
  <done>
- WebhookService class delivers webhooks to target URLs
- Retry logic with exponential backoff (1s, 5s, 30s, 5m, 30m)
- 410 response handling deactivates subscription
- Delivery tracking in zapier_webhook_deliveries table
- processRetries() handles pending retries
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Event Emitter and Update Index</name>
  <files>
    src/lib/integrations/zapier/event-emitter.ts
    src/lib/integrations/zapier/index.ts
  </files>
  <action>
Create event-emitter.ts that provides functions to emit events for Zapier webhooks:

```typescript
import { createServiceRoleClient } from '@/lib/supabase/server'
import { webhookService } from './webhook-service'
import type {
  ZapierEventType,
  WebhookPayload,
  MessageReceivedData,
  ContactCreatedData,
  ContactUpdatedData,
  FilterOperator
} from '@/types/zapier'

/**
 * Check if event matches subscription filters
 */
function matchesFilters(
  contactTags: string[],
  filterTags: string[] | null,
  filterOperator: FilterOperator
): boolean {
  if (!filterTags || filterTags.length === 0) return true

  const contactTagSet = new Set(contactTags)

  switch (filterOperator) {
    case 'any_of':
      return filterTags.some(tag => contactTagSet.has(tag))
    case 'all_of':
      return filterTags.every(tag => contactTagSet.has(tag))
    case 'none_of':
      return !filterTags.some(tag => contactTagSet.has(tag))
    default:
      return true
  }
}

/**
 * Emit event to all matching subscriptions
 */
export async function emitZapierEvent(
  organizationId: string,
  eventType: ZapierEventType,
  data: MessageReceivedData | ContactCreatedData | ContactUpdatedData,
  contactTags: string[] = []
): Promise<number> {
  const supabase = createServiceRoleClient()

  // Get active subscriptions for this event type and organization
  const { data: subscriptions } = await supabase
    .from('zapier_subscriptions')
    .select('*')
    .eq('organization_id', organizationId)
    .eq('event_type', eventType)
    .eq('is_active', true)

  if (!subscriptions || subscriptions.length === 0) return 0

  // Build payload
  const payload: WebhookPayload = {
    id: crypto.randomUUID(),
    event: eventType,
    timestamp: new Date().toISOString(),
    organization_id: organizationId,
    data
  }

  // Deliver to matching subscriptions
  let delivered = 0
  for (const subscription of subscriptions) {
    // Apply tag filtering
    if (!matchesFilters(contactTags, subscription.filter_tags, subscription.filter_operator)) {
      continue
    }

    // Fire and forget - don't await all deliveries
    webhookService.deliverWebhook(subscription.id, payload)
      .catch(err => console.error(`Webhook delivery failed for ${subscription.id}:`, err))

    delivered++
  }

  return delivered
}

/**
 * Convenience function for message.received events
 */
export async function emitMessageReceived(
  organizationId: string,
  data: MessageReceivedData,
  contactTags: string[] = []
): Promise<number> {
  return emitZapierEvent(organizationId, 'message.received', data, contactTags)
}

/**
 * Convenience function for contact.created events
 */
export async function emitContactCreated(
  organizationId: string,
  data: ContactCreatedData
): Promise<number> {
  return emitZapierEvent(organizationId, 'contact.created', data, data.tags)
}

/**
 * Convenience function for contact.updated events
 */
export async function emitContactUpdated(
  organizationId: string,
  data: ContactUpdatedData,
  contactTags: string[] = []
): Promise<number> {
  return emitZapierEvent(organizationId, 'contact.updated', data, contactTags)
}
```

Update src/lib/integrations/zapier/index.ts to export the new modules:

Add these exports to the existing file:

```typescript
// =====================================================
// Webhook Service
// =====================================================

export {
  WebhookService,
  webhookService,
  deliverWebhook,
} from './webhook-service'

// =====================================================
// Event Emitter
// =====================================================

export {
  emitZapierEvent,
  emitMessageReceived,
  emitContactCreated,
  emitContactUpdated,
} from './event-emitter'
```
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit src/lib/integrations/zapier/event-emitter.ts
npx tsc --noEmit src/lib/integrations/zapier/index.ts
```
  </verify>
  <done>
- emitZapierEvent() broadcasts events to all matching subscriptions
- Tag filtering logic implements any_of, all_of, none_of operators
- Convenience functions for specific event types
- All new exports added to index.ts
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. TypeScript compilation:
```bash
npx tsc --noEmit
```

2. Verify exports work:
```bash
node -e "require('./src/lib/integrations/zapier/index.ts')"
```

3. Check file structure exists:
```bash
ls -la src/app/api/integrations/zapier/hooks/
ls -la src/lib/integrations/zapier/
```
</verification>

<success_criteria>
1. POST /api/integrations/zapier/hooks/subscribe creates subscription in zapier_subscriptions table
2. DELETE /api/integrations/zapier/hooks/{id} removes subscription
3. WebhookService delivers payloads to target URLs with retry logic
4. emitZapierEvent() finds matching subscriptions and triggers delivery
5. Tag filtering works with any_of, all_of, none_of operators
6. All files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-zapier-integration/10-04-SUMMARY.md`
</output>
