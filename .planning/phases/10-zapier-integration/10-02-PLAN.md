---
phase: 10-zapier-integration
plan: 02
type: execute
wave: 2
depends_on:
  - 10-01
files_modified:
  - src/lib/integrations/zapier/oauth-provider.ts
  - src/lib/integrations/zapier/token-manager.ts
  - src/app/api/integrations/zapier/authorize/route.ts
  - src/app/api/integrations/zapier/token/route.ts
  - src/app/api/integrations/zapier/revoke/route.ts
  - src/app/(auth)/oauth/consent/page.tsx
autonomous: true

must_haves:
  truths:
    - "OAuth provider generates valid JWT access tokens signed with secret"
    - "Authorization Code Grant flow completes successfully with PKCE support"
    - "Refresh tokens can be used to obtain new access tokens"
    - "Token revocation invalidates both access and refresh tokens"
  artifacts:
    - path: "src/lib/integrations/zapier/oauth-provider.ts"
      provides: "Core OAuth 2.0 provider logic"
      exports: ["OAuthProvider", "validateClient", "generateAuthorizationCode", "exchangeCodeForTokens"]
    - path: "src/lib/integrations/zapier/token-manager.ts"
      provides: "JWT token generation and validation"
      exports: ["generateAccessToken", "verifyAccessToken", "generateRefreshToken", "hashToken"]
    - path: "src/app/api/integrations/zapier/authorize/route.ts"
      provides: "Authorization endpoint"
    - path: "src/app/api/integrations/zapier/token/route.ts"
      provides: "Token exchange endpoint"
  key_links:
    - from: "oauth-provider.ts"
      to: "token-manager.ts"
      via: "token generation functions"
    - from: "authorize endpoint"
      to: "consent page"
      via: "redirect for user login"
---

<objective>
Implement OAuth 2.0 Authorization Server for Zapier integration.

Purpose: Enable Zapier to authenticate users and obtain access tokens to call ADSapp APIs. Implements Authorization Code Grant with PKCE support, JWT access tokens, and refresh token flow.

Output:
- OAuth provider service with authorization code flow
- JWT-based token manager with secure signing
- Authorization, token, and revocation API endpoints
- Consent UI page for user authorization
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-zapier-integration/10-RESEARCH.md

Key OAuth requirements from research (Part 2):
- Authorization Code Grant (Zapier requirement)
- PKCE support for enhanced security
- JWT access tokens with 1-hour lifespan
- Refresh tokens with 30-day lifespan
- State parameter validation (mandatory)
- Scope-based permissions

Environment variables needed:
- OAUTH_JWT_SECRET: For signing JWT tokens
- OAUTH_TOKEN_ISSUER: 'adsapp'
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create token manager service</name>
  <files>src/lib/integrations/zapier/token-manager.ts</files>
  <action>
Create the token manager for JWT generation and validation:

```typescript
import { SignJWT, jwtVerify, JWTPayload } from 'jose'
import { createHash, randomBytes } from 'crypto'
import { OAuthJWTPayload, OAuthScope } from '@/types/oauth'

const JWT_SECRET = new TextEncoder().encode(process.env.OAUTH_JWT_SECRET || 'fallback-secret-change-in-production')
const ISSUER = 'adsapp'
const ACCESS_TOKEN_EXPIRY = '1h'
const REFRESH_TOKEN_EXPIRY_DAYS = 30

// Generate a secure random string
export function generateSecureToken(bytes: number = 32): string {
  return randomBytes(bytes).toString('hex')
}

// Hash a token using SHA256 for storage
export function hashToken(token: string): string {
  return createHash('sha256').update(token).digest('hex')
}

// Generate JWT access token
export async function generateAccessToken(
  userId: string,
  organizationId: string,
  scopes: OAuthScope[],
  clientName: string,
  tokenId: string
): Promise<{ token: string; expiresAt: Date }> {
  const now = Math.floor(Date.now() / 1000)
  const expiresIn = 3600 // 1 hour in seconds
  const expiresAt = new Date((now + expiresIn) * 1000)

  const token = await new SignJWT({
    sub: userId,
    org: organizationId,
    scope: scopes.join(' '),
    jti: tokenId
  } as JWTPayload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt(now)
    .setExpirationTime(now + expiresIn)
    .setIssuer(ISSUER)
    .setAudience(clientName)
    .sign(JWT_SECRET)

  return { token, expiresAt }
}

// Verify and decode JWT access token
export async function verifyAccessToken(token: string): Promise<OAuthJWTPayload | null> {
  try {
    const { payload } = await jwtVerify(token, JWT_SECRET, {
      issuer: ISSUER
    })

    return {
      sub: payload.sub as string,
      org: payload.org as string,
      scope: payload.scope as string,
      iat: payload.iat as number,
      exp: payload.exp as number,
      iss: payload.iss as 'adsapp',
      aud: Array.isArray(payload.aud) ? payload.aud[0] : payload.aud as string,
      jti: payload.jti as string
    }
  } catch (error) {
    console.error('Token verification failed:', error)
    return null
  }
}

// Generate refresh token (random string, not JWT)
export function generateRefreshToken(): { token: string; expiresAt: Date } {
  const token = generateSecureToken(64)
  const expiresAt = new Date()
  expiresAt.setDate(expiresAt.getDate() + REFRESH_TOKEN_EXPIRY_DAYS)
  return { token, expiresAt }
}

// Generate authorization code
export function generateAuthorizationCode(): { code: string; expiresAt: Date } {
  const code = generateSecureToken(32)
  const expiresAt = new Date()
  expiresAt.setMinutes(expiresAt.getMinutes() + 10) // 10 minute expiry
  return { code, expiresAt }
}

// PKCE: Verify code challenge
export function verifyCodeChallenge(
  codeVerifier: string,
  codeChallenge: string,
  method: 'S256' | 'plain'
): boolean {
  if (method === 'plain') {
    return codeVerifier === codeChallenge
  }

  // S256: base64url(sha256(code_verifier))
  const hash = createHash('sha256').update(codeVerifier).digest()
  const computed = hash.toString('base64url')
  return computed === codeChallenge
}

// Compare client secret with stored hash
export async function verifyClientSecret(secret: string, hash: string): Promise<boolean> {
  // Using bcrypt for client secret comparison
  const bcrypt = await import('bcrypt')
  return bcrypt.compare(secret, hash)
}

// Hash client secret for storage
export async function hashClientSecret(secret: string): Promise<string> {
  const bcrypt = await import('bcrypt')
  return bcrypt.hash(secret, 12)
}
```

Export all functions.
  </action>
  <verify>
Run: `npm run type-check`
Check that jose and bcrypt packages are available or add to dependencies.
  </verify>
  <done>
token-manager.ts exists with JWT generation, verification, hashing, and PKCE support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create OAuth provider service</name>
  <files>src/lib/integrations/zapier/oauth-provider.ts</files>
  <action>
Create the core OAuth 2.0 provider logic:

```typescript
import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/server'
import { OAuthScope, OAuthAuthorizeRequest, OAuthTokenRequest, OAuthTokenResponse, OAuthErrorResponse } from '@/types/oauth'
import {
  generateAuthorizationCode,
  generateAccessToken,
  generateRefreshToken,
  hashToken,
  verifyCodeChallenge,
  verifyClientSecret
} from './token-manager'

// Validate OAuth client exists and is active
export async function validateClient(
  clientId: string,
  redirectUri: string
): Promise<{ valid: boolean; client?: { id: string; name: string; scopes: OAuthScope[] }; error?: string }> {
  const supabase = createServiceRoleClient()

  const { data: client, error } = await supabase
    .from('oauth_clients')
    .select('id, name, redirect_uris, scopes, is_active')
    .eq('client_id', clientId)
    .single()

  if (error || !client) {
    return { valid: false, error: 'invalid_client' }
  }

  if (!client.is_active) {
    return { valid: false, error: 'client_disabled' }
  }

  if (!client.redirect_uris.includes(redirectUri)) {
    return { valid: false, error: 'invalid_redirect_uri' }
  }

  return {
    valid: true,
    client: {
      id: client.id,
      name: client.name,
      scopes: client.scopes as OAuthScope[]
    }
  }
}

// Create authorization code after user consent
export async function createAuthorizationCode(
  clientId: string,
  userId: string,
  organizationId: string,
  redirectUri: string,
  scopes: OAuthScope[],
  state: string,
  codeChallenge?: string,
  codeChallengeMethod?: 'S256' | 'plain'
): Promise<{ code: string } | { error: string }> {
  const supabase = createServiceRoleClient()

  // Get the client UUID from client_id
  const { data: client } = await supabase
    .from('oauth_clients')
    .select('id')
    .eq('client_id', clientId)
    .single()

  if (!client) {
    return { error: 'invalid_client' }
  }

  const { code, expiresAt } = generateAuthorizationCode()

  const { error } = await supabase
    .from('oauth_authorization_codes')
    .insert({
      code,
      client_id: client.id,
      user_id: userId,
      organization_id: organizationId,
      redirect_uri: redirectUri,
      scopes,
      code_challenge: codeChallenge,
      code_challenge_method: codeChallengeMethod,
      state,
      expires_at: expiresAt.toISOString()
    })

  if (error) {
    console.error('Failed to create authorization code:', error)
    return { error: 'server_error' }
  }

  return { code }
}

// Exchange authorization code for tokens
export async function exchangeCodeForTokens(
  code: string,
  clientId: string,
  clientSecret: string,
  redirectUri: string,
  codeVerifier?: string
): Promise<OAuthTokenResponse | OAuthErrorResponse> {
  const supabase = createServiceRoleClient()

  // Verify client credentials
  const { data: client } = await supabase
    .from('oauth_clients')
    .select('id, name, client_secret_hash')
    .eq('client_id', clientId)
    .single()

  if (!client) {
    return { error: 'invalid_client', error_description: 'Client not found' }
  }

  const secretValid = await verifyClientSecret(clientSecret, client.client_secret_hash)
  if (!secretValid) {
    return { error: 'invalid_client', error_description: 'Invalid client secret' }
  }

  // Find and validate authorization code
  const { data: authCode } = await supabase
    .from('oauth_authorization_codes')
    .select('*')
    .eq('code', code)
    .eq('client_id', client.id)
    .is('used_at', null)
    .single()

  if (!authCode) {
    return { error: 'invalid_grant', error_description: 'Invalid or expired code' }
  }

  // Check expiration
  if (new Date(authCode.expires_at) < new Date()) {
    return { error: 'invalid_grant', error_description: 'Code expired' }
  }

  // Verify redirect URI matches
  if (authCode.redirect_uri !== redirectUri) {
    return { error: 'invalid_grant', error_description: 'Redirect URI mismatch' }
  }

  // Verify PKCE if code challenge was used
  if (authCode.code_challenge) {
    if (!codeVerifier) {
      return { error: 'invalid_grant', error_description: 'Code verifier required' }
    }
    if (!verifyCodeChallenge(codeVerifier, authCode.code_challenge, authCode.code_challenge_method || 'S256')) {
      return { error: 'invalid_grant', error_description: 'Invalid code verifier' }
    }
  }

  // Mark code as used
  await supabase
    .from('oauth_authorization_codes')
    .update({ used_at: new Date().toISOString() })
    .eq('id', authCode.id)

  // Generate tokens
  const tokenId = crypto.randomUUID()
  const { token: accessToken, expiresAt } = await generateAccessToken(
    authCode.user_id,
    authCode.organization_id,
    authCode.scopes,
    client.name,
    tokenId
  )

  const { token: refreshToken, expiresAt: refreshExpiresAt } = generateRefreshToken()

  // Store access token
  const { data: accessTokenRecord } = await supabase
    .from('oauth_access_tokens')
    .insert({
      id: tokenId,
      token_hash: hashToken(accessToken),
      client_id: client.id,
      user_id: authCode.user_id,
      organization_id: authCode.organization_id,
      scopes: authCode.scopes,
      expires_at: expiresAt.toISOString()
    })
    .select('id')
    .single()

  // Store refresh token
  await supabase
    .from('oauth_refresh_tokens')
    .insert({
      token_hash: hashToken(refreshToken),
      access_token_id: accessTokenRecord?.id,
      client_id: client.id,
      user_id: authCode.user_id,
      organization_id: authCode.organization_id,
      expires_at: refreshExpiresAt.toISOString()
    })

  return {
    access_token: accessToken,
    token_type: 'Bearer',
    expires_in: 3600,
    refresh_token: refreshToken,
    scope: authCode.scopes.join(' ')
  }
}

// Refresh access token
export async function refreshAccessToken(
  refreshToken: string,
  clientId: string,
  clientSecret: string
): Promise<OAuthTokenResponse | OAuthErrorResponse> {
  const supabase = createServiceRoleClient()

  // Verify client credentials
  const { data: client } = await supabase
    .from('oauth_clients')
    .select('id, name, client_secret_hash')
    .eq('client_id', clientId)
    .single()

  if (!client) {
    return { error: 'invalid_client' }
  }

  const secretValid = await verifyClientSecret(clientSecret, client.client_secret_hash)
  if (!secretValid) {
    return { error: 'invalid_client' }
  }

  // Find refresh token
  const tokenHash = hashToken(refreshToken)
  const { data: storedToken } = await supabase
    .from('oauth_refresh_tokens')
    .select('*, oauth_access_tokens!access_token_id(scopes)')
    .eq('token_hash', tokenHash)
    .eq('client_id', client.id)
    .is('revoked_at', null)
    .single()

  if (!storedToken) {
    return { error: 'invalid_grant', error_description: 'Invalid refresh token' }
  }

  if (new Date(storedToken.expires_at) < new Date()) {
    return { error: 'invalid_grant', error_description: 'Refresh token expired' }
  }

  // Generate new tokens
  const tokenId = crypto.randomUUID()
  const scopes = storedToken.oauth_access_tokens?.scopes || []
  const { token: newAccessToken, expiresAt } = await generateAccessToken(
    storedToken.user_id,
    storedToken.organization_id,
    scopes,
    client.name,
    tokenId
  )

  const { token: newRefreshToken, expiresAt: newRefreshExpiresAt } = generateRefreshToken()

  // Revoke old refresh token
  await supabase
    .from('oauth_refresh_tokens')
    .update({ used_at: new Date().toISOString() })
    .eq('id', storedToken.id)

  // Store new access token
  const { data: newAccessTokenRecord } = await supabase
    .from('oauth_access_tokens')
    .insert({
      id: tokenId,
      token_hash: hashToken(newAccessToken),
      client_id: client.id,
      user_id: storedToken.user_id,
      organization_id: storedToken.organization_id,
      scopes,
      expires_at: expiresAt.toISOString()
    })
    .select('id')
    .single()

  // Store new refresh token
  await supabase
    .from('oauth_refresh_tokens')
    .insert({
      token_hash: hashToken(newRefreshToken),
      access_token_id: newAccessTokenRecord?.id,
      client_id: client.id,
      user_id: storedToken.user_id,
      organization_id: storedToken.organization_id,
      expires_at: newRefreshExpiresAt.toISOString()
    })

  return {
    access_token: newAccessToken,
    token_type: 'Bearer',
    expires_in: 3600,
    refresh_token: newRefreshToken,
    scope: scopes.join(' ')
  }
}

// Revoke tokens
export async function revokeToken(
  token: string,
  tokenTypeHint?: 'access_token' | 'refresh_token'
): Promise<void> {
  const supabase = createServiceRoleClient()
  const tokenHash = hashToken(token)
  const now = new Date().toISOString()

  // Try to revoke as access token
  if (!tokenTypeHint || tokenTypeHint === 'access_token') {
    const { data: accessToken } = await supabase
      .from('oauth_access_tokens')
      .update({ revoked_at: now })
      .eq('token_hash', tokenHash)
      .select('id')
      .single()

    if (accessToken) {
      // Also revoke associated refresh tokens
      await supabase
        .from('oauth_refresh_tokens')
        .update({ revoked_at: now })
        .eq('access_token_id', accessToken.id)
      return
    }
  }

  // Try to revoke as refresh token
  if (!tokenTypeHint || tokenTypeHint === 'refresh_token') {
    await supabase
      .from('oauth_refresh_tokens')
      .update({ revoked_at: now })
      .eq('token_hash', tokenHash)
  }
}
```

Export all functions.
  </action>
  <verify>
Run: `npm run type-check`
All functions should compile without errors.
  </verify>
  <done>
oauth-provider.ts exists with complete Authorization Code Grant flow implementation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create authorization endpoint</name>
  <files>src/app/api/integrations/zapier/authorize/route.ts</files>
  <action>
Create the OAuth authorization endpoint:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { validateClient } from '@/lib/integrations/zapier/oauth-provider'
import { OAuthAuthorizeRequest } from '@/types/oauth'

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams

  // Parse OAuth parameters
  const params: Partial<OAuthAuthorizeRequest> = {
    response_type: searchParams.get('response_type') as 'code' | null ?? undefined,
    client_id: searchParams.get('client_id') ?? undefined,
    redirect_uri: searchParams.get('redirect_uri') ?? undefined,
    state: searchParams.get('state') ?? undefined,
    scope: searchParams.get('scope') ?? undefined,
    code_challenge: searchParams.get('code_challenge') ?? undefined,
    code_challenge_method: searchParams.get('code_challenge_method') as 'S256' | 'plain' | null ?? undefined
  }

  // Validate required parameters
  if (params.response_type !== 'code') {
    return NextResponse.json(
      { error: 'unsupported_response_type', error_description: 'Only code response type is supported' },
      { status: 400 }
    )
  }

  if (!params.client_id || !params.redirect_uri || !params.state) {
    return NextResponse.json(
      { error: 'invalid_request', error_description: 'Missing required parameters' },
      { status: 400 }
    )
  }

  // Validate client
  const clientValidation = await validateClient(params.client_id, params.redirect_uri)
  if (!clientValidation.valid) {
    return NextResponse.json(
      { error: clientValidation.error, error_description: 'Client validation failed' },
      { status: 400 }
    )
  }

  // Check if user is authenticated
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  // Build consent page URL with OAuth params
  const consentUrl = new URL('/oauth/consent', request.nextUrl.origin)
  consentUrl.searchParams.set('client_id', params.client_id)
  consentUrl.searchParams.set('client_name', clientValidation.client!.name)
  consentUrl.searchParams.set('redirect_uri', params.redirect_uri)
  consentUrl.searchParams.set('state', params.state)
  consentUrl.searchParams.set('scope', params.scope || clientValidation.client!.scopes.join(' '))

  if (params.code_challenge) {
    consentUrl.searchParams.set('code_challenge', params.code_challenge)
  }
  if (params.code_challenge_method) {
    consentUrl.searchParams.set('code_challenge_method', params.code_challenge_method)
  }

  // If not authenticated, add return URL for login redirect
  if (!user) {
    const loginUrl = new URL('/auth/login', request.nextUrl.origin)
    loginUrl.searchParams.set('returnTo', consentUrl.pathname + consentUrl.search)
    return NextResponse.redirect(loginUrl)
  }

  // Redirect to consent page
  return NextResponse.redirect(consentUrl)
}
```
  </action>
  <verify>
Check: Endpoint validates all required OAuth parameters.
Check: Redirects to login if not authenticated.
Check: Redirects to consent page with all OAuth parameters.
  </verify>
  <done>
Authorization endpoint exists and handles OAuth parameter validation and redirects.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create token endpoint</name>
  <files>src/app/api/integrations/zapier/token/route.ts</files>
  <action>
Create the OAuth token endpoint:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { exchangeCodeForTokens, refreshAccessToken } from '@/lib/integrations/zapier/oauth-provider'

export async function POST(request: NextRequest) {
  try {
    const contentType = request.headers.get('content-type')
    let body: Record<string, string>

    // Support both form-urlencoded and JSON
    if (contentType?.includes('application/x-www-form-urlencoded')) {
      const formData = await request.formData()
      body = Object.fromEntries(formData.entries()) as Record<string, string>
    } else {
      body = await request.json()
    }

    const { grant_type, code, redirect_uri, client_id, client_secret, refresh_token, code_verifier } = body

    if (!client_id || !client_secret) {
      return NextResponse.json(
        { error: 'invalid_client', error_description: 'Client credentials required' },
        { status: 401 }
      )
    }

    let result

    switch (grant_type) {
      case 'authorization_code':
        if (!code || !redirect_uri) {
          return NextResponse.json(
            { error: 'invalid_request', error_description: 'Code and redirect_uri required' },
            { status: 400 }
          )
        }
        result = await exchangeCodeForTokens(code, client_id, client_secret, redirect_uri, code_verifier)
        break

      case 'refresh_token':
        if (!refresh_token) {
          return NextResponse.json(
            { error: 'invalid_request', error_description: 'Refresh token required' },
            { status: 400 }
          )
        }
        result = await refreshAccessToken(refresh_token, client_id, client_secret)
        break

      default:
        return NextResponse.json(
          { error: 'unsupported_grant_type', error_description: 'Only authorization_code and refresh_token grants are supported' },
          { status: 400 }
        )
    }

    // Check if result is an error
    if ('error' in result) {
      const status = result.error === 'invalid_client' ? 401 : 400
      return NextResponse.json(result, { status })
    }

    // Success response
    return NextResponse.json(result, {
      headers: {
        'Cache-Control': 'no-store',
        'Pragma': 'no-cache'
      }
    })
  } catch (error) {
    console.error('Token endpoint error:', error)
    return NextResponse.json(
      { error: 'server_error', error_description: 'Internal server error' },
      { status: 500 }
    )
  }
}
```
  </action>
  <verify>
Check: Endpoint handles both authorization_code and refresh_token grants.
Check: Proper error responses with correct status codes.
Check: Cache-Control headers prevent token caching.
  </verify>
  <done>
Token endpoint exists and handles code exchange and token refresh.
  </done>
</task>

<task type="auto">
  <name>Task 5: Create revoke endpoint</name>
  <files>src/app/api/integrations/zapier/revoke/route.ts</files>
  <action>
Create the OAuth token revocation endpoint:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { revokeToken } from '@/lib/integrations/zapier/oauth-provider'

export async function POST(request: NextRequest) {
  try {
    const contentType = request.headers.get('content-type')
    let body: Record<string, string>

    // Support both form-urlencoded and JSON
    if (contentType?.includes('application/x-www-form-urlencoded')) {
      const formData = await request.formData()
      body = Object.fromEntries(formData.entries()) as Record<string, string>
    } else {
      body = await request.json()
    }

    const { token, token_type_hint } = body

    if (!token) {
      return NextResponse.json(
        { error: 'invalid_request', error_description: 'Token required' },
        { status: 400 }
      )
    }

    const tokenTypeHint = token_type_hint as 'access_token' | 'refresh_token' | undefined

    await revokeToken(token, tokenTypeHint)

    // RFC 7009: Always return 200 OK, even if token was invalid
    return new NextResponse(null, { status: 200 })
  } catch (error) {
    console.error('Revoke endpoint error:', error)
    // Still return 200 per RFC 7009
    return new NextResponse(null, { status: 200 })
  }
}
```
  </action>
  <verify>
Check: Endpoint accepts token and optional token_type_hint.
Check: Returns 200 OK regardless of token validity (per RFC 7009).
  </verify>
  <done>
Revoke endpoint exists and handles token revocation.
  </done>
</task>

<task type="auto">
  <name>Task 6: Create consent UI page</name>
  <files>src/app/(auth)/oauth/consent/page.tsx</files>
  <action>
Create the OAuth consent page for user authorization:

```typescript
'use client'

import { useState } from 'react'
import { useSearchParams, useRouter } from 'next/navigation'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card'
import { Checkbox } from '@/components/ui/checkbox'
import { Label } from '@/components/ui/label'
import { createClient } from '@/lib/supabase/client'

const SCOPE_DESCRIPTIONS: Record<string, string> = {
  'messages:read': 'Read your messages and conversations',
  'messages:write': 'Send messages on your behalf',
  'contacts:read': 'View your contacts',
  'contacts:write': 'Create and update contacts',
  'webhooks:manage': 'Subscribe to event notifications'
}

export default function OAuthConsentPage() {
  const searchParams = useSearchParams()
  const router = useRouter()
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const clientId = searchParams.get('client_id')
  const clientName = searchParams.get('client_name') || 'Unknown Application'
  const redirectUri = searchParams.get('redirect_uri')
  const state = searchParams.get('state')
  const scope = searchParams.get('scope') || ''
  const codeChallenge = searchParams.get('code_challenge')
  const codeChallengeMethod = searchParams.get('code_challenge_method')

  const scopes = scope.split(' ').filter(Boolean)

  const handleAuthorize = async () => {
    if (!clientId || !redirectUri || !state) {
      setError('Missing required parameters')
      return
    }

    setIsLoading(true)
    setError(null)

    try {
      const supabase = createClient()
      const { data: { user } } = await supabase.auth.getUser()

      if (!user) {
        router.push('/auth/login')
        return
      }

      // Get user's organization
      const { data: profile } = await supabase
        .from('profiles')
        .select('organization_id')
        .eq('id', user.id)
        .single()

      if (!profile?.organization_id) {
        setError('No organization found')
        return
      }

      // Call server to create authorization code
      const response = await fetch('/api/integrations/zapier/authorize/callback', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          client_id: clientId,
          redirect_uri: redirectUri,
          state,
          scopes,
          code_challenge: codeChallenge,
          code_challenge_method: codeChallengeMethod
        })
      })

      const result = await response.json()

      if (!response.ok || result.error) {
        setError(result.error_description || result.error || 'Authorization failed')
        return
      }

      // Redirect back to client with authorization code
      const callbackUrl = new URL(redirectUri)
      callbackUrl.searchParams.set('code', result.code)
      callbackUrl.searchParams.set('state', state)

      window.location.href = callbackUrl.toString()
    } catch (err) {
      console.error('Authorization error:', err)
      setError('An unexpected error occurred')
    } finally {
      setIsLoading(false)
    }
  }

  const handleDeny = () => {
    if (!redirectUri || !state) return

    const callbackUrl = new URL(redirectUri)
    callbackUrl.searchParams.set('error', 'access_denied')
    callbackUrl.searchParams.set('error_description', 'User denied authorization')
    callbackUrl.searchParams.set('state', state)

    window.location.href = callbackUrl.toString()
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 p-4">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle>Authorize {clientName}</CardTitle>
          <CardDescription>
            {clientName} is requesting access to your ADSapp account
          </CardDescription>
        </CardHeader>

        <CardContent className="space-y-4">
          <div className="space-y-2">
            <p className="text-sm font-medium">This application will be able to:</p>
            <ul className="space-y-2">
              {scopes.map((s) => (
                <li key={s} className="flex items-start gap-2 text-sm">
                  <Checkbox checked disabled className="mt-0.5" />
                  <Label className="font-normal">
                    {SCOPE_DESCRIPTIONS[s] || s}
                  </Label>
                </li>
              ))}
            </ul>
          </div>

          {error && (
            <div className="p-3 bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 rounded-md text-sm">
              {error}
            </div>
          )}
        </CardContent>

        <CardFooter className="flex gap-2">
          <Button
            variant="outline"
            onClick={handleDeny}
            disabled={isLoading}
            className="flex-1"
          >
            Deny
          </Button>
          <Button
            onClick={handleAuthorize}
            disabled={isLoading}
            className="flex-1"
          >
            {isLoading ? 'Authorizing...' : 'Authorize'}
          </Button>
        </CardFooter>
      </Card>
    </div>
  )
}
```
  </action>
  <verify>
Check: Page displays client name and requested scopes.
Check: Authorize button triggers code generation and redirect.
Check: Deny button redirects with access_denied error.
  </verify>
  <done>
Consent page exists with scope display and authorize/deny actions.
  </done>
</task>

<task type="auto">
  <name>Task 7: Create authorize callback endpoint</name>
  <files>src/app/api/integrations/zapier/authorize/callback/route.ts</files>
  <action>
Create the callback endpoint that generates authorization codes after consent:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createAuthorizationCode, validateClient } from '@/lib/integrations/zapier/oauth-provider'
import { OAuthScope } from '@/types/oauth'

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { client_id, redirect_uri, state, scopes, code_challenge, code_challenge_method } = body

    // Validate required parameters
    if (!client_id || !redirect_uri || !state) {
      return NextResponse.json(
        { error: 'invalid_request', error_description: 'Missing required parameters' },
        { status: 400 }
      )
    }

    // Validate client
    const clientValidation = await validateClient(client_id, redirect_uri)
    if (!clientValidation.valid) {
      return NextResponse.json(
        { error: clientValidation.error },
        { status: 400 }
      )
    }

    // Get authenticated user
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      return NextResponse.json(
        { error: 'unauthorized', error_description: 'User not authenticated' },
        { status: 401 }
      )
    }

    // Get user's organization
    const { data: profile } = await supabase
      .from('profiles')
      .select('organization_id')
      .eq('id', user.id)
      .single()

    if (!profile?.organization_id) {
      return NextResponse.json(
        { error: 'invalid_request', error_description: 'No organization found' },
        { status: 400 }
      )
    }

    // Validate requested scopes against client's allowed scopes
    const requestedScopes = (scopes || []) as OAuthScope[]
    const allowedScopes = clientValidation.client!.scopes
    const validScopes = requestedScopes.filter(s => allowedScopes.includes(s))

    if (validScopes.length === 0) {
      // Default to all allowed scopes if none specified
      validScopes.push(...allowedScopes)
    }

    // Create authorization code
    const result = await createAuthorizationCode(
      client_id,
      user.id,
      profile.organization_id,
      redirect_uri,
      validScopes,
      state,
      code_challenge,
      code_challenge_method as 'S256' | 'plain' | undefined
    )

    if ('error' in result) {
      return NextResponse.json(
        { error: result.error },
        { status: 400 }
      )
    }

    return NextResponse.json({ code: result.code })
  } catch (error) {
    console.error('Authorize callback error:', error)
    return NextResponse.json(
      { error: 'server_error', error_description: 'Internal server error' },
      { status: 500 }
    )
  }
}
```
  </action>
  <verify>
Check: Endpoint validates user authentication.
Check: Creates authorization code with user and org context.
Check: Validates scopes against client's allowed scopes.
  </verify>
  <done>
Authorize callback endpoint exists and generates authorization codes.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Token manager generates valid JWT tokens
2. OAuth provider handles full Authorization Code Grant flow
3. Authorization endpoint validates parameters and redirects to consent
4. Token endpoint exchanges codes and refreshes tokens
5. Revoke endpoint invalidates tokens
6. Consent page displays scopes and handles user decision
7. `npm run type-check` passes
</verification>

<success_criteria>
- JWT tokens are properly signed and verifiable
- Authorization Code Grant flow completes end-to-end
- PKCE challenge/verifier validation works correctly
- Refresh tokens generate new access tokens
- Token revocation invalidates all associated tokens
- Consent UI shows client name and requested permissions
</success_criteria>

<output>
After completion, create `.planning/phases/10-zapier-integration/10-02-SUMMARY.md`
</output>
