---
phase: 10-zapier-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260124_zapier_oauth.sql
  - supabase/migrations/20260124_zapier_webhooks.sql
  - src/types/zapier.ts
  - src/types/oauth.ts
autonomous: true

must_haves:
  truths:
    - "oauth_clients, oauth_authorization_codes, oauth_access_tokens, oauth_refresh_tokens tables exist"
    - "zapier_subscriptions and zapier_webhook_deliveries tables exist with RLS"
    - "All tables enforce organization isolation via RLS policies"
    - "TypeScript types for OAuth and Zapier entities are exported"
  artifacts:
    - path: "supabase/migrations/20260124_zapier_oauth.sql"
      provides: "Database schema for OAuth 2.0 provider"
      contains: "CREATE TABLE oauth_clients"
    - path: "supabase/migrations/20260124_zapier_webhooks.sql"
      provides: "Database schema for webhook subscriptions"
      contains: "CREATE TABLE zapier_subscriptions"
    - path: "src/types/oauth.ts"
      provides: "TypeScript types for OAuth entities"
      exports: ["OAuthClient", "OAuthAuthorizationCode", "OAuthAccessToken", "OAuthRefreshToken", "OAuthScope"]
    - path: "src/types/zapier.ts"
      provides: "TypeScript types for Zapier integration"
      exports: ["ZapierSubscription", "ZapierWebhookDelivery", "ZapierEventType", "WebhookPayload"]
  key_links:
    - from: "oauth_authorization_codes"
      to: "oauth_clients"
      via: "foreign key client_id"
    - from: "oauth_access_tokens"
      to: "auth.users"
      via: "foreign key user_id"
    - from: "zapier_subscriptions"
      to: "organizations"
      via: "foreign key organization_id"
---

<objective>
Create database schema and TypeScript type definitions for OAuth 2.0 provider and Zapier webhook system.

Purpose: Establish the data foundation for OAuth 2.0 Authorization Server and REST Hook webhook subscriptions. This enables Zapier integration with proper token management and event delivery tracking.

Output:
- Migration file for OAuth tables (clients, authorization codes, access tokens, refresh tokens)
- Migration file for webhook tables (subscriptions, delivery logs)
- TypeScript types for all OAuth and Zapier entities
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-zapier-integration/10-RESEARCH.md

Key schema from research (Part 6):
- oauth_clients: Stores OAuth client credentials for Zapier and future integrations
- oauth_authorization_codes: Short-lived codes for Authorization Code Grant flow
- oauth_access_tokens: JWT-based access tokens with hash storage
- oauth_refresh_tokens: Long-lived refresh tokens for token renewal
- zapier_subscriptions: REST Hook webhook subscriptions with filtering support
- zapier_webhook_deliveries: Delivery logs for debugging and retry management
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OAuth tables migration</name>
  <files>supabase/migrations/20260124_zapier_oauth.sql</files>
  <action>
Create a SQL migration file with OAuth 2.0 provider tables from research Part 6.1:

1. **oauth_clients table** - OAuth client applications:
   - id UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - name TEXT NOT NULL
   - client_id TEXT UNIQUE NOT NULL DEFAULT encode(gen_random_bytes(32), 'hex')
   - client_secret_hash TEXT NOT NULL (bcrypt hash)
   - redirect_uris TEXT[] NOT NULL
   - scopes TEXT[] NOT NULL DEFAULT ARRAY['messages:read', 'messages:write', 'contacts:read', 'contacts:write', 'webhooks:manage']
   - is_active BOOLEAN DEFAULT true
   - created_at, updated_at TIMESTAMPTZ DEFAULT now()

2. **oauth_authorization_codes table** - Short-lived auth codes:
   - id UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - code TEXT UNIQUE NOT NULL DEFAULT encode(gen_random_bytes(32), 'hex')
   - client_id UUID REFERENCES oauth_clients(id) ON DELETE CASCADE
   - user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE
   - organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE
   - redirect_uri TEXT NOT NULL
   - scopes TEXT[] NOT NULL
   - code_challenge TEXT (for PKCE)
   - code_challenge_method TEXT ('S256' or 'plain')
   - state TEXT NOT NULL
   - expires_at TIMESTAMPTZ NOT NULL
   - used_at TIMESTAMPTZ
   - created_at TIMESTAMPTZ DEFAULT now()

3. **oauth_access_tokens table** - Access tokens:
   - id UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - token_hash TEXT UNIQUE NOT NULL (SHA256 hash of JWT)
   - client_id UUID REFERENCES oauth_clients(id) ON DELETE CASCADE
   - user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE
   - organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE
   - scopes TEXT[] NOT NULL
   - expires_at TIMESTAMPTZ NOT NULL
   - revoked_at TIMESTAMPTZ
   - created_at TIMESTAMPTZ DEFAULT now()

4. **oauth_refresh_tokens table** - Refresh tokens:
   - id UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - token_hash TEXT UNIQUE NOT NULL (SHA256 hash)
   - access_token_id UUID REFERENCES oauth_access_tokens(id) ON DELETE CASCADE
   - client_id UUID REFERENCES oauth_clients(id) ON DELETE CASCADE
   - user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE
   - organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE
   - expires_at TIMESTAMPTZ NOT NULL
   - revoked_at TIMESTAMPTZ
   - used_at TIMESTAMPTZ
   - created_at TIMESTAMPTZ DEFAULT now()

5. **Add indexes** for:
   - oauth_authorization_codes: code (WHERE used_at IS NULL), expires_at
   - oauth_access_tokens: token_hash, expires_at, user_id
   - oauth_refresh_tokens: token_hash, access_token_id

6. **Enable RLS** on all tables:
   - oauth_clients: Only super admins can manage
   - oauth_authorization_codes: Users can view their own
   - oauth_access_tokens: Users can view and revoke their own
   - oauth_refresh_tokens: Users can view their own

7. **Create cleanup function** cleanup_expired_oauth_tokens():
   - Delete expired auth codes older than 1 hour
   - Delete expired/revoked access tokens older than 7 days
   - Delete expired/revoked refresh tokens older than 7 days

Wrap in BEGIN/COMMIT transaction.
  </action>
  <verify>
Check: File exists with valid SQL syntax.
Check: All 4 tables defined with proper constraints.
Check: RLS enabled on all tables with appropriate policies.
  </verify>
  <done>
Migration file exists with oauth_clients, oauth_authorization_codes, oauth_access_tokens, oauth_refresh_tokens tables, indexes, and RLS policies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create webhook tables migration</name>
  <files>supabase/migrations/20260124_zapier_webhooks.sql</files>
  <action>
Create a SQL migration file with webhook subscription tables from research Part 6.2:

1. **zapier_subscriptions table** - REST Hook subscriptions:
   - id UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE
   - user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
   - access_token_id UUID REFERENCES oauth_access_tokens(id) ON DELETE SET NULL
   - event_type TEXT NOT NULL (e.g., 'message.received', 'contact.created')
   - target_url TEXT NOT NULL
   - filter_tags TEXT[] (for ZAP-06 filtering)
   - filter_segments TEXT[]
   - filter_operator TEXT DEFAULT 'any_of' CHECK IN ('any_of', 'all_of', 'none_of')
   - is_active BOOLEAN DEFAULT true
   - last_triggered_at TIMESTAMPTZ
   - trigger_count INTEGER DEFAULT 0
   - error_count INTEGER DEFAULT 0
   - last_error TEXT
   - last_error_at TIMESTAMPTZ
   - created_at, updated_at TIMESTAMPTZ DEFAULT now()

2. **zapier_webhook_deliveries table** - Delivery logs:
   - id UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - subscription_id UUID REFERENCES zapier_subscriptions(id) ON DELETE CASCADE
   - organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE
   - event_type TEXT NOT NULL
   - event_id TEXT NOT NULL (original event ID)
   - payload JSONB NOT NULL
   - attempt_count INTEGER DEFAULT 1
   - status TEXT NOT NULL CHECK IN ('pending', 'delivered', 'failed', 'abandoned')
   - response_status INTEGER
   - response_body TEXT
   - delivered_at TIMESTAMPTZ
   - next_retry_at TIMESTAMPTZ
   - created_at TIMESTAMPTZ DEFAULT now()

3. **Add indexes** for:
   - zapier_subscriptions: organization_id, event_type, is_active (partial WHERE true)
   - zapier_webhook_deliveries: subscription_id, next_retry_at (partial WHERE status='pending')

4. **Enable RLS** with policies:
   - Organization members can SELECT their subscriptions
   - Admins/owners can manage (INSERT, UPDATE, DELETE) subscriptions
   - Organization members can SELECT their delivery logs

5. **Add updated_at trigger** on zapier_subscriptions using existing update_updated_at_column() function.

6. **Add cleanup to cleanup_expired_oauth_tokens function**:
   - Delete webhook deliveries older than 30 days

Wrap in BEGIN/COMMIT transaction.
  </action>
  <verify>
Check: File exists with valid SQL syntax.
Check: Both tables defined with proper constraints.
Check: RLS enforces organization isolation.
  </verify>
  <done>
Migration file exists with zapier_subscriptions, zapier_webhook_deliveries tables, indexes, RLS policies, and triggers.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create OAuth TypeScript types</name>
  <files>src/types/oauth.ts</files>
  <action>
Create TypeScript types matching the OAuth database schema:

```typescript
// OAuth scopes supported by ADSapp
export type OAuthScope =
  | 'messages:read'
  | 'messages:write'
  | 'contacts:read'
  | 'contacts:write'
  | 'webhooks:manage'

// OAuth client (e.g., Zapier)
export interface OAuthClient {
  id: string
  name: string
  client_id: string
  // client_secret_hash is never exposed
  redirect_uris: string[]
  scopes: OAuthScope[]
  is_active: boolean
  created_at: string
  updated_at: string
}

// Authorization code (short-lived, 10 minutes)
export interface OAuthAuthorizationCode {
  id: string
  code: string
  client_id: string
  user_id: string
  organization_id: string
  redirect_uri: string
  scopes: OAuthScope[]
  code_challenge?: string
  code_challenge_method?: 'S256' | 'plain'
  state: string
  expires_at: string
  used_at?: string
  created_at: string
}

// Access token (1 hour lifespan)
export interface OAuthAccessToken {
  id: string
  token_hash: string
  client_id: string
  user_id: string
  organization_id: string
  scopes: OAuthScope[]
  expires_at: string
  revoked_at?: string
  created_at: string
}

// Refresh token (30 days lifespan)
export interface OAuthRefreshToken {
  id: string
  token_hash: string
  access_token_id: string
  client_id: string
  user_id: string
  organization_id: string
  expires_at: string
  revoked_at?: string
  used_at?: string
  created_at: string
}

// JWT payload for access tokens
export interface OAuthJWTPayload {
  sub: string  // user_id
  org: string  // organization_id
  scope: string  // space-separated scopes
  iat: number
  exp: number
  iss: 'adsapp'
  aud: string  // client name (e.g., 'zapier')
  jti: string  // token id
}

// Authorization request parameters
export interface OAuthAuthorizeRequest {
  response_type: 'code'
  client_id: string
  redirect_uri: string
  state: string
  scope?: string
  code_challenge?: string
  code_challenge_method?: 'S256' | 'plain'
}

// Token request parameters
export interface OAuthTokenRequest {
  grant_type: 'authorization_code' | 'refresh_token'
  code?: string
  redirect_uri?: string
  client_id: string
  client_secret: string
  refresh_token?: string
  code_verifier?: string
}

// Token response
export interface OAuthTokenResponse {
  access_token: string
  token_type: 'Bearer'
  expires_in: number
  refresh_token?: string
  scope: string
}

// Error response
export interface OAuthErrorResponse {
  error: string
  error_description?: string
}
```

Export all types.
  </action>
  <verify>
Run: `npm run type-check`
All types should compile without errors.
  </verify>
  <done>
src/types/oauth.ts exists with all OAuth-related types exported.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create Zapier TypeScript types</name>
  <files>src/types/zapier.ts</files>
  <action>
Create TypeScript types matching the Zapier webhook schema and API contracts:

```typescript
// Event types that can trigger webhooks
export type ZapierEventType =
  | 'message.received'
  | 'message.status_changed'
  | 'contact.created'
  | 'contact.updated'

// Filter operator for tag/segment filtering
export type FilterOperator = 'any_of' | 'all_of' | 'none_of'

// Webhook delivery status
export type WebhookDeliveryStatus = 'pending' | 'delivered' | 'failed' | 'abandoned'

// Webhook subscription
export interface ZapierSubscription {
  id: string
  organization_id: string
  user_id: string
  access_token_id?: string
  event_type: ZapierEventType
  target_url: string
  filter_tags?: string[]
  filter_segments?: string[]
  filter_operator: FilterOperator
  is_active: boolean
  last_triggered_at?: string
  trigger_count: number
  error_count: number
  last_error?: string
  last_error_at?: string
  created_at: string
  updated_at: string
}

// Webhook delivery log
export interface ZapierWebhookDelivery {
  id: string
  subscription_id: string
  organization_id: string
  event_type: ZapierEventType
  event_id: string
  payload: WebhookPayload
  attempt_count: number
  status: WebhookDeliveryStatus
  response_status?: number
  response_body?: string
  delivered_at?: string
  next_retry_at?: string
  created_at: string
}

// Base webhook payload structure
export interface WebhookPayload {
  id: string
  event: ZapierEventType
  timestamp: string
  organization_id: string
  data: MessageReceivedData | MessageStatusData | ContactCreatedData | ContactUpdatedData
}

// Payload for message.received event
export interface MessageReceivedData {
  message_id: string
  conversation_id: string
  contact: {
    id: string
    name: string
    phone: string
  }
  content: {
    type: 'text' | 'media' | 'rich'
    text?: string
    media_url?: string
  }
  channel: string
  received_at: string
}

// Payload for message.status_changed event
export interface MessageStatusData {
  message_id: string
  conversation_id: string
  old_status: string
  new_status: string
  timestamp: string
}

// Payload for contact.created event
export interface ContactCreatedData {
  contact_id: string
  name: string
  phone: string
  email?: string
  tags: string[]
  created_at: string
}

// Payload for contact.updated event
export interface ContactUpdatedData {
  contact_id: string
  changes: Record<string, { old: unknown; new: unknown }>
  updated_at: string
}

// Subscribe request (from Zapier)
export interface SubscribeRequest {
  event: ZapierEventType
  hookUrl: string
  filters?: {
    tags?: {
      operator?: FilterOperator
      values: string[]
    }
    segments?: string[]
  }
}

// Subscribe response
export interface SubscribeResponse {
  id: string
  event: ZapierEventType
  hookUrl: string
  active: boolean
  createdAt: string
}

// Action: Send message request
export interface SendMessageRequest {
  to: string
  channel?: 'whatsapp'
  message?: {
    type: 'text'
    text: string
  }
  template?: {
    name: string
    language: string
    components?: Array<{
      type: string
      parameters: Array<{
        type: string
        text?: string
      }>
    }>
  }
}

// Action: Send message response
export interface SendMessageResponse {
  success: boolean
  message_id?: string
  status?: string
  sent_at?: string
  error?: ZapierActionError
}

// Action: Create contact request
export interface CreateContactRequest {
  name: string
  phone: string
  email?: string
  tags?: string[]
  custom_fields?: Record<string, unknown>
}

// Action: Create contact response
export interface CreateContactResponse {
  success: boolean
  contact?: {
    id: string
    name: string
    phone: string
    email?: string
    tags: string[]
    custom_fields: Record<string, unknown>
    created_at: string
  }
  error?: ZapierActionError
}

// Action: Update contact request
export interface UpdateContactRequest {
  name?: string
  email?: string
  tags?: string[]
  custom_fields?: Record<string, unknown>
}

// Action: Update contact response
export interface UpdateContactResponse {
  success: boolean
  contact?: {
    id: string
    name: string
    phone: string
    email?: string
    tags: string[]
    custom_fields: Record<string, unknown>
    updated_at: string
  }
  error?: ZapierActionError
}

// Standardized error response
export interface ZapierActionError {
  code: 'INVALID_INPUT' | 'UNAUTHORIZED' | 'FORBIDDEN' | 'NOT_FOUND' | 'RATE_LIMITED' | 'INTERNAL_ERROR'
  message: string
  field?: string
}

// Rate limit information
export interface RateLimitInfo {
  limit: number
  remaining: number
  reset: number  // Unix timestamp
}

// Retry configuration
export const WEBHOOK_RETRY_DELAYS = [1000, 5000, 30000, 300000, 1800000] as const  // ms
```

Export all types.
  </action>
  <verify>
Run: `npm run type-check`
All types should compile without errors.
  </verify>
  <done>
src/types/zapier.ts exists with all Zapier-related types exported.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. OAuth migration exists at supabase/migrations/20260124_zapier_oauth.sql
2. Webhooks migration exists at supabase/migrations/20260124_zapier_webhooks.sql
3. Types file exists at src/types/oauth.ts
4. Types file exists at src/types/zapier.ts
5. `npm run type-check` passes
6. All tables have RLS policies enforcing tenant isolation
</verification>

<success_criteria>
- OAuth tables support full Authorization Code Grant flow with PKCE
- Webhook tables support REST Hook subscriptions with filtering
- All RLS policies enforce organization isolation
- TypeScript types match database schema exactly
- Types compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-zapier-integration/10-01-SUMMARY.md`
</output>
