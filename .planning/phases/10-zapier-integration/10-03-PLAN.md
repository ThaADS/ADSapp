---
phase: 10-zapier-integration
plan: 03
type: execute
wave: 2
depends_on:
  - 10-01
  - 10-02
files_modified:
  - src/lib/integrations/zapier/rate-limiter.ts
  - src/lib/integrations/zapier/middleware.ts
  - src/lib/integrations/zapier/auth-middleware.ts
autonomous: true

must_haves:
  truths:
    - "Rate limiter enforces per-token limits with sliding window"
    - "429 responses include Retry-After header"
    - "Rate limit headers (X-RateLimit-*) present on all Zapier API responses"
    - "Auth middleware validates Bearer tokens and extracts user/org context"
  artifacts:
    - path: "src/lib/integrations/zapier/rate-limiter.ts"
      provides: "Sliding window rate limiter implementation"
      exports: ["rateLimiter", "RateLimitResult", "checkRateLimit"]
    - path: "src/lib/integrations/zapier/middleware.ts"
      provides: "Combined middleware for Zapier endpoints"
      exports: ["withZapierMiddleware", "ZapierContext"]
    - path: "src/lib/integrations/zapier/auth-middleware.ts"
      provides: "OAuth token validation middleware"
      exports: ["validateBearerToken", "requireScopes"]
  key_links:
    - from: "middleware.ts"
      to: "rate-limiter.ts"
      via: "rate limit check"
    - from: "middleware.ts"
      to: "auth-middleware.ts"
      via: "token validation"
---

<objective>
Implement rate limiting middleware for Zapier API endpoints.

Purpose: Protect ADSapp APIs from abuse while meeting Zapier's rate limit requirements. Implements sliding window rate limiting with proper headers and 429 responses.

Output:
- Rate limiter with in-memory sliding window algorithm
- Auth middleware for Bearer token validation
- Combined middleware wrapper for Zapier endpoints
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-zapier-integration/10-RESEARCH.md

Rate limit requirements from research (Part 5):
- OAuth Endpoints: 20 req/min per IP
- Action APIs: 100 req/min per token
- Subscribe/Unsubscribe: 10 req/min per token
- Trigger Webhooks: 20,000 req/5min per user

Response headers required:
- X-RateLimit-Limit
- X-RateLimit-Remaining
- X-RateLimit-Reset (Unix timestamp)
- Retry-After (on 429 responses)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rate limiter service</name>
  <files>src/lib/integrations/zapier/rate-limiter.ts</files>
  <action>
Create an in-memory sliding window rate limiter:

```typescript
// Rate limit configurations by endpoint type
export interface RateLimitConfig {
  limit: number        // Max requests
  windowMs: number     // Window size in milliseconds
}

export const RATE_LIMITS = {
  oauth: { limit: 20, windowMs: 60 * 1000 },          // 20 req/min
  actions: { limit: 100, windowMs: 60 * 1000 },       // 100 req/min
  subscribe: { limit: 10, windowMs: 60 * 1000 },      // 10 req/min
  webhooks: { limit: 20000, windowMs: 5 * 60 * 1000 } // 20000 req/5min
} as const

export type RateLimitType = keyof typeof RATE_LIMITS

export interface RateLimitResult {
  allowed: boolean
  limit: number
  remaining: number
  reset: number       // Unix timestamp
  retryAfter?: number // Seconds until reset (only if not allowed)
}

// In-memory store for rate limit windows
// Key: identifier (token hash or IP)
// Value: array of timestamps
const windows = new Map<string, number[]>()

// Cleanup old entries periodically
const CLEANUP_INTERVAL_MS = 60 * 1000 // 1 minute
let cleanupTimer: NodeJS.Timeout | null = null

function startCleanup() {
  if (cleanupTimer) return

  cleanupTimer = setInterval(() => {
    const now = Date.now()
    const maxWindowMs = Math.max(...Object.values(RATE_LIMITS).map(r => r.windowMs))

    for (const [key, timestamps] of windows.entries()) {
      const filtered = timestamps.filter(t => now - t < maxWindowMs)
      if (filtered.length === 0) {
        windows.delete(key)
      } else {
        windows.set(key, filtered)
      }
    }
  }, CLEANUP_INTERVAL_MS)
}

// Stop cleanup (for testing)
export function stopCleanup() {
  if (cleanupTimer) {
    clearInterval(cleanupTimer)
    cleanupTimer = null
  }
}

// Clear all windows (for testing)
export function clearWindows() {
  windows.clear()
}

/**
 * Check rate limit for an identifier using sliding window algorithm
 */
export function checkRateLimit(
  identifier: string,
  type: RateLimitType
): RateLimitResult {
  startCleanup()

  const config = RATE_LIMITS[type]
  const now = Date.now()
  const windowStart = now - config.windowMs

  // Get current window
  const key = `${type}:${identifier}`
  const timestamps = windows.get(key) || []

  // Remove expired timestamps
  const validTimestamps = timestamps.filter(t => t >= windowStart)

  // Calculate remaining
  const remaining = Math.max(0, config.limit - validTimestamps.length)
  const reset = Math.floor((now + config.windowMs) / 1000) // Unix timestamp

  if (validTimestamps.length >= config.limit) {
    // Rate limited
    const oldestTimestamp = Math.min(...validTimestamps)
    const retryAfter = Math.ceil((oldestTimestamp + config.windowMs - now) / 1000)

    return {
      allowed: false,
      limit: config.limit,
      remaining: 0,
      reset,
      retryAfter: Math.max(1, retryAfter)
    }
  }

  // Record this request
  validTimestamps.push(now)
  windows.set(key, validTimestamps)

  return {
    allowed: true,
    limit: config.limit,
    remaining: remaining - 1, // -1 because we just used one
    reset
  }
}

/**
 * Get rate limit headers for response
 */
export function getRateLimitHeaders(result: RateLimitResult): Record<string, string> {
  const headers: Record<string, string> = {
    'X-RateLimit-Limit': result.limit.toString(),
    'X-RateLimit-Remaining': result.remaining.toString(),
    'X-RateLimit-Reset': result.reset.toString()
  }

  if (!result.allowed && result.retryAfter) {
    headers['Retry-After'] = result.retryAfter.toString()
  }

  return headers
}

/**
 * Create 429 Too Many Requests response
 */
export function createRateLimitResponse(result: RateLimitResult): Response {
  return new Response(
    JSON.stringify({
      success: false,
      error: {
        code: 'RATE_LIMITED',
        message: `Rate limit exceeded. Please retry after ${result.retryAfter} seconds.`,
        retry_after: result.retryAfter
      }
    }),
    {
      status: 429,
      headers: {
        'Content-Type': 'application/json',
        ...getRateLimitHeaders(result)
      }
    }
  )
}
```

Export all functions and types.
  </action>
  <verify>
Run: `npm run type-check`
Test: Rate limiter correctly counts requests and blocks when limit exceeded.
  </verify>
  <done>
Rate limiter exists with sliding window algorithm and proper header generation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auth middleware</name>
  <files>src/lib/integrations/zapier/auth-middleware.ts</files>
  <action>
Create middleware for validating Bearer tokens:

```typescript
import { NextRequest } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/server'
import { verifyAccessToken, hashToken } from './token-manager'
import { OAuthScope, OAuthJWTPayload } from '@/types/oauth'

export interface AuthResult {
  valid: boolean
  payload?: OAuthJWTPayload
  userId?: string
  organizationId?: string
  scopes?: OAuthScope[]
  error?: string
}

/**
 * Validate Bearer token from Authorization header
 */
export async function validateBearerToken(request: NextRequest): Promise<AuthResult> {
  const authHeader = request.headers.get('authorization')

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return { valid: false, error: 'Missing or invalid Authorization header' }
  }

  const token = authHeader.substring(7) // Remove 'Bearer ' prefix

  // Verify JWT signature and claims
  const payload = await verifyAccessToken(token)

  if (!payload) {
    return { valid: false, error: 'Invalid or expired token' }
  }

  // Verify token exists in database and is not revoked
  const supabase = createServiceRoleClient()
  const tokenHash = hashToken(token)

  const { data: storedToken } = await supabase
    .from('oauth_access_tokens')
    .select('id, revoked_at, expires_at')
    .eq('token_hash', tokenHash)
    .single()

  if (!storedToken) {
    return { valid: false, error: 'Token not found' }
  }

  if (storedToken.revoked_at) {
    return { valid: false, error: 'Token has been revoked' }
  }

  if (new Date(storedToken.expires_at) < new Date()) {
    return { valid: false, error: 'Token has expired' }
  }

  return {
    valid: true,
    payload,
    userId: payload.sub,
    organizationId: payload.org,
    scopes: payload.scope.split(' ') as OAuthScope[]
  }
}

/**
 * Check if required scopes are present
 */
export function requireScopes(
  requiredScopes: OAuthScope[],
  grantedScopes: OAuthScope[]
): { valid: boolean; missing?: OAuthScope[] } {
  const missing = requiredScopes.filter(s => !grantedScopes.includes(s))

  if (missing.length > 0) {
    return { valid: false, missing }
  }

  return { valid: true }
}

/**
 * Create unauthorized response
 */
export function createUnauthorizedResponse(error: string): Response {
  return new Response(
    JSON.stringify({
      success: false,
      error: {
        code: 'UNAUTHORIZED',
        message: error
      }
    }),
    {
      status: 401,
      headers: {
        'Content-Type': 'application/json',
        'WWW-Authenticate': 'Bearer error="invalid_token"'
      }
    }
  )
}

/**
 * Create forbidden response for insufficient scopes
 */
export function createForbiddenResponse(missingScopes: OAuthScope[]): Response {
  return new Response(
    JSON.stringify({
      success: false,
      error: {
        code: 'FORBIDDEN',
        message: `Insufficient permissions. Missing scopes: ${missingScopes.join(', ')}`
      }
    }),
    {
      status: 403,
      headers: {
        'Content-Type': 'application/json',
        'WWW-Authenticate': `Bearer error="insufficient_scope" scope="${missingScopes.join(' ')}"`
      }
    }
  )
}
```

Export all functions and types.
  </action>
  <verify>
Run: `npm run type-check`
Check: Token validation checks both JWT and database state.
  </verify>
  <done>
Auth middleware exists with Bearer token validation and scope checking.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create combined middleware wrapper</name>
  <files>src/lib/integrations/zapier/middleware.ts</files>
  <action>
Create a combined middleware wrapper for Zapier API endpoints:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { checkRateLimit, getRateLimitHeaders, createRateLimitResponse, RateLimitType } from './rate-limiter'
import { validateBearerToken, requireScopes, createUnauthorizedResponse, createForbiddenResponse, AuthResult } from './auth-middleware'
import { OAuthScope } from '@/types/oauth'
import { hashToken } from './token-manager'

export interface ZapierContext {
  userId: string
  organizationId: string
  scopes: OAuthScope[]
}

export interface ZapierMiddlewareOptions {
  rateLimitType: RateLimitType
  requiredScopes?: OAuthScope[]
  skipAuth?: boolean  // For OAuth endpoints that don't need token auth
}

type ZapierHandler = (
  request: NextRequest,
  context: ZapierContext
) => Promise<Response>

/**
 * Wrapper that applies rate limiting and authentication to Zapier endpoints
 */
export function withZapierMiddleware(
  handler: ZapierHandler,
  options: ZapierMiddlewareOptions
) {
  return async function(request: NextRequest): Promise<Response> {
    // 1. Rate limiting
    let rateLimitIdentifier: string

    if (options.skipAuth) {
      // Use IP for unauthenticated endpoints (like OAuth)
      rateLimitIdentifier = getClientIP(request)
    } else {
      // Use token hash for authenticated endpoints
      const token = request.headers.get('authorization')?.substring(7)
      rateLimitIdentifier = token ? hashToken(token) : getClientIP(request)
    }

    const rateLimitResult = checkRateLimit(rateLimitIdentifier, options.rateLimitType)

    if (!rateLimitResult.allowed) {
      return createRateLimitResponse(rateLimitResult)
    }

    // 2. Authentication (if required)
    let context: ZapierContext

    if (!options.skipAuth) {
      const authResult = await validateBearerToken(request)

      if (!authResult.valid) {
        return addRateLimitHeaders(
          createUnauthorizedResponse(authResult.error || 'Authentication failed'),
          rateLimitResult
        )
      }

      // 3. Scope validation
      if (options.requiredScopes && options.requiredScopes.length > 0) {
        const scopeCheck = requireScopes(options.requiredScopes, authResult.scopes!)

        if (!scopeCheck.valid) {
          return addRateLimitHeaders(
            createForbiddenResponse(scopeCheck.missing!),
            rateLimitResult
          )
        }
      }

      context = {
        userId: authResult.userId!,
        organizationId: authResult.organizationId!,
        scopes: authResult.scopes!
      }
    } else {
      // For OAuth endpoints, create empty context
      context = {
        userId: '',
        organizationId: '',
        scopes: []
      }
    }

    // 4. Call the actual handler
    try {
      const response = await handler(request, context)

      // Add rate limit headers to successful response
      return addRateLimitHeaders(response, rateLimitResult)
    } catch (error) {
      console.error('Zapier endpoint error:', error)

      return addRateLimitHeaders(
        new Response(
          JSON.stringify({
            success: false,
            error: {
              code: 'INTERNAL_ERROR',
              message: 'An unexpected error occurred'
            }
          }),
          {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          }
        ),
        rateLimitResult
      )
    }
  }
}

/**
 * Add rate limit headers to a response
 */
function addRateLimitHeaders(response: Response, rateLimitResult: { limit: number; remaining: number; reset: number }): Response {
  const headers = new Headers(response.headers)

  for (const [key, value] of Object.entries(getRateLimitHeaders(rateLimitResult))) {
    headers.set(key, value)
  }

  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers
  })
}

/**
 * Get client IP from request
 */
function getClientIP(request: NextRequest): string {
  // Check common proxy headers
  const forwarded = request.headers.get('x-forwarded-for')
  if (forwarded) {
    return forwarded.split(',')[0].trim()
  }

  const realIP = request.headers.get('x-real-ip')
  if (realIP) {
    return realIP
  }

  // Fallback to a generic identifier
  return 'unknown-ip'
}

/**
 * Helper to create success responses with rate limit headers
 */
export function createSuccessResponse<T>(
  data: T,
  status: number = 200
): Response {
  return new Response(
    JSON.stringify(data),
    {
      status,
      headers: { 'Content-Type': 'application/json' }
    }
  )
}

/**
 * Helper to create error responses
 */
export function createErrorResponse(
  code: string,
  message: string,
  status: number = 400,
  field?: string
): Response {
  return new Response(
    JSON.stringify({
      success: false,
      error: { code, message, field }
    }),
    {
      status,
      headers: { 'Content-Type': 'application/json' }
    }
  )
}
```

Export all functions and types.
  </action>
  <verify>
Run: `npm run type-check`
Check: Middleware chains rate limiting -> auth -> scope validation -> handler.
  </verify>
  <done>
Combined middleware wrapper exists with proper chaining of rate limiting and auth.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create index file for exports</name>
  <files>src/lib/integrations/zapier/index.ts</files>
  <action>
Create an index file to export all Zapier integration modules:

```typescript
// OAuth Provider
export {
  validateClient,
  createAuthorizationCode,
  exchangeCodeForTokens,
  refreshAccessToken,
  revokeToken
} from './oauth-provider'

// Token Manager
export {
  generateSecureToken,
  hashToken,
  generateAccessToken,
  verifyAccessToken,
  generateRefreshToken,
  generateAuthorizationCode,
  verifyCodeChallenge,
  verifyClientSecret,
  hashClientSecret
} from './token-manager'

// Rate Limiter
export {
  RATE_LIMITS,
  checkRateLimit,
  getRateLimitHeaders,
  createRateLimitResponse,
  clearWindows,
  stopCleanup
} from './rate-limiter'
export type { RateLimitConfig, RateLimitType, RateLimitResult } from './rate-limiter'

// Auth Middleware
export {
  validateBearerToken,
  requireScopes,
  createUnauthorizedResponse,
  createForbiddenResponse
} from './auth-middleware'
export type { AuthResult } from './auth-middleware'

// Combined Middleware
export {
  withZapierMiddleware,
  createSuccessResponse,
  createErrorResponse
} from './middleware'
export type { ZapierContext, ZapierMiddlewareOptions } from './middleware'
```
  </action>
  <verify>
Run: `npm run type-check`
All exports should be accessible from `@/lib/integrations/zapier`.
  </verify>
  <done>
Index file exists with all exports from Zapier integration modules.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Rate limiter implements sliding window algorithm
2. Rate limit headers present on all responses
3. 429 responses include Retry-After header
4. Auth middleware validates Bearer tokens against database
5. Scope validation enforces required permissions
6. Combined middleware chains all checks correctly
7. `npm run type-check` passes
</verification>

<success_criteria>
- Rate limits enforced per configuration (100 req/min for actions, etc.)
- 429 responses include correct Retry-After value
- X-RateLimit-* headers present on all Zapier API responses
- Token validation checks both JWT signature and database revocation status
- Scope requirements enforced at middleware level
- Clean separation of concerns between rate limiting and auth
</success_criteria>

<output>
After completion, create `.planning/phases/10-zapier-integration/10-03-SUMMARY.md`
</output>
