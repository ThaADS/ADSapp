# Phase 10.5: i18n Completion - Research

**Researched:** 2026-01-28
**Domain:** Next.js internationalization with custom translation system
**Confidence:** HIGH

## Summary

Phase 10.5 completes the existing i18n infrastructure by fixing TranslationProvider coverage gaps, implementing database-backed language preferences, and adding localized system emails via Resend. The project has a solid custom translation system (not using next-intl library despite having it installed) with JSON translation files, but lacks TranslationProvider wrapping on onboarding pages, database storage for user language preferences, and localized auth emails.

**Key findings:**
- Project uses custom TranslationProvider (not next-intl), which is working well in dashboard/auth layouts
- Onboarding page lacks layout wrapper with TranslationProvider, causing "ik zie de sleutels" issue
- No database field for `preferred_language` in profiles table - needs migration
- Middleware handles cookie/browser detection but doesn't check database preference
- Resend is configured but auth emails use Supabase templates (not localized)
- Translation files exist for all namespaces (auth, onboarding, dashboard, etc.) in both NL and EN

**Primary recommendation:** Wrap onboarding in TranslationProvider, add `preferred_language` column to profiles table, update middleware to prioritize database preference, and implement custom auth emails via Resend with react-email templates using existing translation JSON files.

## Standard Stack

The project uses a **custom i18n implementation** rather than next-intl library patterns, despite next-intl being installed.

### Core (Already Installed)
| Library | Version | Purpose | Why Used |
|---------|---------|---------|----------|
| Custom TranslationProvider | N/A | Client-side translation context | Project-specific implementation with namespace support and cookie management |
| getServerLocale/getTranslations | N/A | Server-side translation utilities | Server-only functions for loading translations in Server Components |
| Resend | ^6.1.0 | Email delivery service | Professional transactional email service with API-first approach |
| next-intl | ^4.3.9 | Not actively used | Installed but project uses custom implementation |

### Supporting (To Add)
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| react-email | Latest | Email template components | Creating type-safe, branded email templates with i18n support |
| i18n-check | Latest | Translation validation CLI | npm script to detect missing translation keys |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Custom implementation | next-intl fully | Would require significant refactoring; custom system is working well |
| HTML string templates | react-email components | React-email provides better maintainability and preview capabilities |
| Build-time validation | Runtime warnings only | Catching missing translations at build prevents production bugs |

**Installation:**
```bash
npm install react-email @react-email/components
npm install --save-dev i18n-check
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── locales/
│   ├── en/
│   │   ├── index.ts           # Barrel export all namespaces
│   │   ├── auth.json
│   │   ├── onboarding.json
│   │   ├── common.json
│   │   └── emails.json        # NEW: Email-specific translations
│   └── nl/
│       └── [same structure]
├── emails/                     # NEW: React email templates
│   ├── templates/
│   │   ├── confirmation.tsx
│   │   ├── password-reset.tsx
│   │   ├── magic-link.tsx
│   │   └── invitation.tsx
│   └── components/
│       ├── email-layout.tsx   # Branded wrapper
│       └── email-button.tsx
├── lib/
│   ├── i18n/
│   │   ├── server.ts          # Server-side utilities
│   │   ├── client.ts          # Client hooks (empty currently)
│   │   └── dictionaries.ts    # Translation loaders
│   └── email/
│       ├── team-invitations.ts # Existing
│       └── auth-emails.ts      # NEW: Auth email sender
└── app/
    ├── onboarding/
    │   └── layout.tsx         # NEW: Add TranslationProvider
    └── [other layouts have it]
```

### Pattern 1: TranslationProvider Wrapping
**What:** Every page subtree must be wrapped with TranslationProvider to provide translation context
**When to use:** All layouts that contain pages with user-facing text
**Example:**
```typescript
// Source: Existing dashboard/layout.tsx and auth/layout.tsx
import { TranslationProvider } from '@/components/providers/translation-provider'
import { getServerLocale } from '@/lib/i18n/server'
import { getDictionary } from '@/lib/i18n/dictionaries'

export default async function OnboardingLayout({ children }: { children: React.ReactNode }) {
  const locale = await getServerLocale()
  const translations = await getDictionary(locale)

  return (
    <TranslationProvider locale={locale} translations={translations}>
      {children}
    </TranslationProvider>
  )
}
```

### Pattern 2: Language Preference Priority Chain
**What:** Multi-source language detection with database as highest priority
**When to use:** Middleware and authentication flows
**Example:**
```typescript
// Priority order (LOCKED decision from CONTEXT.md):
// 1. Database (user.preferred_language in profiles table)
// 2. Cookie (NEXT_LOCALE from previous visit)
// 3. Browser (Accept-Language header)
// 4. Default (fallbackLocale = 'en')

async function getUserPreferredLocale(userId: string): Promise<Locale> {
  // Check database first
  const profile = await supabase
    .from('profiles')
    .select('preferred_language')
    .eq('id', userId)
    .single()

  if (profile?.preferred_language && isValidLocale(profile.preferred_language)) {
    return profile.preferred_language
  }

  // Fallback to cookie/browser detection
  return getLocaleFromCookieOrBrowser()
}
```

### Pattern 3: Localized Email Templates with react-email
**What:** Type-safe email templates that accept locale parameter and use translation files
**When to use:** All system emails (auth, invitations, notifications)
**Example:**
```typescript
// Source: Adapted from react-email i18n patterns
import { Html, Text, Button } from '@react-email/components'

interface ConfirmationEmailProps {
  locale: Locale
  confirmationUrl: string
  translations: Record<string, string>
}

export function ConfirmationEmail({ locale, confirmationUrl, translations }: ConfirmationEmailProps) {
  return (
    <Html lang={locale}>
      <Text>{translations.greeting}</Text>
      <Button href={confirmationUrl}>
        {translations.confirmButton}
      </Button>
    </Html>
  )
}

// Usage in API route
const translations = await getNamespaceDictionary(locale, 'emails')
const emailHtml = render(<ConfirmationEmail locale={locale} confirmationUrl={url} translations={translations} />)

await resend.emails.send({
  from: 'ADSapp <noreply@adsapp.com>',
  to: email,
  subject: translations.confirmationSubject,
  html: emailHtml,
})
```

### Pattern 4: Missing Translation Detection
**What:** Console warnings in development, build-time validation in CI
**When to use:** Development workflow and CI/CD pipeline
**Example:**
```typescript
// Source: Existing TranslationProvider implementation
const t = useCallback(
  (key: string, params?: Record<string, string | number>): string => {
    const value = getNestedValue(translations, key)
    if (!value) {
      console.warn(`Missing translation: ${key}`)
      return key // Fallback to key (helps debugging)
    }
    return interpolate(value, params)
  },
  [translations]
)
```

### Anti-Patterns to Avoid
- **No Provider Fallback:** Never assume TranslationProvider is present - always provide fallback in useTranslations hook (already implemented correctly)
- **Hardcoded Text:** Never use hardcoded strings like "Welcome to ADSapp" - always use translation keys
- **Missing Namespace:** Always organize translations by namespace (auth, dashboard, etc.) - prevents key collisions
- **Locale in URL Path:** Project deliberately avoids `/en/` or `/nl/` URL prefixes per user preference - language is cookie/database-driven only

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Email HTML layout | String concatenation | react-email components | Cross-client compatibility, preview, type safety |
| Translation validation | Manual file comparison | i18n-check CLI tool | Automated key coverage analysis, prevents runtime errors |
| Browser language detection | Custom header parsing | Middleware detectLocale (existing) | Handles quality values, regional variants correctly |
| Email template testing | Manual send tests | react-email preview server | Visual testing without sending real emails |

**Key insight:** Email HTML is notoriously difficult to get right across clients (Gmail, Outlook, Apple Mail). react-email provides battle-tested components that work everywhere, with preview capability. The project currently uses HTML string templates in team-invitations.ts which should be migrated to react-email for consistency.

## Common Pitfalls

### Pitfall 1: Forgetting to Add TranslationProvider to New Layouts
**What goes wrong:** Pages show translation keys (like "onboarding.title") instead of translated text
**Why it happens:** Next.js layouts don't inherit providers from parent layouts - each layout tree needs its own provider
**How to avoid:**
1. Every new layout under `/app` that contains pages must wrap children with TranslationProvider
2. Use checklist: Auth layout ✅, Dashboard layout ✅, Onboarding layout ❌ (needs fix), Root layout (skipped - too high level)
**Warning signs:** User reports seeing "dots and words" instead of readable text, e.g., "ik zie de sleutels" (I see the keys)

### Pitfall 2: Language Preference Not Persisting After Login
**What goes wrong:** User selects Dutch before login, but after login sees English interface
**Why it happens:** Cookie-only storage is lost, and database has no preferred_language field
**How to avoid:**
1. Add `preferred_language TEXT CHECK (preferred_language IN ('nl', 'en'))` to profiles table
2. After login, sync cookie value to database immediately
3. Middleware checks database first for authenticated users
**Warning signs:** Language switcher works temporarily but resets after page reload or re-login

### Pitfall 3: Auth Emails Always in English Regardless of User Preference
**What goes wrong:** Dutch users receive English confirmation/reset emails
**Why it happens:** Supabase Auth uses built-in templates that don't support localization
**How to avoid:**
1. Configure Supabase to use custom SMTP (Resend) instead of built-in email
2. Use Auth Hooks or custom API endpoints to intercept email sending
3. Send localized emails via Resend with react-email templates
**Warning signs:** User complains about language mismatch between app and emails

### Pitfall 4: Missing Translations Only Discovered in Production
**What goes wrong:** New features ship with missing Dutch translations, showing English fallback to NL users
**Why it happens:** No validation at build time or in CI pipeline
**How to avoid:**
1. Add `npm run i18n:check` script with i18n-check tool
2. Configure CI to fail if translation keys are missing
3. Add pre-commit hook to warn about new English keys without Dutch equivalent
**Warning signs:** QA reports inconsistent language, some buttons in English within Dutch interface

### Pitfall 5: Email Subjects Cannot Be Localized in Supabase Templates
**What goes wrong:** Email body is localized but subject line is always in one language
**Why it happens:** Supabase config.toml only accepts one static subject line per template
**How to avoid:**
1. Don't use Supabase Auth templates for localized apps
2. Use custom email sending via Resend with full control over subject and body
3. Store both email subject and body in translation files
**Warning signs:** Email content is correct language but subject is wrong language

## Code Examples

Verified patterns from current codebase and official documentation:

### Server Component Translation (Existing Pattern)
```typescript
// Source: src/lib/i18n/server.ts
import { getTranslations } from '@/lib/i18n/server'

export default async function OnboardingPage() {
  const { t } = await getTranslations('onboarding')

  return (
    <div>
      <h1>{t('title')}</h1>
      <p>{t('description')}</p>
    </div>
  )
}
```

### Client Component Translation (Existing Pattern)
```typescript
// Source: Existing components using useTranslations
'use client'
import { useTranslations } from '@/components/providers/translation-provider'

export function OnboardingForm() {
  const t = useTranslations('onboarding')

  return (
    <form>
      <label>{t('organizationName')}</label>
      <input placeholder={t('organizationNamePlaceholder')} />
      <button>{t('continue')}</button>
    </form>
  )
}
```

### Database Migration for Language Preference
```sql
-- Add preferred_language column to profiles table
ALTER TABLE profiles
ADD COLUMN preferred_language TEXT CHECK (preferred_language IN ('nl', 'en'));

-- Set default to null (will use cookie/browser detection as fallback)
-- Update existing users to their current cookie locale if possible via app logic

-- Index for performance (optional but recommended)
CREATE INDEX idx_profiles_preferred_language ON profiles(preferred_language);
```

### Middleware Language Priority Implementation
```typescript
// Enhanced middleware.ts to check database preference
export async function middleware(request: NextRequest) {
  const sessionResponse = await updateSession(request)

  // For authenticated users, check database preference first
  const user = await supabase.auth.getUser()
  let locale: Locale

  if (user.data.user) {
    // Priority 1: Database
    const { data: profile } = await supabase
      .from('profiles')
      .select('preferred_language')
      .eq('id', user.data.user.id)
      .single()

    if (profile?.preferred_language && isValidLocale(profile.preferred_language)) {
      locale = profile.preferred_language as Locale
    } else {
      // Priority 2 & 3: Cookie or Browser
      locale = getLocale(request)
    }
  } else {
    // Priority 2 & 3: Cookie or Browser (existing logic)
    locale = getLocale(request)
  }

  // Set locale header and cookie
  sessionResponse.headers.set('x-locale', locale)
  sessionResponse.cookies.set(LOCALE_COOKIE, locale, {
    path: '/',
    maxAge: 60 * 60 * 24 * 365,
    sameSite: 'lax',
  })

  return sessionResponse
}
```

### React-Email Template with Localization
```typescript
// Source: Adapted from react-email i18n patterns
// emails/templates/confirmation.tsx
import { Html, Body, Container, Heading, Text, Button, Section } from '@react-email/components'
import { EmailLayout } from '../components/email-layout'

interface ConfirmationEmailProps {
  locale: 'nl' | 'en'
  confirmationUrl: string
  userEmail: string
}

export function ConfirmationEmail({ locale, confirmationUrl, userEmail }: ConfirmationEmailProps) {
  // Load translations (this runs server-side during rendering)
  const translations = locale === 'nl' ? nlTranslations : enTranslations

  return (
    <Html lang={locale}>
      <EmailLayout>
        <Heading>{translations.confirmEmailTitle}</Heading>
        <Text>{translations.confirmEmailGreeting}</Text>
        <Text>{translations.confirmEmailBody}</Text>
        <Section style={{ textAlign: 'center', margin: '32px 0' }}>
          <Button href={confirmationUrl} style={buttonStyle}>
            {translations.confirmButton}
          </Button>
        </Section>
        <Text style={{ fontSize: '14px', color: '#666' }}>
          {translations.confirmEmailFooter}
        </Text>
      </EmailLayout>
    </Html>
  )
}

const buttonStyle = {
  backgroundColor: '#2563eb',
  color: '#ffffff',
  padding: '12px 32px',
  borderRadius: '6px',
  textDecoration: 'none',
}

// Usage in API route
import { render } from '@react-email/render'

const emailHtml = render(
  <ConfirmationEmail
    locale={userLocale}
    confirmationUrl={url}
    userEmail={email}
  />
)

await resend.emails.send({
  from: 'ADSapp <noreply@adsapp.com>',
  to: email,
  subject: translations.confirmEmailSubject,
  html: emailHtml,
})
```

### Translation JSON Structure for Emails
```json
// src/locales/en/emails.json
{
  "confirmEmailSubject": "Confirm your email address",
  "confirmEmailTitle": "Welcome to ADSapp!",
  "confirmEmailGreeting": "Hello,",
  "confirmEmailBody": "Thank you for signing up. Please confirm your email address to get started.",
  "confirmButton": "Confirm Email Address",
  "confirmEmailFooter": "If you didn't create this account, you can safely ignore this email.",

  "resetPasswordSubject": "Reset your password",
  "resetPasswordTitle": "Password Reset Request",
  "resetPasswordBody": "We received a request to reset your password. Click the button below to choose a new password.",
  "resetButton": "Reset Password",
  "resetPasswordExpiry": "This link expires in 24 hours.",

  "magicLinkSubject": "Your sign-in link",
  "magicLinkTitle": "Sign in to ADSapp",
  "magicLinkBody": "Click the button below to sign in to your account.",
  "magicLinkButton": "Sign In",

  "invitationSubject": "You've been invited to join {organizationName}",
  "invitationTitle": "Team Invitation",
  "invitationBody": "{inviterName} has invited you to join their team on ADSapp.",
  "invitationButton": "Accept Invitation"
}
```

### CLI Script for Translation Validation
```json
// package.json scripts
{
  "scripts": {
    "i18n:check": "i18n-check --source en --locales nl --path src/locales",
    "i18n:check:strict": "npm run i18n:check && exit $?",
    "prebuild": "npm run i18n:check || echo 'Warning: Missing translations detected'"
  }
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| next-intl with routing | Custom provider without URL localization | Project decision (likely 2025) | Simpler URLs, cookie-driven instead of path-based |
| Supabase email templates | Custom SMTP via Resend | Industry trend (2024-2026) | Full control over branding and localization |
| HTML string templates | react-email components | Emerging best practice (2025-2026) | Better maintainability, preview, type safety |
| Runtime-only validation | Build-time translation checks | Tooling maturity (2024-2026) | Catch missing translations before production |
| Separate email per language | Single template with locale param | react-email i18n pattern (2025) | DRY principle, easier maintenance |

**Deprecated/outdated:**
- **next-intl URL-based routing (`/en/`, `/nl/`):** Project uses cookie/database approach instead - more appropriate for app (vs. marketing site)
- **Supabase built-in email templates:** Cannot be localized per user preference; use custom SMTP instead
- **i18next library:** Project uses custom simpler implementation; i18next is overkill for 2-language app
- **Manual translation file validation:** Replaced by automated CLI tools like i18n-check

## Open Questions

Things that couldn't be fully resolved:

1. **Should existing team-invitations.ts HTML templates be migrated to react-email?**
   - What we know: team-invitations.ts uses HTML string templates (not localized currently)
   - What's unclear: Whether to migrate existing non-auth emails to react-email in this phase or later
   - Recommendation: Keep team-invitations.ts as-is for now (working), focus on auth emails only for Phase 10.5. Consider react-email migration in future refactoring phase.

2. **Build strictness level: fail on missing translations or warn?**
   - What we know: User wants dev mode warnings (CONTEXT.md specifies this)
   - What's unclear: Whether CI builds should fail or just warn
   - Recommendation: Warn in development (console.warn), soft warning in builds initially (`|| echo 'Warning'`), then upgrade to strict mode (`npm run i18n:check:strict`) once all translations are complete. This prevents blocking development while catching gaps.

3. **Exact database schema for preferred_language**
   - What we know: Need column in profiles table with constraint
   - What's unclear: Should it be nullable (null = use cookie) or have default value?
   - Recommendation: Make it nullable (NULL means "use cookie/browser fallback"). This allows gradual migration - users without explicit preference continue using cookie, users who actively choose language get database persistence.

4. **Supabase Auth Hooks vs Custom API Endpoints for Email Interception**
   - What we know: Supabase Auth Hooks can intercept auth events, or we can use custom API endpoints
   - What's unclear: Which approach is more maintainable for this project's architecture
   - Recommendation: Use custom API endpoints instead of Auth Hooks. Rationale: Project already uses Supabase Auth's built-in flows, intercepting them with hooks adds complexity. Instead, implement custom signup/signin flows that send emails via Resend directly. This gives full control and is more testable.

## Sources

### Primary (HIGH confidence)
- [Context7: /amannn/next-intl](https://github.com/amannn/next-intl) - Next.js i18n patterns and middleware setup
- [Supabase Docs: Customizing Emails by Language](https://supabase.com/docs/guides/troubleshooting/customizing-emails-by-language-KZ_38Q) - Email localization limitations
- [React Email: React Intl Guide](https://react.email/docs/guides/internationalization/react-intl) - Email template i18n patterns
- Existing codebase: `src/components/providers/translation-provider.tsx`, `src/lib/i18n/server.ts`, `middleware.ts` - Current implementation patterns

### Secondary (MEDIUM confidence)
- [Next-intl Middleware Documentation](https://next-intl.dev/docs/routing/middleware) - Language detection priority order
- [Supabase Discussion #6160](https://github.com/orgs/supabase/discussions/6160) - Multi-language template challenges
- [Blog: Custom i18n Auth Emails with Edge Functions](https://blog.mansueli.com/creating-customized-i18n-ready-authentication-emails-using-supabase-edge-functions-postgresql-and-resend) - Resend integration approach
- [i18n-validate GitHub](https://github.com/imranbarbhuiya/i18n-validate) - Translation validation CLI

### Tertiary (LOW confidence)
- [WebSearch: react-email i18n patterns](https://dev.to/femtowork/how-to-send-i18n-html-emails-from-scripts-using-react-email-3lea) - Community implementation examples
- [i18n-check GitHub](https://github.com/lingualdev/i18n-check) - Alternative validation tool

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Project's custom implementation is well-documented in codebase, react-email is proven solution
- Architecture: HIGH - Existing patterns work, need extension not replacement; email patterns from official react-email docs
- Pitfalls: HIGH - Based on actual user bug report ("ik zie de sleutels") and common i18n mistakes
- Email localization: MEDIUM - Supabase limitations documented, but implementation approach (Auth Hooks vs API) requires project-specific decision

**Research date:** 2026-01-28
**Valid until:** 60 days (stable domain - i18n patterns, email tools mature; database migration standard SQL)

**Key Implementation Notes:**
1. **No library refactoring needed:** Keep custom TranslationProvider, it's working well
2. **Database-first for auth users:** Middleware must check profiles.preferred_language before cookie
3. **react-email for new emails only:** Don't refactor existing team-invitations.ts in this phase
4. **Validation as soft warning initially:** Prevent CI blocks during implementation, upgrade to strict after completion
