---
phase: 08-foundation-layer
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/lib/channels/router.ts
  - src/lib/channels/health.ts
  - src/lib/channels/index.ts
autonomous: true

must_haves:
  truths:
    - "UnifiedMessageRouter can register and retrieve channel adapters by type"
    - "Messages route through the correct adapter based on channelType"
    - "Health monitoring detects unhealthy channels and reports status"
  artifacts:
    - path: "src/lib/channels/router.ts"
      provides: "Unified message router for all channels"
      exports: ["UnifiedMessageRouter"]
    - path: "src/lib/channels/health.ts"
      provides: "Channel health monitoring"
      exports: ["ChannelHealthMonitor"]
    - path: "src/lib/channels/index.ts"
      provides: "Public exports for channels module"
      exports: ["UnifiedMessageRouter", "ChannelHealthMonitor"]
  key_links:
    - from: "src/lib/channels/router.ts"
      to: "src/types/channels.ts"
      via: "ChannelAdapter, CanonicalMessage imports"
    - from: "src/lib/channels/router.ts"
      to: "src/lib/channels/health.ts"
      via: "ChannelHealthMonitor import"
---

<objective>
Create the UnifiedMessageRouter that coordinates message routing across all channel adapters.

Purpose: Provide a single entry point for sending and receiving messages across any channel. The router handles adapter registration, message routing, feature validation, and health monitoring.

Output:
- UnifiedMessageRouter class with send/receive methods
- ChannelHealthMonitor for tracking channel status
- Public module exports
</objective>

<execution_context>
@C:\Users\info\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\info\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-foundation-layer/08-RESEARCH.md
@.planning/phases/08-foundation-layer/08-01-SUMMARY.md

Types from Plan 01:
@src/types/channels.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create channel health monitor</name>
  <files>src/lib/channels/health.ts</files>
  <action>
Create the health directory and health monitor:

1. **Create directory**: src/lib/channels/ (if not exists)

2. **ChannelHealthStatus interface**:
   ```typescript
   interface ChannelHealthStatus {
     channelType: ChannelType
     isHealthy: boolean
     lastCheck: Date
     latency?: number
     rateLimit?: {
       remaining: number
       resetAt: Date
     }
     lastError?: string
     consecutiveFailures: number
   }
   ```

3. **ChannelHealthMonitor class**:
   ```typescript
   import { ChannelType, ChannelAdapter, HealthStatus } from '@/types/channels'

   export class ChannelHealthMonitor {
     private healthStatus: Map<ChannelType, ChannelHealthStatus> = new Map()
     private adapters: Map<ChannelType, ChannelAdapter> = new Map()

     // Configuration
     private readonly checkIntervalMs: number
     private readonly unhealthyThreshold: number // consecutive failures before marking unhealthy
     private checkInterval: NodeJS.Timeout | null = null

     constructor(options?: {
       checkIntervalMs?: number
       unhealthyThreshold?: number
     }) {
       this.checkIntervalMs = options?.checkIntervalMs ?? 60000 // 1 minute
       this.unhealthyThreshold = options?.unhealthyThreshold ?? 3
     }

     // Register adapter for health monitoring
     registerAdapter(adapter: ChannelAdapter): void {
       this.adapters.set(adapter.channelType, adapter)
       this.healthStatus.set(adapter.channelType, {
         channelType: adapter.channelType,
         isHealthy: true, // Assume healthy until proven otherwise
         lastCheck: new Date(),
         consecutiveFailures: 0
       })
     }

     // Unregister adapter
     unregisterAdapter(channelType: ChannelType): void {
       this.adapters.delete(channelType)
       this.healthStatus.delete(channelType)
     }

     // Get current health status for a channel
     getHealth(channelType: ChannelType): ChannelHealthStatus | undefined {
       return this.healthStatus.get(channelType)
     }

     // Get all channel health statuses
     getAllHealth(): ChannelHealthStatus[] {
       return Array.from(this.healthStatus.values())
     }

     // Check health for specific channel
     async checkHealth(channelType: ChannelType): Promise<ChannelHealthStatus> {
       const adapter = this.adapters.get(channelType)
       const currentStatus = this.healthStatus.get(channelType)

       if (!adapter || !currentStatus) {
         throw new Error(`No adapter registered for channel: ${channelType}`)
       }

       try {
         const result: HealthStatus = await adapter.healthCheck()

         const newStatus: ChannelHealthStatus = {
           channelType,
           isHealthy: result.isHealthy,
           lastCheck: new Date(),
           latency: result.latency,
           rateLimit: result.rateLimit,
           consecutiveFailures: result.isHealthy ? 0 : currentStatus.consecutiveFailures + 1,
           lastError: result.lastError
         }

         // Mark unhealthy if consecutive failures exceed threshold
         if (newStatus.consecutiveFailures >= this.unhealthyThreshold) {
           newStatus.isHealthy = false
         }

         this.healthStatus.set(channelType, newStatus)
         return newStatus

       } catch (error) {
         const errorMessage = error instanceof Error ? error.message : 'Unknown error'
         const newStatus: ChannelHealthStatus = {
           channelType,
           isHealthy: false,
           lastCheck: new Date(),
           consecutiveFailures: currentStatus.consecutiveFailures + 1,
           lastError: errorMessage
         }

         this.healthStatus.set(channelType, newStatus)
         return newStatus
       }
     }

     // Start periodic health checks
     startPeriodicChecks(): void {
       if (this.checkInterval) return

       this.checkInterval = setInterval(async () => {
         const checkPromises = Array.from(this.adapters.keys()).map(type =>
           this.checkHealth(type).catch(err =>
             console.error(`Health check failed for ${type}:`, err)
           )
         )
         await Promise.allSettled(checkPromises)
       }, this.checkIntervalMs)
     }

     // Stop periodic health checks
     stopPeriodicChecks(): void {
       if (this.checkInterval) {
         clearInterval(this.checkInterval)
         this.checkInterval = null
       }
     }

     // Record a successful operation (resets failure count)
     recordSuccess(channelType: ChannelType): void {
       const status = this.healthStatus.get(channelType)
       if (status) {
         status.isHealthy = true
         status.consecutiveFailures = 0
         status.lastCheck = new Date()
       }
     }

     // Record a failed operation
     recordFailure(channelType: ChannelType, error: string): void {
       const status = this.healthStatus.get(channelType)
       if (status) {
         status.consecutiveFailures++
         status.lastError = error
         status.lastCheck = new Date()
         if (status.consecutiveFailures >= this.unhealthyThreshold) {
           status.isHealthy = false
         }
       }
     }
   }
   ```

Export ChannelHealthMonitor and ChannelHealthStatus type.
  </action>
  <verify>
Run: `npm run type-check`
File should compile without errors.
  </verify>
  <done>
src/lib/channels/health.ts exists with ChannelHealthMonitor class and health tracking functionality.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create unified message router</name>
  <files>src/lib/channels/router.ts</files>
  <action>
Create the UnifiedMessageRouter based on research Section 4.1:

```typescript
import {
  ChannelType,
  ChannelAdapter,
  CanonicalMessage,
  SendResult,
  ChannelFeature
} from '@/types/channels'
import { ChannelHealthMonitor } from './health'

export interface RouterOptions {
  healthMonitor?: ChannelHealthMonitor
  enableHealthChecks?: boolean
}

export interface RoutingResult extends SendResult {
  channelType: ChannelType
  routedAt: Date
}

export class UnifiedMessageRouter {
  private adapters: Map<ChannelType, ChannelAdapter> = new Map()
  private healthMonitor: ChannelHealthMonitor

  constructor(options?: RouterOptions) {
    this.healthMonitor = options?.healthMonitor ?? new ChannelHealthMonitor()

    if (options?.enableHealthChecks !== false) {
      this.healthMonitor.startPeriodicChecks()
    }
  }

  // Register a channel adapter
  registerAdapter(adapter: ChannelAdapter): void {
    if (this.adapters.has(adapter.channelType)) {
      console.warn(`Adapter for ${adapter.channelType} already registered, replacing`)
    }
    this.adapters.set(adapter.channelType, adapter)
    this.healthMonitor.registerAdapter(adapter)
    console.log(`Registered adapter: ${adapter.name} (${adapter.channelType})`)
  }

  // Unregister a channel adapter
  unregisterAdapter(channelType: ChannelType): void {
    this.adapters.delete(channelType)
    this.healthMonitor.unregisterAdapter(channelType)
  }

  // Get registered adapter
  getAdapter(channelType: ChannelType): ChannelAdapter | undefined {
    return this.adapters.get(channelType)
  }

  // Get all registered adapters
  getRegisteredChannels(): ChannelType[] {
    return Array.from(this.adapters.keys())
  }

  // Route outbound message through appropriate adapter
  async route(message: CanonicalMessage): Promise<RoutingResult> {
    const { channelType } = message

    // 1. Get adapter
    const adapter = this.adapters.get(channelType)
    if (!adapter) {
      return {
        success: false,
        error: `No adapter registered for channel: ${channelType}`,
        retryable: false,
        channelType,
        routedAt: new Date()
      }
    }

    // 2. Check channel health
    const health = this.healthMonitor.getHealth(channelType)
    if (health && !health.isHealthy) {
      return {
        success: false,
        error: `Channel ${channelType} is unhealthy: ${health.lastError}`,
        retryable: true, // Retryable because channel may recover
        channelType,
        routedAt: new Date()
      }
    }

    // 3. Validate message supports required features
    if (message.richContent && !adapter.supportsFeature(ChannelFeature.RICH_CONTENT)) {
      return {
        success: false,
        error: `Channel ${channelType} does not support rich content`,
        retryable: false,
        channelType,
        routedAt: new Date()
      }
    }

    if (message.media && !adapter.supportsFeature(ChannelFeature.MEDIA)) {
      return {
        success: false,
        error: `Channel ${channelType} does not support media`,
        retryable: false,
        channelType,
        routedAt: new Date()
      }
    }

    // 4. Validate message
    const validation = adapter.validateMessage(message)
    if (!validation.valid) {
      return {
        success: false,
        error: `Validation failed: ${validation.errors.join(', ')}`,
        retryable: false,
        channelType,
        routedAt: new Date()
      }
    }

    // 5. Send via adapter
    try {
      const result = await adapter.send(message)

      if (result.success) {
        this.healthMonitor.recordSuccess(channelType)
      } else {
        this.healthMonitor.recordFailure(channelType, result.error || 'Unknown error')
      }

      return {
        ...result,
        channelType,
        routedAt: new Date()
      }

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      this.healthMonitor.recordFailure(channelType, errorMessage)

      return {
        success: false,
        error: errorMessage,
        retryable: this.isRetryableError(error),
        channelType,
        routedAt: new Date()
      }
    }
  }

  // Receive and normalize inbound message from webhook
  async receive(
    channelType: ChannelType,
    webhookPayload: unknown
  ): Promise<CanonicalMessage> {
    const adapter = this.adapters.get(channelType)
    if (!adapter) {
      throw new Error(`No adapter registered for channel: ${channelType}`)
    }

    try {
      const canonicalMessage = await adapter.receive(webhookPayload)
      this.healthMonitor.recordSuccess(channelType)
      return canonicalMessage

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      this.healthMonitor.recordFailure(channelType, errorMessage)
      throw error
    }
  }

  // Get health status for all channels
  getHealthStatus() {
    return this.healthMonitor.getAllHealth()
  }

  // Get health status for specific channel
  getChannelHealth(channelType: ChannelType) {
    return this.healthMonitor.getHealth(channelType)
  }

  // Check if channel supports a specific feature
  channelSupportsFeature(channelType: ChannelType, feature: ChannelFeature): boolean {
    const adapter = this.adapters.get(channelType)
    return adapter ? adapter.supportsFeature(feature) : false
  }

  // Shutdown router
  shutdown(): void {
    this.healthMonitor.stopPeriodicChecks()
    this.adapters.clear()
  }

  private isRetryableError(error: unknown): boolean {
    if (error instanceof Error) {
      const message = error.message.toLowerCase()
      return (
        message.includes('rate limit') ||
        message.includes('timeout') ||
        message.includes('network') ||
        message.includes('429') ||
        message.includes('500') ||
        message.includes('502') ||
        message.includes('503')
      )
    }
    return false
  }
}
```

Export UnifiedMessageRouter and RouterOptions.
  </action>
  <verify>
Run: `npm run type-check`
All methods should compile without errors.
  </verify>
  <done>
src/lib/channels/router.ts exists with UnifiedMessageRouter class implementing message routing, health checking, and feature validation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create module index with public exports</name>
  <files>src/lib/channels/index.ts</files>
  <action>
Create the public API for the channels module:

```typescript
// Main exports
export { UnifiedMessageRouter } from './router'
export type { RouterOptions, RoutingResult } from './router'

export { ChannelHealthMonitor } from './health'
export type { ChannelHealthStatus } from './health'

// Re-export types from types/channels for convenience
export {
  ChannelType,
  ChannelFeature,
  type CanonicalMessage,
  type ChannelAdapter,
  type SendResult,
  type MessageStatus,
  type ValidationResult,
  type HealthStatus,
  type MediaContent,
  type RichContent
} from '@/types/channels'

// Factory function to create router with common adapters
export async function createRouter(): Promise<UnifiedMessageRouter> {
  const router = new UnifiedMessageRouter()
  // Adapters are registered by the application, not here
  // This is just a convenience factory
  return router
}
```

This provides a clean public API for the channels module.
  </action>
  <verify>
Run: `npm run type-check`
Index should re-export all necessary types and classes.
  </verify>
  <done>
src/lib/channels/index.ts exists with clean public exports for router, health monitor, and types.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. src/lib/channels/health.ts exports ChannelHealthMonitor
2. src/lib/channels/router.ts exports UnifiedMessageRouter
3. src/lib/channels/index.ts provides public module API
4. `npm run type-check` passes
5. Router can register adapters and route messages
</verification>

<success_criteria>
- UnifiedMessageRouter routes messages to correct adapter
- Health monitor tracks channel status
- Feature validation prevents unsupported operations
- Module provides clean public API
- All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-foundation-layer/08-03-SUMMARY.md`
</output>
