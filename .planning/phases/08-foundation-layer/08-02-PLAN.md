---
phase: 08-foundation-layer
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/lib/channels/adapters/base.ts
  - src/lib/channels/adapters/whatsapp.ts
autonomous: true

must_haves:
  truths:
    - "WhatsAppAdapter implements all ChannelAdapter interface methods"
    - "WhatsApp messages convert to and from CanonicalMessage format without data loss"
    - "Adapter correctly detects supported WhatsApp features"
  artifacts:
    - path: "src/lib/channels/adapters/base.ts"
      provides: "Base adapter with shared utilities"
      exports: ["BaseChannelAdapter"]
    - path: "src/lib/channels/adapters/whatsapp.ts"
      provides: "WhatsApp channel adapter implementation"
      exports: ["WhatsAppAdapter"]
  key_links:
    - from: "src/lib/channels/adapters/whatsapp.ts"
      to: "src/lib/whatsapp/enhanced-client.ts"
      via: "EnhancedWhatsAppClient import"
    - from: "src/lib/channels/adapters/whatsapp.ts"
      to: "src/types/channels.ts"
      via: "CanonicalMessage, ChannelAdapter imports"
---

<objective>
Create the WhatsApp channel adapter that wraps the existing EnhancedWhatsAppClient.

Purpose: Demonstrate the channel abstraction pattern works by adapting the existing WhatsApp implementation. This adapter becomes the reference implementation for future channels.

Output:
- Base adapter class with shared utilities
- WhatsAppAdapter implementing ChannelAdapter interface
</objective>

<execution_context>
@C:\Users\info\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\info\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-foundation-layer/08-RESEARCH.md
@.planning/phases/08-foundation-layer/08-01-SUMMARY.md

Existing code to wrap:
@src/lib/whatsapp/enhanced-client.ts
@src/lib/whatsapp/client.ts

Types from Plan 01:
@src/types/channels.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create base adapter with shared utilities</name>
  <files>src/lib/channels/adapters/base.ts</files>
  <action>
Create the channels adapters directory and base adapter file:

1. **Create directory structure**: src/lib/channels/adapters/

2. **BaseChannelAdapter abstract class**:
   ```typescript
   import {
     ChannelAdapter,
     ChannelType,
     ChannelFeature,
     CanonicalMessage,
     SendResult,
     MessageStatus,
     ValidationResult,
     HealthStatus
   } from '@/types/channels'

   export abstract class BaseChannelAdapter implements ChannelAdapter {
     abstract readonly channelType: ChannelType
     abstract readonly name: string

     abstract send(message: CanonicalMessage): Promise<SendResult>
     abstract receive(webhookPayload: unknown): Promise<CanonicalMessage>
     abstract getStatus(channelMessageId: string): Promise<MessageStatus>
     abstract supportsFeature(feature: ChannelFeature): boolean
     abstract getFeatures(): ChannelFeature[]
     abstract healthCheck(): Promise<HealthStatus>

     // Shared validation logic
     validateMessage(message: CanonicalMessage): ValidationResult {
       const errors: string[] = []

       if (!message.content && !message.media && !message.richContent) {
         errors.push('Message must have content, media, or rich content')
       }

       if (!message.channelMetadata) {
         errors.push('Channel metadata is required')
       }

       // Subclasses add channel-specific validation
       const channelErrors = this.validateChannelSpecific(message)
       errors.push(...channelErrors)

       return {
         valid: errors.length === 0,
         errors
       }
     }

     // Hook for channel-specific validation
     protected validateChannelSpecific(message: CanonicalMessage): string[] {
       return []
     }

     // Utility: Normalize phone number to E.164
     protected normalizePhoneNumber(phone: string): string {
       const cleaned = phone.replace(/[^0-9+]/g, '')
       return cleaned.startsWith('+') ? cleaned : `+${cleaned}`
     }

     // Utility: Check if error is retryable
     protected isRetryableError(error: unknown): boolean {
       if (error instanceof Error) {
         // Rate limit, network issues, server errors
         const message = error.message.toLowerCase()
         return (
           message.includes('rate limit') ||
           message.includes('timeout') ||
           message.includes('network') ||
           message.includes('500') ||
           message.includes('502') ||
           message.includes('503') ||
           message.includes('429')
         )
       }
       return false
     }

     // Utility: Generate internal message ID
     protected generateMessageId(): string {
       return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`
     }
   }
   ```

Export the BaseChannelAdapter.
  </action>
  <verify>
Run: `npm run type-check`
File should compile without errors.
  </verify>
  <done>
src/lib/channels/adapters/base.ts exists with BaseChannelAdapter abstract class and utility methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create WhatsApp adapter implementing ChannelAdapter</name>
  <files>src/lib/channels/adapters/whatsapp.ts</files>
  <action>
Create WhatsAppAdapter wrapping the existing EnhancedWhatsAppClient based on research Section 4.3:

1. **Imports**:
   ```typescript
   import { BaseChannelAdapter } from './base'
   import {
     ChannelType,
     ChannelFeature,
     CanonicalMessage,
     SendResult,
     MessageStatus,
     HealthStatus,
     MediaContent
   } from '@/types/channels'
   import {
     EnhancedWhatsAppClient,
     WhatsAppMessage,
     WhatsAppMedia,
     WhatsAppStatus
   } from '@/lib/whatsapp/enhanced-client'
   ```

2. **WhatsAppAdapter class extending BaseChannelAdapter**:
   - Properties:
     - readonly channelType = ChannelType.WHATSAPP
     - readonly name = 'WhatsApp Business Cloud API'
     - private client: EnhancedWhatsAppClient
     - private phoneNumberId: string

   - Constructor takes accessToken and phoneNumberId

   - **send(message: CanonicalMessage): Promise<SendResult>**:
     - Extract phone number from channelMetadata
     - Convert canonical to WhatsApp format via toWhatsAppFormat()
     - Call this.client.sendMessage()
     - Return { success: true, channelMessageId } or { success: false, error, retryable }

   - **receive(webhookPayload: unknown): Promise<CanonicalMessage>**:
     - Parse webhook payload to extract WhatsAppMessage
     - Convert to canonical format via toCanonicalFormat()
     - Return CanonicalMessage

   - **getStatus(channelMessageId: string): Promise<MessageStatus>**:
     - Return current status (simplified - WhatsApp doesn't have status lookup API)
     - Status updates come via webhook, not API query
     - Return 'sent' as default

   - **supportsFeature(feature: ChannelFeature): boolean**:
     - Return true for: RICH_CONTENT, MEDIA, READ_RECEIPTS, LOCATION_SHARING, CONTACT_CARDS
     - Return false for: TYPING_INDICATORS (not supported in Cloud API)

   - **getFeatures(): ChannelFeature[]**:
     - Return array of supported features

   - **healthCheck(): Promise<HealthStatus>**:
     - Call this.client.getBusinessProfile(this.phoneNumberId)
     - Return { isHealthy: true, latency } on success
     - Return { isHealthy: false, lastError } on failure

   - **protected validateChannelSpecific(message: CanonicalMessage): string[]**:
     - Check phone number exists in channelMetadata
     - Check content length <= 4096 characters
     - Check media type is supported (image, video, audio, document)

3. **Private conversion methods**:

   - **toWhatsAppFormat(canonical: CanonicalMessage): Record<string, unknown>**:
     - Map contentType to WhatsApp message type
     - Handle text: { type: 'text', text: { body: content } }
     - Handle media: { type: mediaType, [mediaType]: { link: url, caption } }
     - Handle rich content buttons/lists

   - **toCanonicalFormat(whatsapp: WhatsAppMessage, phoneNumber: string): CanonicalMessage**:
     - Map WhatsApp type to contentType
     - Extract content from text.body or caption
     - Map media fields to MediaContent
     - Map interactive to richContent
     - Set timestamp, direction: 'inbound', status: 'delivered'
     - Include channelMetadata with phoneNumber and profileName

   - **parseWebhookPayload(payload: unknown): WhatsAppMessage**:
     - Validate payload structure
     - Extract message from entry[0].changes[0].value.messages[0]
     - Throw if invalid format

4. **Static factory method**:
   ```typescript
   static async createForOrganization(organizationId: string): Promise<WhatsAppAdapter> {
     // Use existing getWhatsAppClient logic to get credentials
     // Return new WhatsAppAdapter instance
   }
   ```

Export WhatsAppAdapter.
  </action>
  <verify>
Run: `npm run type-check`
All methods should implement ChannelAdapter interface correctly.
  </verify>
  <done>
src/lib/channels/adapters/whatsapp.ts exists with WhatsAppAdapter implementing all ChannelAdapter methods, conversion utilities, and factory method.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. Directory structure: src/lib/channels/adapters/ exists
2. base.ts exports BaseChannelAdapter
3. whatsapp.ts exports WhatsAppAdapter
4. `npm run type-check` passes
5. WhatsAppAdapter implements all ChannelAdapter methods
</verification>

<success_criteria>
- WhatsAppAdapter implements ChannelAdapter interface
- Adapter wraps existing EnhancedWhatsAppClient
- Canonical <-> WhatsApp format conversion works
- Feature detection returns correct capabilities
- Code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-foundation-layer/08-02-SUMMARY.md`
</output>
