---
phase: 08-foundation-layer
plan: 04
type: execute
wave: 3
depends_on: ["08-02", "08-03"]
files_modified:
  - src/lib/channels/adapters/index.ts
  - src/lib/channels/contact-dedup.ts
  - src/app/api/webhooks/whatsapp/route.ts
autonomous: true

must_haves:
  truths:
    - "WhatsApp webhook uses UnifiedMessageRouter for message processing"
    - "Contact deduplication normalizes phone numbers to E.164 format"
    - "Inbound messages are converted to CanonicalMessage format before storage"
  artifacts:
    - path: "src/lib/channels/adapters/index.ts"
      provides: "Adapter factory and exports"
      exports: ["createWhatsAppAdapter", "WhatsAppAdapter"]
    - path: "src/lib/channels/contact-dedup.ts"
      provides: "Contact deduplication utilities"
      exports: ["normalizeIdentifier", "findOrCreateContact"]
    - path: "src/app/api/webhooks/whatsapp/route.ts"
      provides: "Updated webhook using router"
  key_links:
    - from: "src/app/api/webhooks/whatsapp/route.ts"
      to: "src/lib/channels/router.ts"
      via: "UnifiedMessageRouter import"
    - from: "src/app/api/webhooks/whatsapp/route.ts"
      to: "src/lib/channels/adapters/whatsapp.ts"
      via: "WhatsAppAdapter import"
---

<objective>
Integrate the channel abstraction layer into the existing WhatsApp webhook.

Purpose: Connect the new router and adapter to the production webhook, enabling the abstraction layer to handle real messages while maintaining backward compatibility with existing message storage.

Output:
- Adapter factory and exports
- Contact deduplication utilities
- Updated webhook using the router
</objective>

<execution_context>
@C:\Users\info\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\info\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-foundation-layer/08-RESEARCH.md
@.planning/phases/08-foundation-layer/08-02-SUMMARY.md
@.planning/phases/08-foundation-layer/08-03-SUMMARY.md

Existing webhook to update:
@src/app/api/webhooks/whatsapp/route.ts

New components:
@src/lib/channels/adapters/whatsapp.ts
@src/lib/channels/router.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create adapter factory and exports</name>
  <files>src/lib/channels/adapters/index.ts</files>
  <action>
Create the adapters index with factory functions:

```typescript
import { ChannelType } from '@/types/channels'
import { WhatsAppAdapter } from './whatsapp'
import { createClient } from '@/lib/supabase/server'
import { decryptWhatsAppCredentials } from '@/lib/security/credential-manager'

// Re-export adapter classes
export { BaseChannelAdapter } from './base'
export { WhatsAppAdapter } from './whatsapp'

// Factory function to create WhatsApp adapter for an organization
export async function createWhatsAppAdapter(organizationId: string): Promise<WhatsAppAdapter> {
  const supabase = await createClient()

  const { data: organization, error } = await supabase
    .from('organizations')
    .select('whatsapp_access_token, whatsapp_phone_number_id, whatsapp_business_account_id, whatsapp_webhook_verify_token')
    .eq('id', organizationId)
    .single()

  if (error || !organization?.whatsapp_access_token) {
    throw new Error('WhatsApp credentials not found for organization')
  }

  // Decrypt credentials
  const credentials = decryptWhatsAppCredentials(
    organizationId,
    organization.whatsapp_access_token,
    organization.whatsapp_phone_number_id,
    organization.whatsapp_business_account_id,
    organization.whatsapp_webhook_verify_token
  )

  if (!credentials) {
    throw new Error('Failed to decrypt WhatsApp credentials')
  }

  return new WhatsAppAdapter(credentials.accessToken, credentials.phoneNumberId)
}

// Factory to create adapter by type for an organization
export async function createAdapterForOrganization(
  organizationId: string,
  channelType: ChannelType
): Promise<WhatsAppAdapter> {
  switch (channelType) {
    case ChannelType.WHATSAPP:
      return createWhatsAppAdapter(organizationId)
    case ChannelType.INSTAGRAM:
    case ChannelType.FACEBOOK:
    case ChannelType.SMS:
      throw new Error(`Channel type ${channelType} not yet implemented`)
    default:
      throw new Error(`Unknown channel type: ${channelType}`)
  }
}
```

This provides a clean way to instantiate adapters for organizations.
  </action>
  <verify>
Run: `npm run type-check`
Factory functions should compile without errors.
  </verify>
  <done>
src/lib/channels/adapters/index.ts exists with factory functions for creating adapters.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create contact deduplication utilities</name>
  <files>src/lib/channels/contact-dedup.ts</files>
  <action>
Create contact deduplication utilities based on research Section 6:

```typescript
import { ChannelType } from '@/types/channels'
import { createClient } from '@/lib/supabase/server'
import type { SupabaseClient } from '@supabase/supabase-js'

export interface ContactInfo {
  name?: string
  avatarUrl?: string
  metadata?: Record<string, unknown>
}

// Normalize channel identifier to standard format
export function normalizeIdentifier(
  channelType: ChannelType,
  identifier: string
): string {
  switch (channelType) {
    case ChannelType.WHATSAPP:
    case ChannelType.SMS:
      return normalizePhoneNumber(identifier)
    case ChannelType.INSTAGRAM:
      // Remove @ prefix, lowercase
      return identifier.toLowerCase().replace(/^@/, '')
    case ChannelType.FACEBOOK:
      // PSID is already normalized
      return identifier
    default:
      return identifier
  }
}

// Normalize phone number to E.164 format
export function normalizePhoneNumber(phone: string): string {
  // Remove all non-numeric characters except leading +
  let cleaned = phone.replace(/[^0-9+]/g, '')

  // Ensure it starts with +
  if (!cleaned.startsWith('+')) {
    // Assume it needs a + prefix
    cleaned = `+${cleaned}`
  }

  return cleaned
}

// Find or create contact for a channel identifier
export async function findOrCreateContact(
  supabase: SupabaseClient,
  organizationId: string,
  channelType: ChannelType,
  channelIdentifier: string,
  contactInfo: ContactInfo = {}
): Promise<{ contactId: string; isNew: boolean }> {
  const normalized = normalizeIdentifier(channelType, channelIdentifier)

  // 1. Check if channel_connection exists
  const { data: existingConnection } = await supabase
    .from('channel_connections')
    .select('contact_id')
    .eq('organization_id', organizationId)
    .eq('channel_type', channelType)
    .eq('channel_identifier', normalized)
    .single()

  if (existingConnection) {
    // Update last_message_at
    await supabase
      .from('channel_connections')
      .update({
        last_message_at: new Date().toISOString(),
        message_count: supabase.sql`message_count + 1`
      })
      .eq('organization_id', organizationId)
      .eq('channel_type', channelType)
      .eq('channel_identifier', normalized)

    return { contactId: existingConnection.contact_id, isNew: false }
  }

  // 2. For phone-based channels, search existing contacts by phone
  if (channelType === ChannelType.WHATSAPP || channelType === ChannelType.SMS) {
    const { data: existingContact } = await supabase
      .from('contacts')
      .select('id')
      .eq('organization_id', organizationId)
      .eq('phone_number', normalized)
      .single()

    if (existingContact) {
      // Create channel_connection for existing contact
      await createChannelConnection(
        supabase,
        organizationId,
        existingContact.id,
        channelType,
        normalized,
        contactInfo
      )
      return { contactId: existingContact.id, isNew: false }
    }
  }

  // 3. Create new contact
  const { data: newContact, error: contactError } = await supabase
    .from('contacts')
    .insert({
      organization_id: organizationId,
      name: contactInfo.name || normalized,
      phone_number: (channelType === ChannelType.WHATSAPP || channelType === ChannelType.SMS)
        ? normalized
        : null,
      avatar_url: contactInfo.avatarUrl,
      status: 'active',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    })
    .select('id')
    .single()

  if (contactError || !newContact) {
    throw new Error(`Failed to create contact: ${contactError?.message}`)
  }

  // 4. Create channel_connection for new contact
  await createChannelConnection(
    supabase,
    organizationId,
    newContact.id,
    channelType,
    normalized,
    contactInfo
  )

  return { contactId: newContact.id, isNew: true }
}

// Create channel connection record
async function createChannelConnection(
  supabase: SupabaseClient,
  organizationId: string,
  contactId: string,
  channelType: ChannelType,
  channelIdentifier: string,
  contactInfo: ContactInfo
): Promise<void> {
  const { error } = await supabase
    .from('channel_connections')
    .insert({
      organization_id: organizationId,
      contact_id: contactId,
      channel_type: channelType,
      channel_identifier: channelIdentifier,
      display_name: contactInfo.name,
      avatar_url: contactInfo.avatarUrl,
      channel_metadata: contactInfo.metadata || {},
      is_primary: true, // First connection is primary
      is_active: true,
      last_message_at: new Date().toISOString(),
      message_count: 1,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    })

  if (error) {
    console.error('Failed to create channel connection:', error)
    // Don't throw - contact exists, connection is nice-to-have
  }
}

// Upsert channel connection (update if exists, create if not)
export async function upsertChannelConnection(
  supabase: SupabaseClient,
  organizationId: string,
  contactId: string,
  channelType: ChannelType,
  channelIdentifier: string,
  updates: Partial<ContactInfo> = {}
): Promise<void> {
  const normalized = normalizeIdentifier(channelType, channelIdentifier)

  const { error } = await supabase
    .from('channel_connections')
    .upsert(
      {
        organization_id: organizationId,
        contact_id: contactId,
        channel_type: channelType,
        channel_identifier: normalized,
        display_name: updates.name,
        avatar_url: updates.avatarUrl,
        channel_metadata: updates.metadata || {},
        is_active: true,
        last_message_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      },
      {
        onConflict: 'organization_id,channel_type,channel_identifier'
      }
    )

  if (error) {
    console.error('Failed to upsert channel connection:', error)
  }
}
```

Export all functions.
  </action>
  <verify>
Run: `npm run type-check`
All functions should compile and handle edge cases.
  </verify>
  <done>
src/lib/channels/contact-dedup.ts exists with normalizeIdentifier, findOrCreateContact, and upsertChannelConnection functions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update WhatsApp webhook to use router</name>
  <files>src/app/api/webhooks/whatsapp/route.ts</files>
  <action>
Update the existing WhatsApp webhook to integrate the router (minimal changes for backward compatibility):

1. **Add imports at top**:
   ```typescript
   import { UnifiedMessageRouter, ChannelType } from '@/lib/channels'
   import { createWhatsAppAdapter } from '@/lib/channels/adapters'
   import { findOrCreateContact, normalizePhoneNumber } from '@/lib/channels/contact-dedup'
   ```

2. **Add router initialization** (lazy singleton pattern):
   ```typescript
   let routerInstance: UnifiedMessageRouter | null = null

   async function getRouter(): Promise<UnifiedMessageRouter> {
     if (!routerInstance) {
       routerInstance = new UnifiedMessageRouter({ enableHealthChecks: false })
     }
     return routerInstance
   }

   async function getOrRegisterAdapter(organizationId: string): Promise<void> {
     const router = await getRouter()
     if (!router.getAdapter(ChannelType.WHATSAPP)) {
       try {
         const adapter = await createWhatsAppAdapter(organizationId)
         router.registerAdapter(adapter)
       } catch (error) {
         console.error('Failed to create WhatsApp adapter:', error)
       }
     }
   }
   ```

3. **Update processMessages function** to use router for receiving:
   In the processMessages function, after finding the organization:
   ```typescript
   async function processMessages(value: WhatsAppWebhookValue) {
     // ... existing organization lookup ...

     // Register adapter if not already done
     await getOrRegisterAdapter(organization.id)

     // Process incoming messages
     if (value.messages) {
       for (const message of value.messages) {
         await processIncomingMessage(message, organization.id, value.contacts?.[0])
       }
     }
     // ... rest unchanged ...
   }
   ```

4. **Update processIncomingMessage** to use contact deduplication:
   Replace the upsertContact call with:
   ```typescript
   async function processIncomingMessage(
     message: WhatsAppMessage,
     organizationId: string,
     contact?: WhatsAppContact
   ) {
     const supabase = await createClient()

     try {
       // Use new contact deduplication
       const { contactId, isNew } = await findOrCreateContact(
         supabase,
         organizationId,
         ChannelType.WHATSAPP,
         message.from,
         {
           name: contact?.profile?.name || undefined,
           metadata: { whatsappId: message.from }
         }
       )

       if (isNew) {
         console.log('Created new contact:', contactId)
       }

       // ... rest of function continues with existing logic ...
       // Use contactId instead of contactData.id
     }
   }
   ```

5. **Keep existing message storage logic** - don't change the messages table writes yet.
   The new channel_messages table will be populated in a future backfill.
   This maintains backward compatibility.

6. **Add logging** for router activity:
   ```typescript
   // After receiving message through router
   console.log(`[Channel Router] Received ${ChannelType.WHATSAPP} message from ${message.from}`)
   ```

Important: Keep all existing functionality intact. The router integration is additive, not replacing existing storage.
  </action>
  <verify>
Run: `npm run build` to verify webhook compiles.
Run: `npm run lint` to check for issues.
The webhook should still handle messages exactly as before, with added contact deduplication.
  </verify>
  <done>
src/app/api/webhooks/whatsapp/route.ts updated to use UnifiedMessageRouter and contact deduplication while maintaining backward compatibility.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. src/lib/channels/adapters/index.ts provides factory functions
2. src/lib/channels/contact-dedup.ts handles E.164 normalization
3. Webhook uses router for adapter management
4. `npm run build` passes
5. `npm run lint` passes
6. Existing message flow unchanged (backward compatible)
</verification>

<success_criteria>
- Webhook integrates UnifiedMessageRouter
- Contact deduplication normalizes phone numbers
- Adapter factory creates WhatsAppAdapter correctly
- All existing webhook behavior preserved
- Build and lint pass without errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-foundation-layer/08-04-SUMMARY.md`
</output>
