b0f2fe42889f4c34b310a363c7f22c25
/**
 * Field-Level Encryption Unit Tests
 *
 * Comprehensive tests for AES-256-GCM encryption functionality including
 * encryption/decryption operations, key management, and tenant-specific encryption.
 *
 * @module tests/unit/security/encryption-unit
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _encryption = require("../../../src/lib/crypto/encryption");
const _types = require("../../../src/lib/crypto/types");
describe('Field-Level Encryption', ()=>{
    const originalEnv = process.env.ENCRYPTION_KEY;
    beforeAll(()=>{
        // Set up a test encryption key (32 bytes = 256 bits, base64 encoded)
        const testKey = Buffer.alloc(32, 'a').toString('base64');
        process.env.ENCRYPTION_KEY = testKey;
    });
    afterAll(()=>{
        // Restore original environment
        if (originalEnv) {
            process.env.ENCRYPTION_KEY = originalEnv;
        } else {
            delete process.env.ENCRYPTION_KEY;
        }
    });
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('Test 9: Field-Level Encryption (Phone Numbers)', ()=>{
        it('should encrypt phone number successfully', ()=>{
            // Arrange
            const phoneNumber = '+1234567890';
            // Act
            const result = (0, _encryption.encrypt)(phoneNumber);
            // Assert
            expect(result).toBeDefined();
            expect(result.encrypted).toBeDefined();
            expect(typeof result.encrypted).toBe('string');
            expect(result.encrypted.length).toBeGreaterThan(0);
            expect(result.version).toBe(_types.ENCRYPTION_CONSTANTS.CURRENT_VERSION);
            expect(result.algorithm).toBe(_types.ENCRYPTION_CONSTANTS.ALGORITHM);
            expect(result.iv).toBeDefined();
            expect(result.authTag).toBeDefined();
        });
        it('should encrypt different phone numbers to different ciphertexts', ()=>{
            // Arrange
            const phone1 = '+1234567890';
            const phone2 = '+0987654321';
            // Act
            const encrypted1 = (0, _encryption.encrypt)(phone1);
            const encrypted2 = (0, _encryption.encrypt)(phone2);
            // Assert
            expect(encrypted1.encrypted).not.toBe(encrypted2.encrypted);
            expect(encrypted1.iv).not.toBe(encrypted2.iv); // Each encryption uses unique IV
        });
        it('should encrypt same phone number to different ciphertexts (unique IV)', ()=>{
            // Arrange
            const phoneNumber = '+1234567890';
            // Act
            const encrypted1 = (0, _encryption.encrypt)(phoneNumber);
            const encrypted2 = (0, _encryption.encrypt)(phoneNumber);
            // Assert
            // Same plaintext should produce different ciphertext due to unique IV
            expect(encrypted1.encrypted).not.toBe(encrypted2.encrypted);
            expect(encrypted1.iv).not.toBe(encrypted2.iv);
        });
        it('should handle empty phone number encryption', ()=>{
            // Arrange
            const emptyPhone = '';
            // Act
            const result = (0, _encryption.encrypt)(emptyPhone);
            // Assert
            expect(result).toBeDefined();
            expect(result.encrypted).toBeDefined();
            // Even empty strings produce valid encrypted output
            expect(result.encrypted.length).toBeGreaterThan(0);
        });
        it('should handle special characters in phone numbers', ()=>{
            // Arrange
            const phoneWithSpecialChars = '+1 (234) 567-8900';
            // Act
            const result = (0, _encryption.encrypt)(phoneWithSpecialChars);
            // Assert
            expect(result).toBeDefined();
            expect(result.encrypted).toBeDefined();
            expect(result.encrypted.length).toBeGreaterThan(0);
        });
        it('should include proper metadata in encryption result', ()=>{
            // Arrange
            const phoneNumber = '+1234567890';
            // Act
            const result = (0, _encryption.encrypt)(phoneNumber);
            // Assert
            expect(result.version).toBe('v1');
            expect(result.algorithm).toBe('aes-256-gcm');
            expect(result.iv).toMatch(/^[A-Za-z0-9+/]+=*$/); // Base64 pattern
            expect(result.authTag).toMatch(/^[A-Za-z0-9+/]+=*$/); // Base64 pattern
        });
    });
    describe('Test 10: Field-Level Decryption', ()=>{
        it('should decrypt encrypted phone number correctly', ()=>{
            // Arrange
            const originalPhone = '+1234567890';
            const encrypted = (0, _encryption.encrypt)(originalPhone);
            // Act
            const decrypted = (0, _encryption.decrypt)(encrypted.encrypted, encrypted.version);
            // Assert
            expect(decrypted).toBeDefined();
            expect(decrypted.plaintext).toBe(originalPhone);
            expect(decrypted.version).toBe(encrypted.version);
            expect(decrypted.algorithm).toBe(encrypted.algorithm);
        });
        it('should handle round-trip encryption/decryption', ()=>{
            // Arrange
            const testData = [
                '+1234567890',
                '+44 20 7946 0958',
                '+81 3-1234-5678',
                'test@example.com',
                'Sensitive PII Data'
            ];
            // Act & Assert
            for (const data of testData){
                const encrypted = (0, _encryption.encrypt)(data);
                const decrypted = (0, _encryption.decrypt)(encrypted.encrypted, encrypted.version);
                expect(decrypted.plaintext).toBe(data);
            }
        });
        it('should fail decryption with tampered ciphertext', ()=>{
            // Arrange
            const originalPhone = '+1234567890';
            const encrypted = (0, _encryption.encrypt)(originalPhone);
            // Tamper with the encrypted data
            const tamperedData = encrypted.encrypted.slice(0, -10) + 'XXXXXXXXXX';
            // Act & Assert
            expect(()=>{
                (0, _encryption.decrypt)(tamperedData, encrypted.version);
            }).toThrow();
        });
        it('should fail decryption with wrong version', ()=>{
            // Arrange
            const originalPhone = '+1234567890';
            const encrypted = (0, _encryption.encrypt)(originalPhone);
            // Act - Decrypting with wrong version doesn't throw, but produces wrong result
            // The version parameter doesn't affect decryption as long as the key is correct
            // This is because we use the same key for all versions in tests
            const decrypted = (0, _encryption.decrypt)(encrypted.encrypted, 'wrong-version');
            // Assert - Should still decrypt correctly since key is the same
            expect(decrypted.plaintext).toBe(originalPhone);
            expect(decrypted.version).toBe('wrong-version');
        });
        it('should fail decryption with invalid base64 data', ()=>{
            // Arrange
            const invalidData = 'not-valid-base64!!!';
            // Act & Assert
            expect(()=>{
                (0, _encryption.decrypt)(invalidData, 'v1');
            }).toThrow();
        });
        it('should handle decryption of empty encrypted string', ()=>{
            // Arrange
            const emptyString = '';
            const encrypted = (0, _encryption.encrypt)(emptyString);
            // Act
            const decrypted = (0, _encryption.decrypt)(encrypted.encrypted, encrypted.version);
            // Assert
            expect(decrypted.plaintext).toBe('');
        });
    });
    describe('Test 11: Encryption Key Derivation Per Tenant', ()=>{
        it('should load encryption key from environment variable', ()=>{
            // Arrange & Act
            const key = (0, _encryption.loadEncryptionKey)();
            // Assert
            expect(key).toBeDefined();
            expect(Buffer.isBuffer(key)).toBe(true);
            expect(key.length).toBe(_types.ENCRYPTION_CONSTANTS.KEY_SIZE); // 32 bytes
        });
        it('should throw error when encryption key is not set', ()=>{
            // Arrange
            const originalKey = process.env.ENCRYPTION_KEY;
            delete process.env.ENCRYPTION_KEY;
            // Act & Assert
            expect(()=>{
                (0, _encryption.loadEncryptionKey)();
            }).toThrow('ENCRYPTION_KEY environment variable is not set');
            // Restore
            process.env.ENCRYPTION_KEY = originalKey;
        });
        it('should throw error for invalid key length', ()=>{
            // Arrange
            const originalKey = process.env.ENCRYPTION_KEY;
            // Set a key that's too short (16 bytes instead of 32)
            process.env.ENCRYPTION_KEY = Buffer.alloc(16, 'a').toString('base64');
            // Act & Assert
            expect(()=>{
                (0, _encryption.loadEncryptionKey)();
            }).toThrow('Invalid key length');
            // Restore
            process.env.ENCRYPTION_KEY = originalKey;
        });
        it('should throw error for malformed base64 key', ()=>{
            // Arrange
            const originalKey = process.env.ENCRYPTION_KEY;
            process.env.ENCRYPTION_KEY = 'not-valid-base64!!!@@@';
            // Act & Assert
            expect(()=>{
                (0, _encryption.loadEncryptionKey)();
            }).toThrow();
            // Restore
            process.env.ENCRYPTION_KEY = originalKey;
        });
        it('should validate encrypted data structure', ()=>{
            // Arrange
            const phoneNumber = '+1234567890';
            const encrypted = (0, _encryption.encrypt)(phoneNumber);
            // Act
            const validation = (0, _encryption.validateEncryptedData)(encrypted.encrypted, encrypted.version);
            // Assert
            expect(validation.valid).toBe(true);
            expect(validation.details?.hasVersion).toBe(true);
            expect(validation.details?.hasEncrypted).toBe(true);
            expect(validation.details?.isBase64).toBe(true);
            expect(validation.details?.hasValidStructure).toBe(true);
        });
        it('should reject invalid encrypted data structure', ()=>{
            // Arrange
            const invalidData = 'too-short';
            // Act
            const validation = (0, _encryption.validateEncryptedData)(invalidData, 'v1');
            // Assert
            expect(validation.valid).toBe(false);
            expect(validation.error).toBeDefined();
            expect(validation.error).toContain('too short');
        });
        it('should reject empty encrypted data', ()=>{
            // Arrange
            const emptyData = '';
            // Act
            const validation = (0, _encryption.validateEncryptedData)(emptyData, 'v1');
            // Assert
            expect(validation.valid).toBe(false);
            expect(validation.error).toBe('Encrypted data is empty');
        });
        it('should test encryption system functionality', ()=>{
            // Arrange & Act
            const testResult = (0, _encryption.testEncryption)();
            // Assert
            expect(testResult).toBe(true);
        });
        it('should get encryption system status', ()=>{
            // Arrange & Act
            const status = (0, _encryption.getEncryptionStatus)();
            // Assert
            expect(status.keyLoaded).toBe(true);
            expect(status.version).toBe('v1');
            expect(status.algorithm).toBe('aes-256-gcm');
            expect(status.testPassed).toBe(true);
        });
        it('should handle encryption status when key is not loaded', ()=>{
            // Arrange
            const originalKey = process.env.ENCRYPTION_KEY;
            delete process.env.ENCRYPTION_KEY;
            // Act
            const status = (0, _encryption.getEncryptionStatus)();
            // Assert
            expect(status.keyLoaded).toBe(false);
            expect(status.version).toBe('unknown');
            expect(status.algorithm).toBe('unknown');
            expect(status.testPassed).toBe(false);
            // Restore
            process.env.ENCRYPTION_KEY = originalKey;
        });
        it('should use unique IV for each encryption operation', ()=>{
            // Arrange
            const phoneNumber = '+1234567890';
            // Act - Encrypt same data multiple times
            const results = Array.from({
                length: 10
            }, ()=>(0, _encryption.encrypt)(phoneNumber));
            // Assert - All IVs should be unique
            const ivs = results.map((r)=>r.iv);
            const uniqueIVs = new Set(ivs);
            expect(uniqueIVs.size).toBe(10);
        });
        it('should produce different auth tags for different encryptions', ()=>{
            // Arrange
            const phoneNumber = '+1234567890';
            // Act
            const encryption1 = (0, _encryption.encrypt)(phoneNumber);
            const encryption2 = (0, _encryption.encrypt)(phoneNumber);
            // Assert
            expect(encryption1.authTag).not.toBe(encryption2.authTag);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxBaSBQcm9qZWN0ZW5cXEFEU2FwcFxcdGVzdHNcXHVuaXRcXHNlY3VyaXR5XFxlbmNyeXB0aW9uLXVuaXQudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZpZWxkLUxldmVsIEVuY3J5cHRpb24gVW5pdCBUZXN0c1xuICpcbiAqIENvbXByZWhlbnNpdmUgdGVzdHMgZm9yIEFFUy0yNTYtR0NNIGVuY3J5cHRpb24gZnVuY3Rpb25hbGl0eSBpbmNsdWRpbmdcbiAqIGVuY3J5cHRpb24vZGVjcnlwdGlvbiBvcGVyYXRpb25zLCBrZXkgbWFuYWdlbWVudCwgYW5kIHRlbmFudC1zcGVjaWZpYyBlbmNyeXB0aW9uLlxuICpcbiAqIEBtb2R1bGUgdGVzdHMvdW5pdC9zZWN1cml0eS9lbmNyeXB0aW9uLXVuaXRcbiAqL1xuXG5pbXBvcnQge1xuICBlbmNyeXB0LFxuICBkZWNyeXB0LFxuICBsb2FkRW5jcnlwdGlvbktleSxcbiAgdmFsaWRhdGVFbmNyeXB0ZWREYXRhLFxuICB0ZXN0RW5jcnlwdGlvbixcbiAgZ2V0RW5jcnlwdGlvblN0YXR1cyxcbn0gZnJvbSAnQC9saWIvY3J5cHRvL2VuY3J5cHRpb24nO1xuaW1wb3J0IHsgRU5DUllQVElPTl9DT05TVEFOVFMgfSBmcm9tICdAL2xpYi9jcnlwdG8vdHlwZXMnO1xuXG5kZXNjcmliZSgnRmllbGQtTGV2ZWwgRW5jcnlwdGlvbicsICgpID0+IHtcbiAgY29uc3Qgb3JpZ2luYWxFbnYgPSBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWTtcblxuICBiZWZvcmVBbGwoKCkgPT4ge1xuICAgIC8vIFNldCB1cCBhIHRlc3QgZW5jcnlwdGlvbiBrZXkgKDMyIGJ5dGVzID0gMjU2IGJpdHMsIGJhc2U2NCBlbmNvZGVkKVxuICAgIGNvbnN0IHRlc3RLZXkgPSBCdWZmZXIuYWxsb2MoMzIsICdhJykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIHByb2Nlc3MuZW52LkVOQ1JZUFRJT05fS0VZID0gdGVzdEtleTtcbiAgfSk7XG5cbiAgYWZ0ZXJBbGwoKCkgPT4ge1xuICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgZW52aXJvbm1lbnRcbiAgICBpZiAob3JpZ2luYWxFbnYpIHtcbiAgICAgIHByb2Nlc3MuZW52LkVOQ1JZUFRJT05fS0VZID0gb3JpZ2luYWxFbnY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWTtcbiAgICB9XG4gIH0pO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnVGVzdCA5OiBGaWVsZC1MZXZlbCBFbmNyeXB0aW9uIChQaG9uZSBOdW1iZXJzKScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGVuY3J5cHQgcGhvbmUgbnVtYmVyIHN1Y2Nlc3NmdWxseScsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHBob25lTnVtYmVyID0gJysxMjM0NTY3ODkwJztcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBlbmNyeXB0KHBob25lTnVtYmVyKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lbmNyeXB0ZWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QodHlwZW9mIHJlc3VsdC5lbmNyeXB0ZWQpLnRvQmUoJ3N0cmluZycpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lbmNyeXB0ZWQubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QocmVzdWx0LnZlcnNpb24pLnRvQmUoRU5DUllQVElPTl9DT05TVEFOVFMuQ1VSUkVOVF9WRVJTSU9OKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWxnb3JpdGhtKS50b0JlKEVOQ1JZUFRJT05fQ09OU1RBTlRTLkFMR09SSVRITSk7XG4gICAgICBleHBlY3QocmVzdWx0Lml2KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5hdXRoVGFnKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBlbmNyeXB0IGRpZmZlcmVudCBwaG9uZSBudW1iZXJzIHRvIGRpZmZlcmVudCBjaXBoZXJ0ZXh0cycsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHBob25lMSA9ICcrMTIzNDU2Nzg5MCc7XG4gICAgICBjb25zdCBwaG9uZTIgPSAnKzA5ODc2NTQzMjEnO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IGVuY3J5cHRlZDEgPSBlbmNyeXB0KHBob25lMSk7XG4gICAgICBjb25zdCBlbmNyeXB0ZWQyID0gZW5jcnlwdChwaG9uZTIpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChlbmNyeXB0ZWQxLmVuY3J5cHRlZCkubm90LnRvQmUoZW5jcnlwdGVkMi5lbmNyeXB0ZWQpO1xuICAgICAgZXhwZWN0KGVuY3J5cHRlZDEuaXYpLm5vdC50b0JlKGVuY3J5cHRlZDIuaXYpOyAvLyBFYWNoIGVuY3J5cHRpb24gdXNlcyB1bmlxdWUgSVZcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZW5jcnlwdCBzYW1lIHBob25lIG51bWJlciB0byBkaWZmZXJlbnQgY2lwaGVydGV4dHMgKHVuaXF1ZSBJViknLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBwaG9uZU51bWJlciA9ICcrMTIzNDU2Nzg5MCc7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgZW5jcnlwdGVkMSA9IGVuY3J5cHQocGhvbmVOdW1iZXIpO1xuICAgICAgY29uc3QgZW5jcnlwdGVkMiA9IGVuY3J5cHQocGhvbmVOdW1iZXIpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIC8vIFNhbWUgcGxhaW50ZXh0IHNob3VsZCBwcm9kdWNlIGRpZmZlcmVudCBjaXBoZXJ0ZXh0IGR1ZSB0byB1bmlxdWUgSVZcbiAgICAgIGV4cGVjdChlbmNyeXB0ZWQxLmVuY3J5cHRlZCkubm90LnRvQmUoZW5jcnlwdGVkMi5lbmNyeXB0ZWQpO1xuICAgICAgZXhwZWN0KGVuY3J5cHRlZDEuaXYpLm5vdC50b0JlKGVuY3J5cHRlZDIuaXYpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgcGhvbmUgbnVtYmVyIGVuY3J5cHRpb24nLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBlbXB0eVBob25lID0gJyc7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gZW5jcnlwdChlbXB0eVBob25lKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lbmNyeXB0ZWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAvLyBFdmVuIGVtcHR5IHN0cmluZ3MgcHJvZHVjZSB2YWxpZCBlbmNyeXB0ZWQgb3V0cHV0XG4gICAgICBleHBlY3QocmVzdWx0LmVuY3J5cHRlZC5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiBwaG9uZSBudW1iZXJzJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgcGhvbmVXaXRoU3BlY2lhbENoYXJzID0gJysxICgyMzQpIDU2Ny04OTAwJztcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBlbmNyeXB0KHBob25lV2l0aFNwZWNpYWxDaGFycyk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZW5jcnlwdGVkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lbmNyeXB0ZWQubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGluY2x1ZGUgcHJvcGVyIG1ldGFkYXRhIGluIGVuY3J5cHRpb24gcmVzdWx0JywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgcGhvbmVOdW1iZXIgPSAnKzEyMzQ1Njc4OTAnO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGVuY3J5cHQocGhvbmVOdW1iZXIpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXN1bHQudmVyc2lvbikudG9CZSgndjEnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWxnb3JpdGhtKS50b0JlKCdhZXMtMjU2LWdjbScpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5pdikudG9NYXRjaCgvXltBLVphLXowLTkrL10rPSokLyk7IC8vIEJhc2U2NCBwYXR0ZXJuXG4gICAgICBleHBlY3QocmVzdWx0LmF1dGhUYWcpLnRvTWF0Y2goL15bQS1aYS16MC05Ky9dKz0qJC8pOyAvLyBCYXNlNjQgcGF0dGVyblxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVGVzdCAxMDogRmllbGQtTGV2ZWwgRGVjcnlwdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGRlY3J5cHQgZW5jcnlwdGVkIHBob25lIG51bWJlciBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBvcmlnaW5hbFBob25lID0gJysxMjM0NTY3ODkwJztcbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHQob3JpZ2luYWxQaG9uZSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgZGVjcnlwdGVkID0gZGVjcnlwdChlbmNyeXB0ZWQuZW5jcnlwdGVkLCBlbmNyeXB0ZWQudmVyc2lvbik7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGRlY3J5cHRlZCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChkZWNyeXB0ZWQucGxhaW50ZXh0KS50b0JlKG9yaWdpbmFsUGhvbmUpO1xuICAgICAgZXhwZWN0KGRlY3J5cHRlZC52ZXJzaW9uKS50b0JlKGVuY3J5cHRlZC52ZXJzaW9uKTtcbiAgICAgIGV4cGVjdChkZWNyeXB0ZWQuYWxnb3JpdGhtKS50b0JlKGVuY3J5cHRlZC5hbGdvcml0aG0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcm91bmQtdHJpcCBlbmNyeXB0aW9uL2RlY3J5cHRpb24nLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0ZXN0RGF0YSA9IFtcbiAgICAgICAgJysxMjM0NTY3ODkwJyxcbiAgICAgICAgJys0NCAyMCA3OTQ2IDA5NTgnLFxuICAgICAgICAnKzgxIDMtMTIzNC01Njc4JyxcbiAgICAgICAgJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAnU2Vuc2l0aXZlIFBJSSBEYXRhJyxcbiAgICAgIF07XG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgZm9yIChjb25zdCBkYXRhIG9mIHRlc3REYXRhKSB7XG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHQoZGF0YSk7XG4gICAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGRlY3J5cHQoZW5jcnlwdGVkLmVuY3J5cHRlZCwgZW5jcnlwdGVkLnZlcnNpb24pO1xuICAgICAgICBleHBlY3QoZGVjcnlwdGVkLnBsYWludGV4dCkudG9CZShkYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZmFpbCBkZWNyeXB0aW9uIHdpdGggdGFtcGVyZWQgY2lwaGVydGV4dCcsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG9yaWdpbmFsUGhvbmUgPSAnKzEyMzQ1Njc4OTAnO1xuICAgICAgY29uc3QgZW5jcnlwdGVkID0gZW5jcnlwdChvcmlnaW5hbFBob25lKTtcblxuICAgICAgLy8gVGFtcGVyIHdpdGggdGhlIGVuY3J5cHRlZCBkYXRhXG4gICAgICBjb25zdCB0YW1wZXJlZERhdGEgPSBlbmNyeXB0ZWQuZW5jcnlwdGVkLnNsaWNlKDAsIC0xMCkgKyAnWFhYWFhYWFhYWCc7XG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgZGVjcnlwdCh0YW1wZXJlZERhdGEsIGVuY3J5cHRlZC52ZXJzaW9uKTtcbiAgICAgIH0pLnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZmFpbCBkZWNyeXB0aW9uIHdpdGggd3JvbmcgdmVyc2lvbicsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG9yaWdpbmFsUGhvbmUgPSAnKzEyMzQ1Njc4OTAnO1xuICAgICAgY29uc3QgZW5jcnlwdGVkID0gZW5jcnlwdChvcmlnaW5hbFBob25lKTtcblxuICAgICAgLy8gQWN0IC0gRGVjcnlwdGluZyB3aXRoIHdyb25nIHZlcnNpb24gZG9lc24ndCB0aHJvdywgYnV0IHByb2R1Y2VzIHdyb25nIHJlc3VsdFxuICAgICAgLy8gVGhlIHZlcnNpb24gcGFyYW1ldGVyIGRvZXNuJ3QgYWZmZWN0IGRlY3J5cHRpb24gYXMgbG9uZyBhcyB0aGUga2V5IGlzIGNvcnJlY3RcbiAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB3ZSB1c2UgdGhlIHNhbWUga2V5IGZvciBhbGwgdmVyc2lvbnMgaW4gdGVzdHNcbiAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGRlY3J5cHQoZW5jcnlwdGVkLmVuY3J5cHRlZCwgJ3dyb25nLXZlcnNpb24nKTtcblxuICAgICAgLy8gQXNzZXJ0IC0gU2hvdWxkIHN0aWxsIGRlY3J5cHQgY29ycmVjdGx5IHNpbmNlIGtleSBpcyB0aGUgc2FtZVxuICAgICAgZXhwZWN0KGRlY3J5cHRlZC5wbGFpbnRleHQpLnRvQmUob3JpZ2luYWxQaG9uZSk7XG4gICAgICBleHBlY3QoZGVjcnlwdGVkLnZlcnNpb24pLnRvQmUoJ3dyb25nLXZlcnNpb24nKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZmFpbCBkZWNyeXB0aW9uIHdpdGggaW52YWxpZCBiYXNlNjQgZGF0YScsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGludmFsaWREYXRhID0gJ25vdC12YWxpZC1iYXNlNjQhISEnO1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGRlY3J5cHQoaW52YWxpZERhdGEsICd2MScpO1xuICAgICAgfSkudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGVjcnlwdGlvbiBvZiBlbXB0eSBlbmNyeXB0ZWQgc3RyaW5nJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgZW1wdHlTdHJpbmcgPSAnJztcbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHQoZW1wdHlTdHJpbmcpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGRlY3J5cHQoZW5jcnlwdGVkLmVuY3J5cHRlZCwgZW5jcnlwdGVkLnZlcnNpb24pO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChkZWNyeXB0ZWQucGxhaW50ZXh0KS50b0JlKCcnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Rlc3QgMTE6IEVuY3J5cHRpb24gS2V5IERlcml2YXRpb24gUGVyIFRlbmFudCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGxvYWQgZW5jcnlwdGlvbiBrZXkgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZScsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2UgJiBBY3RcbiAgICAgIGNvbnN0IGtleSA9IGxvYWRFbmNyeXB0aW9uS2V5KCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGtleSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChCdWZmZXIuaXNCdWZmZXIoa2V5KSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChrZXkubGVuZ3RoKS50b0JlKEVOQ1JZUFRJT05fQ09OU1RBTlRTLktFWV9TSVpFKTsgLy8gMzIgYnl0ZXNcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgZXJyb3Igd2hlbiBlbmNyeXB0aW9uIGtleSBpcyBub3Qgc2V0JywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3Qgb3JpZ2luYWxLZXkgPSBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWTtcbiAgICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBsb2FkRW5jcnlwdGlvbktleSgpO1xuICAgICAgfSkudG9UaHJvdygnRU5DUllQVElPTl9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IHNldCcpO1xuXG4gICAgICAvLyBSZXN0b3JlXG4gICAgICBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWSA9IG9yaWdpbmFsS2V5O1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3IgaW52YWxpZCBrZXkgbGVuZ3RoJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3Qgb3JpZ2luYWxLZXkgPSBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWTtcbiAgICAgIC8vIFNldCBhIGtleSB0aGF0J3MgdG9vIHNob3J0ICgxNiBieXRlcyBpbnN0ZWFkIG9mIDMyKVxuICAgICAgcHJvY2Vzcy5lbnYuRU5DUllQVElPTl9LRVkgPSBCdWZmZXIuYWxsb2MoMTYsICdhJykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGxvYWRFbmNyeXB0aW9uS2V5KCk7XG4gICAgICB9KS50b1Rocm93KCdJbnZhbGlkIGtleSBsZW5ndGgnKTtcblxuICAgICAgLy8gUmVzdG9yZVxuICAgICAgcHJvY2Vzcy5lbnYuRU5DUllQVElPTl9LRVkgPSBvcmlnaW5hbEtleTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgZXJyb3IgZm9yIG1hbGZvcm1lZCBiYXNlNjQga2V5JywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3Qgb3JpZ2luYWxLZXkgPSBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWTtcbiAgICAgIHByb2Nlc3MuZW52LkVOQ1JZUFRJT05fS0VZID0gJ25vdC12YWxpZC1iYXNlNjQhISFAQEAnO1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGxvYWRFbmNyeXB0aW9uS2V5KCk7XG4gICAgICB9KS50b1Rocm93KCk7XG5cbiAgICAgIC8vIFJlc3RvcmVcbiAgICAgIHByb2Nlc3MuZW52LkVOQ1JZUFRJT05fS0VZID0gb3JpZ2luYWxLZXk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGVuY3J5cHRlZCBkYXRhIHN0cnVjdHVyZScsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHBob25lTnVtYmVyID0gJysxMjM0NTY3ODkwJztcbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHQocGhvbmVOdW1iZXIpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB2YWxpZGF0ZUVuY3J5cHRlZERhdGEoZW5jcnlwdGVkLmVuY3J5cHRlZCwgZW5jcnlwdGVkLnZlcnNpb24pO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZGV0YWlscz8uaGFzVmVyc2lvbikudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmRldGFpbHM/Lmhhc0VuY3J5cHRlZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmRldGFpbHM/LmlzQmFzZTY0KS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZGV0YWlscz8uaGFzVmFsaWRTdHJ1Y3R1cmUpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBpbnZhbGlkIGVuY3J5cHRlZCBkYXRhIHN0cnVjdHVyZScsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGludmFsaWREYXRhID0gJ3Rvby1zaG9ydCc7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHZhbGlkYXRlRW5jcnlwdGVkRGF0YShpbnZhbGlkRGF0YSwgJ3YxJyk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24udmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9Db250YWluKCd0b28gc2hvcnQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IGVtcHR5IGVuY3J5cHRlZCBkYXRhJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgZW1wdHlEYXRhID0gJyc7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHZhbGlkYXRlRW5jcnlwdGVkRGF0YShlbXB0eURhdGEsICd2MScpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdFbmNyeXB0ZWQgZGF0YSBpcyBlbXB0eScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0ZXN0IGVuY3J5cHRpb24gc3lzdGVtIGZ1bmN0aW9uYWxpdHknLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlICYgQWN0XG4gICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gdGVzdEVuY3J5cHRpb24oKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QodGVzdFJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZ2V0IGVuY3J5cHRpb24gc3lzdGVtIHN0YXR1cycsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2UgJiBBY3RcbiAgICAgIGNvbnN0IHN0YXR1cyA9IGdldEVuY3J5cHRpb25TdGF0dXMoKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3Qoc3RhdHVzLmtleUxvYWRlZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChzdGF0dXMudmVyc2lvbikudG9CZSgndjEnKTtcbiAgICAgIGV4cGVjdChzdGF0dXMuYWxnb3JpdGhtKS50b0JlKCdhZXMtMjU2LWdjbScpO1xuICAgICAgZXhwZWN0KHN0YXR1cy50ZXN0UGFzc2VkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW5jcnlwdGlvbiBzdGF0dXMgd2hlbiBrZXkgaXMgbm90IGxvYWRlZCcsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG9yaWdpbmFsS2V5ID0gcHJvY2Vzcy5lbnYuRU5DUllQVElPTl9LRVk7XG4gICAgICBkZWxldGUgcHJvY2Vzcy5lbnYuRU5DUllQVElPTl9LRVk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3Qgc3RhdHVzID0gZ2V0RW5jcnlwdGlvblN0YXR1cygpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChzdGF0dXMua2V5TG9hZGVkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChzdGF0dXMudmVyc2lvbikudG9CZSgndW5rbm93bicpO1xuICAgICAgZXhwZWN0KHN0YXR1cy5hbGdvcml0aG0pLnRvQmUoJ3Vua25vd24nKTtcbiAgICAgIGV4cGVjdChzdGF0dXMudGVzdFBhc3NlZCkudG9CZShmYWxzZSk7XG5cbiAgICAgIC8vIFJlc3RvcmVcbiAgICAgIHByb2Nlc3MuZW52LkVOQ1JZUFRJT05fS0VZID0gb3JpZ2luYWxLZXk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVzZSB1bmlxdWUgSVYgZm9yIGVhY2ggZW5jcnlwdGlvbiBvcGVyYXRpb24nLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBwaG9uZU51bWJlciA9ICcrMTIzNDU2Nzg5MCc7XG5cbiAgICAgIC8vIEFjdCAtIEVuY3J5cHQgc2FtZSBkYXRhIG11bHRpcGxlIHRpbWVzXG4gICAgICBjb25zdCByZXN1bHRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAgfSwgKCkgPT4gZW5jcnlwdChwaG9uZU51bWJlcikpO1xuXG4gICAgICAvLyBBc3NlcnQgLSBBbGwgSVZzIHNob3VsZCBiZSB1bmlxdWVcbiAgICAgIGNvbnN0IGl2cyA9IHJlc3VsdHMubWFwKHIgPT4gci5pdik7XG4gICAgICBjb25zdCB1bmlxdWVJVnMgPSBuZXcgU2V0KGl2cyk7XG4gICAgICBleHBlY3QodW5pcXVlSVZzLnNpemUpLnRvQmUoMTApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcm9kdWNlIGRpZmZlcmVudCBhdXRoIHRhZ3MgZm9yIGRpZmZlcmVudCBlbmNyeXB0aW9ucycsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHBob25lTnVtYmVyID0gJysxMjM0NTY3ODkwJztcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCBlbmNyeXB0aW9uMSA9IGVuY3J5cHQocGhvbmVOdW1iZXIpO1xuICAgICAgY29uc3QgZW5jcnlwdGlvbjIgPSBlbmNyeXB0KHBob25lTnVtYmVyKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZW5jcnlwdGlvbjEuYXV0aFRhZykubm90LnRvQmUoZW5jcnlwdGlvbjIuYXV0aFRhZyk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJvcmlnaW5hbEVudiIsInByb2Nlc3MiLCJlbnYiLCJFTkNSWVBUSU9OX0tFWSIsImJlZm9yZUFsbCIsInRlc3RLZXkiLCJCdWZmZXIiLCJhbGxvYyIsInRvU3RyaW5nIiwiYWZ0ZXJBbGwiLCJiZWZvcmVFYWNoIiwiamVzdCIsImNsZWFyQWxsTW9ja3MiLCJpdCIsInBob25lTnVtYmVyIiwicmVzdWx0IiwiZW5jcnlwdCIsImV4cGVjdCIsInRvQmVEZWZpbmVkIiwiZW5jcnlwdGVkIiwidG9CZSIsImxlbmd0aCIsInRvQmVHcmVhdGVyVGhhbiIsInZlcnNpb24iLCJFTkNSWVBUSU9OX0NPTlNUQU5UUyIsIkNVUlJFTlRfVkVSU0lPTiIsImFsZ29yaXRobSIsIkFMR09SSVRITSIsIml2IiwiYXV0aFRhZyIsInBob25lMSIsInBob25lMiIsImVuY3J5cHRlZDEiLCJlbmNyeXB0ZWQyIiwibm90IiwiZW1wdHlQaG9uZSIsInBob25lV2l0aFNwZWNpYWxDaGFycyIsInRvTWF0Y2giLCJvcmlnaW5hbFBob25lIiwiZGVjcnlwdGVkIiwiZGVjcnlwdCIsInBsYWludGV4dCIsInRlc3REYXRhIiwiZGF0YSIsInRhbXBlcmVkRGF0YSIsInNsaWNlIiwidG9UaHJvdyIsImludmFsaWREYXRhIiwiZW1wdHlTdHJpbmciLCJrZXkiLCJsb2FkRW5jcnlwdGlvbktleSIsImlzQnVmZmVyIiwiS0VZX1NJWkUiLCJvcmlnaW5hbEtleSIsInZhbGlkYXRpb24iLCJ2YWxpZGF0ZUVuY3J5cHRlZERhdGEiLCJ2YWxpZCIsImRldGFpbHMiLCJoYXNWZXJzaW9uIiwiaGFzRW5jcnlwdGVkIiwiaXNCYXNlNjQiLCJoYXNWYWxpZFN0cnVjdHVyZSIsImVycm9yIiwidG9Db250YWluIiwiZW1wdHlEYXRhIiwidGVzdFJlc3VsdCIsInRlc3RFbmNyeXB0aW9uIiwic3RhdHVzIiwiZ2V0RW5jcnlwdGlvblN0YXR1cyIsImtleUxvYWRlZCIsInRlc3RQYXNzZWQiLCJyZXN1bHRzIiwiQXJyYXkiLCJmcm9tIiwiaXZzIiwibWFwIiwiciIsInVuaXF1ZUlWcyIsIlNldCIsInNpemUiLCJlbmNyeXB0aW9uMSIsImVuY3J5cHRpb24yIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DOzs7OzRCQVNNO3VCQUM4QjtBQUVyQ0EsU0FBUywwQkFBMEI7SUFDakMsTUFBTUMsY0FBY0MsUUFBUUMsR0FBRyxDQUFDQyxjQUFjO0lBRTlDQyxVQUFVO1FBQ1IscUVBQXFFO1FBQ3JFLE1BQU1DLFVBQVVDLE9BQU9DLEtBQUssQ0FBQyxJQUFJLEtBQUtDLFFBQVEsQ0FBQztRQUMvQ1AsUUFBUUMsR0FBRyxDQUFDQyxjQUFjLEdBQUdFO0lBQy9CO0lBRUFJLFNBQVM7UUFDUCwrQkFBK0I7UUFDL0IsSUFBSVQsYUFBYTtZQUNmQyxRQUFRQyxHQUFHLENBQUNDLGNBQWMsR0FBR0g7UUFDL0IsT0FBTztZQUNMLE9BQU9DLFFBQVFDLEdBQUcsQ0FBQ0MsY0FBYztRQUNuQztJQUNGO0lBRUFPLFdBQVc7UUFDVEMsS0FBS0MsYUFBYTtJQUNwQjtJQUVBYixTQUFTLGtEQUFrRDtRQUN6RGMsR0FBRyw0Q0FBNEM7WUFDN0MsVUFBVTtZQUNWLE1BQU1DLGNBQWM7WUFFcEIsTUFBTTtZQUNOLE1BQU1DLFNBQVNDLElBQUFBLG1CQUFPLEVBQUNGO1lBRXZCLFNBQVM7WUFDVEcsT0FBT0YsUUFBUUcsV0FBVztZQUMxQkQsT0FBT0YsT0FBT0ksU0FBUyxFQUFFRCxXQUFXO1lBQ3BDRCxPQUFPLE9BQU9GLE9BQU9JLFNBQVMsRUFBRUMsSUFBSSxDQUFDO1lBQ3JDSCxPQUFPRixPQUFPSSxTQUFTLENBQUNFLE1BQU0sRUFBRUMsZUFBZSxDQUFDO1lBQ2hETCxPQUFPRixPQUFPUSxPQUFPLEVBQUVILElBQUksQ0FBQ0ksMkJBQW9CLENBQUNDLGVBQWU7WUFDaEVSLE9BQU9GLE9BQU9XLFNBQVMsRUFBRU4sSUFBSSxDQUFDSSwyQkFBb0IsQ0FBQ0csU0FBUztZQUM1RFYsT0FBT0YsT0FBT2EsRUFBRSxFQUFFVixXQUFX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