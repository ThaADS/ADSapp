{"version":3,"sources":["C:\\Ai Projecten\\ADSapp\\src\\lib\\crypto\\encryption.ts"],"sourcesContent":["/**\n * Core Encryption Library\n *\n * Provides low-level AES-256-GCM encryption and decryption functions\n * for field-level encryption of sensitive PII data.\n *\n * Features:\n * - AES-256-GCM encryption with authentication\n * - Secure IV generation for each encryption\n * - Key derivation from environment variables\n * - Version support for key rotation\n * - Comprehensive error handling\n * - Audit logging capabilities\n *\n * @module crypto/encryption\n */\n\nimport * as crypto from 'crypto';\nimport {\n  EncryptionConfig,\n  EncryptionResult,\n  DecryptionResult,\n  EncryptionError,\n  DecryptionError,\n  KeyManagementError,\n  ENCRYPTION_CONSTANTS,\n  ValidationResult,\n} from './types';\n\n/**\n * Default encryption configuration\n */\nconst DEFAULT_CONFIG: Partial<EncryptionConfig> = {\n  algorithm: ENCRYPTION_CONSTANTS.ALGORITHM,\n  version: ENCRYPTION_CONSTANTS.CURRENT_VERSION,\n  ivLength: ENCRYPTION_CONSTANTS.IV_SIZE,\n  authTagLength: ENCRYPTION_CONSTANTS.AUTH_TAG_SIZE,\n};\n\n/**\n * Load encryption key from environment variable (legacy method)\n * For KMS-managed keys, use getKeyManager().getEncryptionKey() instead\n *\n * @deprecated Use KMS-managed keys via KeyManager for production\n * @throws {KeyManagementError} If ENCRYPTION_KEY is not set or invalid\n * @returns Master encryption key as Buffer\n */\nexport function loadEncryptionKey(): Buffer {\n  const keyBase64 = process.env.ENCRYPTION_KEY;\n\n  if (!keyBase64) {\n    throw new KeyManagementError(\n      'ENCRYPTION_KEY environment variable is not set',\n      'MISSING_KEY',\n      {\n        hint: 'For production, use AWS KMS-managed keys. For development, run: npm run generate-encryption-key',\n      }\n    );\n  }\n\n  try {\n    const key = Buffer.from(keyBase64, 'base64');\n\n    if (key.length !== ENCRYPTION_CONSTANTS.KEY_SIZE) {\n      throw new KeyManagementError(\n        `Invalid key length: expected ${ENCRYPTION_CONSTANTS.KEY_SIZE} bytes, got ${key.length}`,\n        'INVALID_KEY_LENGTH',\n        { expected: ENCRYPTION_CONSTANTS.KEY_SIZE, actual: key.length }\n      );\n    }\n\n    return key;\n  } catch (error) {\n    if (error instanceof KeyManagementError) {\n      throw error;\n    }\n\n    throw new KeyManagementError(\n      'Failed to decode encryption key from base64',\n      'INVALID_KEY_FORMAT',\n      { originalError: error }\n    );\n  }\n}\n\n/**\n * Load encryption key with KMS support\n * Automatically uses KMS-managed keys if AWS_KMS_KEY_ID is configured,\n * otherwise falls back to environment variable\n *\n * @param tenantId - Tenant identifier for KMS key retrieval\n * @returns Master encryption key as Buffer\n */\nexport async function loadEncryptionKeyWithKMS(tenantId?: string): Promise<Buffer> {\n  // Check if KMS is configured\n  const useKMS = !!process.env.AWS_KMS_KEY_ID;\n\n  if (useKMS && tenantId) {\n    // Use KMS-managed keys for production\n    try {\n      const { getKeyManager } = await import('@/lib/security/key-manager');\n      const keyManager = getKeyManager();\n      return await keyManager.getEncryptionKey(tenantId);\n    } catch (error) {\n      console.error('Failed to load KMS key, falling back to environment key:', error);\n      // Fall through to legacy method\n    }\n  }\n\n  // Fall back to environment variable (development/testing)\n  return loadEncryptionKey();\n}\n\n/**\n * Get encryption configuration with defaults\n *\n * @param customConfig - Optional custom configuration\n * @returns Complete encryption configuration\n */\nexport function getEncryptionConfig(\n  customConfig?: Partial<EncryptionConfig>\n): EncryptionConfig {\n  const key = loadEncryptionKey();\n\n  return {\n    key,\n    ...DEFAULT_CONFIG,\n    ...customConfig,\n  } as EncryptionConfig;\n}\n\n/**\n * Generate a cryptographically secure random IV\n *\n * @param length - IV length in bytes (default: 12 for GCM)\n * @returns Random IV as Buffer\n */\nexport function generateIV(length: number = ENCRYPTION_CONSTANTS.IV_SIZE): Buffer {\n  return crypto.randomBytes(length);\n}\n\n/**\n * Validate encryption configuration\n *\n * @param config - Configuration to validate\n * @throws {KeyManagementError} If configuration is invalid\n */\nfunction validateConfig(config: EncryptionConfig): void {\n  if (!config.key || config.key.length !== ENCRYPTION_CONSTANTS.KEY_SIZE) {\n    throw new KeyManagementError(\n      'Invalid encryption key',\n      'INVALID_KEY',\n      { keyLength: config.key?.length }\n    );\n  }\n\n  if (!config.version) {\n    throw new KeyManagementError(\n      'Version is required for key rotation support',\n      'MISSING_VERSION'\n    );\n  }\n\n  if (!config.algorithm) {\n    throw new KeyManagementError(\n      'Algorithm is required',\n      'MISSING_ALGORITHM'\n    );\n  }\n}\n\n/**\n * Encrypt plaintext using AES-256-GCM\n *\n * @param plaintext - Data to encrypt\n * @param config - Optional encryption configuration\n * @returns Encryption result with encrypted data and metadata\n * @throws {EncryptionError} If encryption fails\n *\n * @example\n * ```typescript\n * const result = encrypt('+1234567890');\n * console.log(result.encrypted); // Base64 encoded encrypted data\n * ```\n */\nexport function encrypt(\n  plaintext: string,\n  config?: Partial<EncryptionConfig>\n): EncryptionResult {\n  try {\n    const fullConfig = getEncryptionConfig(config);\n    validateConfig(fullConfig);\n\n    // Generate random IV for this encryption\n    const iv = generateIV(fullConfig.ivLength);\n\n    // Create cipher\n    const cipher = crypto.createCipheriv(\n      fullConfig.algorithm!,\n      fullConfig.key,\n      iv,\n      {\n        authTagLength: fullConfig.authTagLength,\n      }\n    );\n\n    // Encrypt the data\n    let encrypted = cipher.update(\n      plaintext,\n      ENCRYPTION_CONSTANTS.STRING_ENCODING,\n      ENCRYPTION_CONSTANTS.ENCODING\n    );\n    encrypted += cipher.final(ENCRYPTION_CONSTANTS.ENCODING);\n\n    // Get authentication tag\n    const authTag = cipher.getAuthTag();\n\n    // Combine IV + encrypted data + authTag for storage\n    const combined = Buffer.concat([\n      iv,\n      Buffer.from(encrypted, ENCRYPTION_CONSTANTS.ENCODING),\n      authTag,\n    ]);\n\n    const encryptedBase64 = combined.toString(ENCRYPTION_CONSTANTS.ENCODING);\n\n    return {\n      encrypted: encryptedBase64,\n      version: fullConfig.version,\n      algorithm: fullConfig.algorithm!,\n      iv: iv.toString(ENCRYPTION_CONSTANTS.ENCODING),\n      authTag: authTag.toString(ENCRYPTION_CONSTANTS.ENCODING),\n    };\n  } catch (error) {\n    // If it's already an encryption-related error, rethrow\n    if (\n      error instanceof EncryptionError ||\n      error instanceof KeyManagementError\n    ) {\n      throw error;\n    }\n\n    // Wrap other errors\n    throw new EncryptionError(\n      'Encryption failed',\n      'ENCRYPTION_FAILED',\n      {\n        originalError: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined,\n      }\n    );\n  }\n}\n\n/**\n * Decrypt data encrypted with AES-256-GCM\n *\n * @param encryptedData - Base64 encoded encrypted data (IV + ciphertext + authTag)\n * @param version - Key version used for encryption\n * @param config - Optional decryption configuration\n * @returns Decryption result with plaintext and metadata\n * @throws {DecryptionError} If decryption fails\n *\n * @example\n * ```typescript\n * const result = decrypt(encryptedData, 'v1');\n * console.log(result.plaintext); // Original plaintext\n * ```\n */\nexport function decrypt(\n  encryptedData: string,\n  version: string,\n  config?: Partial<EncryptionConfig>\n): DecryptionResult {\n  try {\n    const fullConfig = getEncryptionConfig({ ...config, version });\n    validateConfig(fullConfig);\n\n    // Decode the combined data\n    const combined = Buffer.from(encryptedData, ENCRYPTION_CONSTANTS.ENCODING);\n\n    // Extract components\n    const ivLength = fullConfig.ivLength || ENCRYPTION_CONSTANTS.IV_SIZE;\n    const authTagLength = fullConfig.authTagLength || ENCRYPTION_CONSTANTS.AUTH_TAG_SIZE;\n\n    if (combined.length < ivLength + authTagLength) {\n      throw new DecryptionError(\n        'Invalid encrypted data: too short',\n        'INVALID_DATA_LENGTH',\n        {\n          dataLength: combined.length,\n          minimumLength: ivLength + authTagLength,\n        }\n      );\n    }\n\n    const iv = combined.subarray(0, ivLength);\n    const authTag = combined.subarray(combined.length - authTagLength);\n    const ciphertext = combined.subarray(ivLength, combined.length - authTagLength);\n\n    // Create decipher\n    const decipher = crypto.createDecipheriv(\n      fullConfig.algorithm!,\n      fullConfig.key,\n      iv,\n      {\n        authTagLength,\n      }\n    );\n\n    // Set auth tag for verification\n    decipher.setAuthTag(authTag);\n\n    // Decrypt the data\n    let plaintext = decipher.update(\n      ciphertext,\n      undefined,\n      ENCRYPTION_CONSTANTS.STRING_ENCODING\n    );\n    plaintext += decipher.final(ENCRYPTION_CONSTANTS.STRING_ENCODING);\n\n    return {\n      plaintext,\n      version: fullConfig.version,\n      algorithm: fullConfig.algorithm!,\n    };\n  } catch (error) {\n    // If it's already a decryption-related error, rethrow\n    if (\n      error instanceof DecryptionError ||\n      error instanceof KeyManagementError\n    ) {\n      throw error;\n    }\n\n    // Authentication tag verification failure\n    if (error instanceof Error && error.message.includes('Unsupported state')) {\n      throw new DecryptionError(\n        'Authentication tag verification failed: data may be corrupted or tampered',\n        'AUTH_TAG_VERIFICATION_FAILED',\n        { originalError: error.message }\n      );\n    }\n\n    // Wrap other errors\n    throw new DecryptionError(\n      'Decryption failed',\n      'DECRYPTION_FAILED',\n      {\n        originalError: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined,\n      }\n    );\n  }\n}\n\n/**\n * Validate that encrypted data has the correct structure\n *\n * @param encryptedData - Data to validate\n * @param version - Expected version\n * @returns Validation result\n */\nexport function validateEncryptedData(\n  encryptedData: string,\n  version?: string\n): ValidationResult {\n  const result: ValidationResult = {\n    valid: true,\n    details: {\n      hasVersion: !!version,\n      hasEncrypted: !!encryptedData,\n      isBase64: false,\n      hasValidStructure: false,\n    },\n  };\n\n  // Check if data exists\n  if (!encryptedData) {\n    result.valid = false;\n    result.error = 'Encrypted data is empty';\n    return result;\n  }\n\n  // Check if it's valid base64\n  try {\n    const buffer = Buffer.from(encryptedData, ENCRYPTION_CONSTANTS.ENCODING);\n    result.details!.isBase64 = buffer.toString(ENCRYPTION_CONSTANTS.ENCODING) === encryptedData;\n\n    // Check minimum length (IV + at least 1 byte + authTag)\n    const minLength = ENCRYPTION_CONSTANTS.IV_SIZE + 1 + ENCRYPTION_CONSTANTS.AUTH_TAG_SIZE;\n    result.details!.hasValidStructure = buffer.length >= minLength;\n\n    if (!result.details!.hasValidStructure) {\n      result.valid = false;\n      result.error = `Data too short: expected at least ${minLength} bytes, got ${buffer.length}`;\n    }\n  } catch (error) {\n    result.valid = false;\n    result.error = 'Invalid base64 encoding';\n    result.details!.isBase64 = false;\n  }\n\n  return result;\n}\n\n/**\n * Encrypt multiple values in batch\n *\n * @param values - Array of plaintext values to encrypt\n * @param config - Optional encryption configuration\n * @returns Array of encryption results\n */\nexport function encryptBatch(\n  values: string[],\n  config?: Partial<EncryptionConfig>\n): EncryptionResult[] {\n  return values.map((value) => encrypt(value, config));\n}\n\n/**\n * Decrypt multiple values in batch\n *\n * @param encryptedValues - Array of encrypted values\n * @param version - Key version used for encryption\n * @param config - Optional decryption configuration\n * @returns Array of decryption results\n */\nexport function decryptBatch(\n  encryptedValues: Array<{ data: string; version: string }>,\n  config?: Partial<EncryptionConfig>\n): DecryptionResult[] {\n  return encryptedValues.map((item) => decrypt(item.data, item.version, config));\n}\n\n/**\n * Re-encrypt data with a new key version (for key rotation)\n *\n * @param encryptedData - Currently encrypted data\n * @param currentVersion - Current key version\n * @param newVersion - New key version to use\n * @param oldConfig - Configuration for old key\n * @param newConfig - Configuration for new key\n * @returns New encryption result\n * @throws {EncryptionError | DecryptionError} If re-encryption fails\n */\nexport function reEncrypt(\n  encryptedData: string,\n  currentVersion: string,\n  newVersion: string,\n  oldConfig?: Partial<EncryptionConfig>,\n  newConfig?: Partial<EncryptionConfig>\n): EncryptionResult {\n  // Decrypt with old key\n  const decrypted = decrypt(encryptedData, currentVersion, oldConfig);\n\n  // Encrypt with new key\n  return encrypt(decrypted.plaintext, { ...newConfig, version: newVersion });\n}\n\n/**\n * Test encryption/decryption round-trip\n *\n * @param testData - Test data to encrypt and decrypt\n * @returns True if round-trip successful, false otherwise\n */\nexport function testEncryption(testData: string = 'test-encryption-data'): boolean {\n  try {\n    const encrypted = encrypt(testData);\n    const decrypted = decrypt(encrypted.encrypted, encrypted.version);\n    return decrypted.plaintext === testData;\n  } catch (error) {\n    console.error('Encryption test failed:', error);\n    return false;\n  }\n}\n\n/**\n * Get encryption system status\n *\n * @returns Status information\n */\nexport function getEncryptionStatus(): {\n  keyLoaded: boolean;\n  version: string;\n  algorithm: string;\n  testPassed: boolean;\n} {\n  try {\n    const config = getEncryptionConfig();\n    const testPassed = testEncryption();\n\n    return {\n      keyLoaded: true,\n      version: config.version,\n      algorithm: config.algorithm!,\n      testPassed,\n    };\n  } catch (error) {\n    return {\n      keyLoaded: false,\n      version: 'unknown',\n      algorithm: 'unknown',\n      testPassed: false,\n    };\n  }\n}\n\n/**\n * Clear sensitive data from memory\n *\n * @param buffer - Buffer containing sensitive data\n */\nexport function clearBuffer(buffer: Buffer): void {\n  if (buffer && buffer.length > 0) {\n    crypto.randomFillSync(buffer);\n  }\n}\n\n/**\n * Encrypt with KMS-managed key (recommended for production)\n *\n * @param plaintext - Data to encrypt\n * @param tenantId - Tenant identifier for key retrieval\n * @param config - Optional encryption configuration\n * @returns Encryption result with encrypted data and metadata\n * @throws {EncryptionError} If encryption fails\n */\nexport async function encryptWithKMS(\n  plaintext: string,\n  tenantId: string,\n  config?: Partial<Omit<EncryptionConfig, 'key'>>\n): Promise<EncryptionResult> {\n  try {\n    const key = await loadEncryptionKeyWithKMS(tenantId);\n    return encrypt(plaintext, { ...config, key });\n  } catch (error) {\n    throw new EncryptionError(\n      'KMS encryption failed',\n      'KMS_ENCRYPTION_FAILED',\n      {\n        tenantId,\n        originalError: error instanceof Error ? error.message : String(error),\n      }\n    );\n  }\n}\n\n/**\n * Decrypt with KMS-managed key (recommended for production)\n *\n * @param encryptedData - Base64 encoded encrypted data\n * @param version - Key version used for encryption\n * @param tenantId - Tenant identifier for key retrieval\n * @param config - Optional decryption configuration\n * @returns Decryption result with plaintext and metadata\n * @throws {DecryptionError} If decryption fails\n */\nexport async function decryptWithKMS(\n  encryptedData: string,\n  version: string,\n  tenantId: string,\n  config?: Partial<Omit<EncryptionConfig, 'key'>>\n): Promise<DecryptionResult> {\n  try {\n    const key = await loadEncryptionKeyWithKMS(tenantId);\n    return decrypt(encryptedData, version, { ...config, key });\n  } catch (error) {\n    throw new DecryptionError(\n      'KMS decryption failed',\n      'KMS_DECRYPTION_FAILED',\n      {\n        tenantId,\n        originalError: error instanceof Error ? error.message : String(error),\n      }\n    );\n  }\n}\n\n/**\n * Batch encrypt with KMS-managed keys\n *\n * @param values - Array of plaintext values to encrypt\n * @param tenantId - Tenant identifier\n * @param config - Optional encryption configuration\n * @returns Array of encryption results\n */\nexport async function encryptBatchWithKMS(\n  values: string[],\n  tenantId: string,\n  config?: Partial<Omit<EncryptionConfig, 'key'>>\n): Promise<EncryptionResult[]> {\n  const key = await loadEncryptionKeyWithKMS(tenantId);\n  return values.map((value) => encrypt(value, { ...config, key }));\n}\n\n/**\n * Batch decrypt with KMS-managed keys\n *\n * @param encryptedValues - Array of encrypted values\n * @param tenantId - Tenant identifier\n * @param config - Optional decryption configuration\n * @returns Array of decryption results\n */\nexport async function decryptBatchWithKMS(\n  encryptedValues: Array<{ data: string; version: string }>,\n  tenantId: string,\n  config?: Partial<Omit<EncryptionConfig, 'key'>>\n): Promise<DecryptionResult[]> {\n  const key = await loadEncryptionKeyWithKMS(tenantId);\n  return encryptedValues.map((item) => decrypt(item.data, item.version, { ...config, key }));\n}\n\n/**\n * Export for testing purposes only\n * DO NOT use in production code\n */\nexport const __testing__ = {\n  generateIV,\n  validateConfig,\n  DEFAULT_CONFIG,\n};\n"],"names":["__testing__","clearBuffer","decrypt","decryptBatch","decryptBatchWithKMS","decryptWithKMS","encrypt","encryptBatch","encryptBatchWithKMS","encryptWithKMS","generateIV","getEncryptionConfig","getEncryptionStatus","loadEncryptionKey","loadEncryptionKeyWithKMS","reEncrypt","testEncryption","validateEncryptedData","DEFAULT_CONFIG","algorithm","ENCRYPTION_CONSTANTS","ALGORITHM","version","CURRENT_VERSION","ivLength","IV_SIZE","authTagLength","AUTH_TAG_SIZE","keyBase64","process","env","ENCRYPTION_KEY","KeyManagementError","hint","key","Buffer","from","length","KEY_SIZE","expected","actual","error","originalError","tenantId","useKMS","AWS_KMS_KEY_ID","getKeyManager","keyManager","getEncryptionKey","console","customConfig","crypto","randomBytes","validateConfig","config","keyLength","plaintext","fullConfig","iv","cipher","createCipheriv","encrypted","update","STRING_ENCODING","ENCODING","final","authTag","getAuthTag","combined","concat","encryptedBase64","toString","EncryptionError","Error","message","String","stack","undefined","encryptedData","DecryptionError","dataLength","minimumLength","subarray","ciphertext","decipher","createDecipheriv","setAuthTag","includes","result","valid","details","hasVersion","hasEncrypted","isBase64","hasValidStructure","buffer","minLength","values","map","value","encryptedValues","item","data","currentVersion","newVersion","oldConfig","newConfig","decrypted","testData","testPassed","keyLoaded","randomFillSync"],"mappings":"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"}