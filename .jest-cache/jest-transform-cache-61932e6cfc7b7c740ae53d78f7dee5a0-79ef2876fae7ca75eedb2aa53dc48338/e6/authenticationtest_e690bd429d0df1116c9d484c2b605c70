dd4860961df84225f0d39c1c20dd160a
/**
 * Authentication Tests
 *
 * Comprehensive tests for user authentication including login validation,
 * credential verification, and MFA token validation.
 *
 * @module tests/unit/auth/authentication
 */ "use strict";
// Mock Supabase client
jest.mock('@/lib/supabase/server');
jest.mock('otplib', ()=>({
        authenticator: {
            verify: jest.fn(),
            options: {}
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _server = require("../../../src/lib/supabase/server");
const _mfa = require("../../../src/lib/auth/mfa");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('Authentication', ()=>{
    const mockCreateClient = _server.createClient;
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('Test 6: User Login with Valid Credentials', ()=>{
        it('should successfully authenticate user with correct email and password', async ()=>{
            // Arrange
            const mockUser = {
                id: 'user-valid-login',
                email: 'valid@example.com',
                user_metadata: {
                    full_name: 'Valid User'
                }
            };
            const mockSession = {
                user: mockUser,
                access_token: 'mock-access-token-123',
                refresh_token: 'mock-refresh-token-456',
                expires_at: Date.now() + 3600000
            };
            const mockSupabaseClient = {
                auth: {
                    signInWithPassword: jest.fn().mockResolvedValue({
                        data: {
                            session: mockSession,
                            user: mockUser
                        },
                        error: null
                    }),
                    getSession: jest.fn().mockResolvedValue({
                        data: {
                            session: mockSession
                        },
                        error: null
                    })
                }
            };
            mockCreateClient.mockResolvedValue(mockSupabaseClient);
            // Act
            const { data, error } = await mockSupabaseClient.auth.signInWithPassword({
                email: 'valid@example.com',
                password: 'SecurePassword123!'
            });
            // Assert
            expect(error).toBeNull();
            expect(data.user).toBeDefined();
            expect(data.user.id).toBe('user-valid-login');
            expect(data.user.email).toBe('valid@example.com');
            expect(data.session).toBeDefined();
            expect(data.session.access_token).toBe('mock-access-token-123');
            expect(mockSupabaseClient.auth.signInWithPassword).toHaveBeenCalledWith({
                email: 'valid@example.com',
                password: 'SecurePassword123!'
            });
        });
        it('should return user profile data after successful authentication', async ()=>{
            // Arrange
            const mockUser = {
                id: 'user-profile-test',
                email: 'profile@example.com',
                user_metadata: {
                    full_name: 'Profile User'
                }
            };
            const mockProfile = {
                id: 'user-profile-test',
                email: 'profile@example.com',
                full_name: 'Profile User',
                organization_id: 'org-123',
                role: 'admin',
                permissions: {
                    can_manage_users: true,
                    can_view_analytics: true
                },
                last_seen: new Date().toISOString()
            };
            const mockSupabaseClient = {
                auth: {
                    signInWithPassword: jest.fn().mockResolvedValue({
                        data: {
                            user: mockUser
                        },
                        error: null
                    })
                },
                from: jest.fn(()=>({
                        select: jest.fn().mockReturnThis(),
                        eq: jest.fn().mockReturnThis(),
                        single: jest.fn().mockResolvedValue({
                            data: mockProfile,
                            error: null
                        })
                    }))
            };
            mockCreateClient.mockResolvedValue(mockSupabaseClient);
            // Act
            const { data: authData, error: authError } = await mockSupabaseClient.auth.signInWithPassword({
                email: 'profile@example.com',
                password: 'Password123!'
            });
            const { data: profileData } = await mockSupabaseClient.from('profiles').select('*').eq('id', authData.user.id).single();
            // Assert
            expect(authError).toBeNull();
            expect(profileData).toBeDefined();
            expect(profileData.id).toBe('user-profile-test');
            expect(profileData.role).toBe('admin');
            expect(profileData.organization_id).toBe('org-123');
            expect(profileData.permissions.can_manage_users).toBe(true);
        });
        it('should create session with proper expiration time', async ()=>{
            // Arrange
            const now = Date.now();
            const expiresAt = now + 3600000; // 1 hour
            const mockSession = {
                user: {
                    id: 'user-session',
                    email: 'session@example.com'
                },
                access_token: 'token-123',
                refresh_token: 'refresh-456',
                expires_at: expiresAt
            };
            const mockSupabaseClient = {
                auth: {
                    signInWithPassword: jest.fn().mockResolvedValue({
                        data: {
                            session: mockSession
                        },
                        error: null
                    })
                }
            };
            mockCreateClient.mockResolvedValue(mockSupabaseClient);
            // Act
            const { data } = await mockSupabaseClient.auth.signInWithPassword({
                email: 'session@example.com',
                password: 'Password123!'
            });
            // Assert
            expect(data.session).toBeDefined();
            expect(data.session.expires_at).toBeGreaterThan(now);
            expect(data.session.expires_at).toBeLessThanOrEqual(expiresAt + 1000);
            expect(data.session.access_token).toBeDefined();
            expect(data.session.refresh_token).toBeDefined();
        });
    });
    describe('Test 7: User Login with Invalid Credentials', ()=>{
        it('should reject authentication with incorrect password', async ()=>{
            // Arrange
            const mockSupabaseClient = {
                auth: {
                    signInWithPassword: jest.fn().mockResolvedValue({
                        data: {
                            session: null,
                            user: null
                        },
                        error: {
                            message: 'Invalid login credentials',
                            status: 400,
                            name: 'AuthApiError'
                        }
                    })
                }
            };
            mockCreateClient.mockResolvedValue(mockSupabaseClient);
            // Act
            const { data, error } = await mockSupabaseClient.auth.signInWithPassword({
                email: 'valid@example.com',
                password: 'WrongPassword123!'
            });
            // Assert
            expect(error).toBeDefined();
            expect(error.message).toBe('Invalid login credentials');
            expect(error.status).toBe(400);
            expect(data.session).toBeNull();
            expect(data.user).toBeNull();
        });
        it('should reject authentication with non-existent email', async ()=>{
            // Arrange
            const mockSupabaseClient = {
                auth: {
                    signInWithPassword: jest.fn().mockResolvedValue({
                        data: {
                            session: null,
                            user: null
                        },
                        error: {
                            message: 'Invalid login credentials',
                            status: 400,
                            name: 'AuthApiError'
                        }
                    })
                }
            };
            mockCreateClient.mockResolvedValue(mockSupabaseClient);
            // Act
            const { data, error } = await mockSupabaseClient.auth.signInWithPassword({
                email: 'nonexistent@example.com',
                password: 'AnyPassword123!'
            });
            // Assert
            expect(error).toBeDefined();
            expect(error.message).toBe('Invalid login credentials');
            expect(data.session).toBeNull();
            expect(data.user).toBeNull();
        });
        it('should reject authentication with malformed email', async ()=>{
            // Arrange
            const mockSupabaseClient = {
                auth: {
                    signInWithPassword: jest.fn().mockResolvedValue({
                        data: {
                            session: null,
                            user: null
                        },
                        error: {
                            message: 'Invalid email format',
                            status: 422,
                            name: 'ValidationError'
                        }
                    })
                }
            };
            mockCreateClient.mockResolvedValue(mockSupabaseClient);
            // Act
            const { data, error } = await mockSupabaseClient.auth.signInWithPassword({
                email: 'not-an-email',
                password: 'Password123!'
            });
            // Assert
            expect(error).toBeDefined();
            expect(error.message).toContain('email');
            expect(data.session).toBeNull();
        });
        it('should reject authentication with empty credentials', async ()=>{
            // Arrange
            const mockSupabaseClient = {
                auth: {
                    signInWithPassword: jest.fn().mockResolvedValue({
                        data: {
                            session: null,
                            user: null
                        },
                        error: {
                            message: 'Email and password are required',
                            status: 422,
                            name: 'ValidationError'
                        }
                    })
                }
            };
            mockCreateClient.mockResolvedValue(mockSupabaseClient);
            // Act
            const { data, error } = await mockSupabaseClient.auth.signInWithPassword({
                email: '',
                password: ''
            });
            // Assert
            expect(error).toBeDefined();
            expect(error.message).toContain('required');
            expect(data.session).toBeNull();
        });
        it('should handle rate limiting for too many failed attempts', async ()=>{
            // Arrange
            const mockSupabaseClient = {
                auth: {
                    signInWithPassword: jest.fn().mockResolvedValue({
                        data: {
                            session: null,
                            user: null
                        },
                        error: {
                            message: 'Too many requests. Please try again later.',
                            status: 429,
                            name: 'RateLimitError'
                        }
                    })
                }
            };
            mockCreateClient.mockResolvedValue(mockSupabaseClient);
            // Act
            const { data, error } = await mockSupabaseClient.auth.signInWithPassword({
                email: 'user@example.com',
                password: 'WrongPassword'
            });
            // Assert
            expect(error).toBeDefined();
            expect(error.status).toBe(429);
            expect(error.message).toContain('Too many requests');
            expect(data.session).toBeNull();
        });
    });
    describe('Test 8: MFA Token Verification', ()=>{
        it('should successfully verify valid TOTP token', async ()=>{
            // Arrange
            const userId = 'user-mfa-enabled';
            const validToken = '123456';
            const mockProfile = {
                id: userId,
                mfa_enabled: true,
                mfa_secret: 'JBSWY3DPEHPK3PXP',
                mfa_backup_codes: []
            };
            const mockSupabaseClient = {
                from: jest.fn(()=>({
                        select: jest.fn().mockReturnThis(),
                        eq: jest.fn().mockReturnThis(),
                        single: jest.fn().mockResolvedValue({
                            data: mockProfile,
                            error: null
                        })
                    }))
            };
            mockCreateClient.mockResolvedValue(mockSupabaseClient);
            // Mock authenticator.verify to return true
            const { authenticator } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("otplib")));
            authenticator.verify.mockReturnValue(true);
            // Act
            const result = await (0, _mfa.verifyMFAToken)(userId, validToken);
            // Assert
            expect(result.valid).toBe(true);
            expect(result.error).toBeUndefined();
            expect(authenticator.verify).toHaveBeenCalledWith({
                token: validToken,
                secret: mockProfile.mfa_secret
            });
        });
        it('should reject invalid TOTP token', async ()=>{
            // Arrange
            const userId = 'user-mfa-invalid';
            const invalidToken = '000000';
            const mockProfile = {
                id: userId,
                mfa_enabled: true,
                mfa_secret: 'JBSWY3DPEHPK3PXP',
                mfa_backup_codes: []
            };
            const mockSupabaseClient = {
                from: jest.fn(()=>({
                        select: jest.fn().mockReturnThis(),
                        eq: jest.fn().mockReturnThis(),
                        single: jest.fn().mockResolvedValue({
                            data: mockProfile,
                            error: null
                        })
                    }))
            };
            mockCreateClient.mockResolvedValue(mockSupabaseClient);
            // Mock authenticator.verify to return false
            const { authenticator } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("otplib")));
            authenticator.verify.mockReturnValue(false);
            // Act
            const result = await (0, _mfa.verifyMFAToken)(userId, invalidToken);
            // Assert
            expect(result.valid).toBe(false);
            expect(result.error).toBe('Invalid verification code');
        });
        it('should reject MFA verification when MFA is not enabled', async ()=>{
            // Arrange
            const userId = 'user-mfa-not-enabled';
            const token = '123456';
            const mockProfile = {
                id: userId,
                mfa_enabled: false,
                mfa_secret: null,
                mfa_backup_codes: []
            };
            const mockSupabaseClient = {
                from: jest.fn(()=>({
                        select: jest.fn().mockReturnThis(),
                        eq: jest.fn().mockReturnThis(),
                        single: jest.fn().mockResolvedValue({
                            data: mockProfile,
                            error: null
                        })
                    }))
            };
            mockCreateClient.mockResolvedValue(mockSupabaseClient);
            // Act
            const result = await (0, _mfa.verifyMFAToken)(userId, token);
            // Assert
            expect(result.valid).toBe(false);
            expect(result.error).toBe('MFA not enabled');
        });
        it('should validate TOTP token format (6 digits)', ()=>{
            // Arrange & Act & Assert
            expect((0, _mfa.isValidMFATokenFormat)('123456')).toBe(true);
            expect((0, _mfa.isValidMFATokenFormat)('000000')).toBe(true);
            expect((0, _mfa.isValidMFATokenFormat)('999999')).toBe(true);
            expect((0, _mfa.isValidMFATokenFormat)('12345')).toBe(false); // Too short
            expect((0, _mfa.isValidMFATokenFormat)('1234567')).toBe(false); // Too long
            expect((0, _mfa.isValidMFATokenFormat)('12345a')).toBe(false); // Contains letter
            expect((0, _mfa.isValidMFATokenFormat)('')).toBe(false); // Empty
        });
        it('should validate backup code format (XXXX-XXXX)', ()=>{
            // Arrange & Act & Assert
            expect((0, _mfa.isValidMFATokenFormat)('ABCD-1234')).toBe(true);
            expect((0, _mfa.isValidMFATokenFormat)('AB23-XY89')).toBe(true);
            expect((0, _mfa.isValidMFATokenFormat)('abcd-1234')).toBe(false); // Lowercase not allowed
            expect((0, _mfa.isValidMFATokenFormat)('ABCD1234')).toBe(false); // Missing hyphen
            expect((0, _mfa.isValidMFATokenFormat)('ABC-1234')).toBe(false); // Too short
            expect((0, _mfa.isValidMFATokenFormat)('ABCDE-1234')).toBe(false); // Too long
        });
        it('should get correct MFA status for user', async ()=>{
            // Arrange
            const userId = 'user-mfa-status';
            const mockProfile = {
                id: userId,
                mfa_enabled: true,
                mfa_enrolled_at: '2024-01-15T10:30:00Z',
                mfa_backup_codes: [
                    'code1',
                    'code2',
                    'code3',
                    'code4',
                    'code5'
                ]
            };
            const mockSupabaseClient = {
                from: jest.fn(()=>({
                        select: jest.fn().mockReturnThis(),
                        eq: jest.fn().mockReturnThis(),
                        single: jest.fn().mockResolvedValue({
                            data: mockProfile,
                            error: null
                        })
                    }))
            };
            mockCreateClient.mockResolvedValue(mockSupabaseClient);
            // Act
            const status = await (0, _mfa.getMFAStatus)(userId);
            // Assert
            expect(status.enabled).toBe(true);
            expect(status.enrolledAt).toBe('2024-01-15T10:30:00Z');
            expect(status.backupCodesRemaining).toBe(5);
        });
        it('should return default status when user not found', async ()=>{
            // Arrange
            const userId = 'non-existent-user';
            const mockSupabaseClient = {
                from: jest.fn(()=>({
                        select: jest.fn().mockReturnThis(),
                        eq: jest.fn().mockReturnThis(),
                        single: jest.fn().mockResolvedValue({
                            data: null,
                            error: {
                                message: 'User not found'
                            }
                        })
                    }))
            };
            mockCreateClient.mockResolvedValue(mockSupabaseClient);
            // Act
            const status = await (0, _mfa.getMFAStatus)(userId);
            // Assert
            expect(status.enabled).toBe(false);
            expect(status.enrolledAt).toBeNull();
            expect(status.backupCodesRemaining).toBe(0);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxBaSBQcm9qZWN0ZW5cXEFEU2FwcFxcdGVzdHNcXHVuaXRcXGF1dGhcXGF1dGhlbnRpY2F0aW9uLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBdXRoZW50aWNhdGlvbiBUZXN0c1xuICpcbiAqIENvbXByZWhlbnNpdmUgdGVzdHMgZm9yIHVzZXIgYXV0aGVudGljYXRpb24gaW5jbHVkaW5nIGxvZ2luIHZhbGlkYXRpb24sXG4gKiBjcmVkZW50aWFsIHZlcmlmaWNhdGlvbiwgYW5kIE1GQSB0b2tlbiB2YWxpZGF0aW9uLlxuICpcbiAqIEBtb2R1bGUgdGVzdHMvdW5pdC9hdXRoL2F1dGhlbnRpY2F0aW9uXG4gKi9cblxuaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQC9saWIvc3VwYWJhc2Uvc2VydmVyJztcbmltcG9ydCB7XG4gIHZlcmlmeU1GQVRva2VuLFxuICB2ZXJpZnlBbmRFbmFibGVNRkEsXG4gIGdldE1GQVN0YXR1cyxcbiAgaXNWYWxpZE1GQVRva2VuRm9ybWF0LFxufSBmcm9tICdAL2xpYi9hdXRoL21mYSc7XG5cbi8vIE1vY2sgU3VwYWJhc2UgY2xpZW50XG5qZXN0Lm1vY2soJ0AvbGliL3N1cGFiYXNlL3NlcnZlcicpO1xuamVzdC5tb2NrKCdvdHBsaWInLCAoKSA9PiAoe1xuICBhdXRoZW50aWNhdG9yOiB7XG4gICAgdmVyaWZ5OiBqZXN0LmZuKCksXG4gICAgb3B0aW9uczoge30sXG4gIH0sXG59KSk7XG5cbmRlc2NyaWJlKCdBdXRoZW50aWNhdGlvbicsICgpID0+IHtcbiAgY29uc3QgbW9ja0NyZWF0ZUNsaWVudCA9IGNyZWF0ZUNsaWVudCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBjcmVhdGVDbGllbnQ+O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnVGVzdCA2OiBVc2VyIExvZ2luIHdpdGggVmFsaWQgQ3JlZGVudGlhbHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzdWNjZXNzZnVsbHkgYXV0aGVudGljYXRlIHVzZXIgd2l0aCBjb3JyZWN0IGVtYWlsIGFuZCBwYXNzd29yZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgICBpZDogJ3VzZXItdmFsaWQtbG9naW4nLFxuICAgICAgICBlbWFpbDogJ3ZhbGlkQGV4YW1wbGUuY29tJyxcbiAgICAgICAgdXNlcl9tZXRhZGF0YToge1xuICAgICAgICAgIGZ1bGxfbmFtZTogJ1ZhbGlkIFVzZXInLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1Nlc3Npb24gPSB7XG4gICAgICAgIHVzZXI6IG1vY2tVc2VyLFxuICAgICAgICBhY2Nlc3NfdG9rZW46ICdtb2NrLWFjY2Vzcy10b2tlbi0xMjMnLFxuICAgICAgICByZWZyZXNoX3Rva2VuOiAnbW9jay1yZWZyZXNoLXRva2VuLTQ1NicsXG4gICAgICAgIGV4cGlyZXNfYXQ6IERhdGUubm93KCkgKyAzNjAwMDAwLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1N1cGFiYXNlQ2xpZW50ID0ge1xuICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgc2lnbkluV2l0aFBhc3N3b3JkOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgZGF0YTogeyBzZXNzaW9uOiBtb2NrU2Vzc2lvbiwgdXNlcjogbW9ja1VzZXIgfSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGdldFNlc3Npb246IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICBkYXRhOiB7IHNlc3Npb246IG1vY2tTZXNzaW9uIH0sXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tDcmVhdGVDbGllbnQubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1cGFiYXNlQ2xpZW50IGFzIGFueSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgbW9ja1N1cGFiYXNlQ2xpZW50LmF1dGguc2lnbkluV2l0aFBhc3N3b3JkKHtcbiAgICAgICAgZW1haWw6ICd2YWxpZEBleGFtcGxlLmNvbScsXG4gICAgICAgIHBhc3N3b3JkOiAnU2VjdXJlUGFzc3dvcmQxMjMhJyxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChlcnJvcikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChkYXRhLnVzZXIpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZGF0YS51c2VyLmlkKS50b0JlKCd1c2VyLXZhbGlkLWxvZ2luJyk7XG4gICAgICBleHBlY3QoZGF0YS51c2VyLmVtYWlsKS50b0JlKCd2YWxpZEBleGFtcGxlLmNvbScpO1xuICAgICAgZXhwZWN0KGRhdGEuc2Vzc2lvbikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChkYXRhLnNlc3Npb24uYWNjZXNzX3Rva2VuKS50b0JlKCdtb2NrLWFjY2Vzcy10b2tlbi0xMjMnKTtcbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2VDbGllbnQuYXV0aC5zaWduSW5XaXRoUGFzc3dvcmQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgZW1haWw6ICd2YWxpZEBleGFtcGxlLmNvbScsXG4gICAgICAgIHBhc3N3b3JkOiAnU2VjdXJlUGFzc3dvcmQxMjMhJyxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdXNlciBwcm9maWxlIGRhdGEgYWZ0ZXIgc3VjY2Vzc2Z1bCBhdXRoZW50aWNhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgICBpZDogJ3VzZXItcHJvZmlsZS10ZXN0JyxcbiAgICAgICAgZW1haWw6ICdwcm9maWxlQGV4YW1wbGUuY29tJyxcbiAgICAgICAgdXNlcl9tZXRhZGF0YToge1xuICAgICAgICAgIGZ1bGxfbmFtZTogJ1Byb2ZpbGUgVXNlcicsXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrUHJvZmlsZSA9IHtcbiAgICAgICAgaWQ6ICd1c2VyLXByb2ZpbGUtdGVzdCcsXG4gICAgICAgIGVtYWlsOiAncHJvZmlsZUBleGFtcGxlLmNvbScsXG4gICAgICAgIGZ1bGxfbmFtZTogJ1Byb2ZpbGUgVXNlcicsXG4gICAgICAgIG9yZ2FuaXphdGlvbl9pZDogJ29yZy0xMjMnLFxuICAgICAgICByb2xlOiAnYWRtaW4nLFxuICAgICAgICBwZXJtaXNzaW9uczoge1xuICAgICAgICAgIGNhbl9tYW5hZ2VfdXNlcnM6IHRydWUsXG4gICAgICAgICAgY2FuX3ZpZXdfYW5hbHl0aWNzOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBsYXN0X3NlZW46IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tTdXBhYmFzZUNsaWVudCA9IHtcbiAgICAgICAgYXV0aDoge1xuICAgICAgICAgIHNpZ25JbldpdGhQYXNzd29yZDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgIGRhdGE6IHsgdXNlcjogbW9ja1VzZXIgfSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9LFxuICAgICAgICBmcm9tOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgZGF0YTogbW9ja1Byb2ZpbGUsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSkpLFxuICAgICAgfTtcblxuICAgICAgbW9ja0NyZWF0ZUNsaWVudC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VwYWJhc2VDbGllbnQgYXMgYW55KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCB7IGRhdGE6IGF1dGhEYXRhLCBlcnJvcjogYXV0aEVycm9yIH0gPSBhd2FpdCBtb2NrU3VwYWJhc2VDbGllbnQuYXV0aC5zaWduSW5XaXRoUGFzc3dvcmQoe1xuICAgICAgICBlbWFpbDogJ3Byb2ZpbGVAZXhhbXBsZS5jb20nLFxuICAgICAgICBwYXNzd29yZDogJ1Bhc3N3b3JkMTIzIScsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgeyBkYXRhOiBwcm9maWxlRGF0YSB9ID0gYXdhaXQgbW9ja1N1cGFiYXNlQ2xpZW50XG4gICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ2lkJywgYXV0aERhdGEudXNlci5pZClcbiAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChhdXRoRXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QocHJvZmlsZURhdGEpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocHJvZmlsZURhdGEuaWQpLnRvQmUoJ3VzZXItcHJvZmlsZS10ZXN0Jyk7XG4gICAgICBleHBlY3QocHJvZmlsZURhdGEucm9sZSkudG9CZSgnYWRtaW4nKTtcbiAgICAgIGV4cGVjdChwcm9maWxlRGF0YS5vcmdhbml6YXRpb25faWQpLnRvQmUoJ29yZy0xMjMnKTtcbiAgICAgIGV4cGVjdChwcm9maWxlRGF0YS5wZXJtaXNzaW9ucy5jYW5fbWFuYWdlX3VzZXJzKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgc2Vzc2lvbiB3aXRoIHByb3BlciBleHBpcmF0aW9uIHRpbWUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gbm93ICsgMzYwMDAwMDsgLy8gMSBob3VyXG5cbiAgICAgIGNvbnN0IG1vY2tTZXNzaW9uID0ge1xuICAgICAgICB1c2VyOiB7IGlkOiAndXNlci1zZXNzaW9uJywgZW1haWw6ICdzZXNzaW9uQGV4YW1wbGUuY29tJyB9LFxuICAgICAgICBhY2Nlc3NfdG9rZW46ICd0b2tlbi0xMjMnLFxuICAgICAgICByZWZyZXNoX3Rva2VuOiAncmVmcmVzaC00NTYnLFxuICAgICAgICBleHBpcmVzX2F0OiBleHBpcmVzQXQsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrU3VwYWJhc2VDbGllbnQgPSB7XG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICBzaWduSW5XaXRoUGFzc3dvcmQ6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICBkYXRhOiB7IHNlc3Npb246IG1vY2tTZXNzaW9uIH0sXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tDcmVhdGVDbGllbnQubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1cGFiYXNlQ2xpZW50IGFzIGFueSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBtb2NrU3VwYWJhc2VDbGllbnQuYXV0aC5zaWduSW5XaXRoUGFzc3dvcmQoe1xuICAgICAgICBlbWFpbDogJ3Nlc3Npb25AZXhhbXBsZS5jb20nLFxuICAgICAgICBwYXNzd29yZDogJ1Bhc3N3b3JkMTIzIScsXG4gICAgICB9KTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZGF0YS5zZXNzaW9uKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGRhdGEuc2Vzc2lvbi5leHBpcmVzX2F0KS50b0JlR3JlYXRlclRoYW4obm93KTtcbiAgICAgIGV4cGVjdChkYXRhLnNlc3Npb24uZXhwaXJlc19hdCkudG9CZUxlc3NUaGFuT3JFcXVhbChleHBpcmVzQXQgKyAxMDAwKTtcbiAgICAgIGV4cGVjdChkYXRhLnNlc3Npb24uYWNjZXNzX3Rva2VuKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGRhdGEuc2Vzc2lvbi5yZWZyZXNoX3Rva2VuKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVGVzdCA3OiBVc2VyIExvZ2luIHdpdGggSW52YWxpZCBDcmVkZW50aWFscycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJlamVjdCBhdXRoZW50aWNhdGlvbiB3aXRoIGluY29ycmVjdCBwYXNzd29yZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG1vY2tTdXBhYmFzZUNsaWVudCA9IHtcbiAgICAgICAgYXV0aDoge1xuICAgICAgICAgIHNpZ25JbldpdGhQYXNzd29yZDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgIGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LFxuICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgbG9naW4gY3JlZGVudGlhbHMnLFxuICAgICAgICAgICAgICBzdGF0dXM6IDQwMCxcbiAgICAgICAgICAgICAgbmFtZTogJ0F1dGhBcGlFcnJvcicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgbW9ja0NyZWF0ZUNsaWVudC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VwYWJhc2VDbGllbnQgYXMgYW55KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBtb2NrU3VwYWJhc2VDbGllbnQuYXV0aC5zaWduSW5XaXRoUGFzc3dvcmQoe1xuICAgICAgICBlbWFpbDogJ3ZhbGlkQGV4YW1wbGUuY29tJyxcbiAgICAgICAgcGFzc3dvcmQ6ICdXcm9uZ1Bhc3N3b3JkMTIzIScsXG4gICAgICB9KTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZXJyb3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSkudG9CZSgnSW52YWxpZCBsb2dpbiBjcmVkZW50aWFscycpO1xuICAgICAgZXhwZWN0KGVycm9yLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KGRhdGEuc2Vzc2lvbikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChkYXRhLnVzZXIpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBhdXRoZW50aWNhdGlvbiB3aXRoIG5vbi1leGlzdGVudCBlbWFpbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG1vY2tTdXBhYmFzZUNsaWVudCA9IHtcbiAgICAgICAgYXV0aDoge1xuICAgICAgICAgIHNpZ25JbldpdGhQYXNzd29yZDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgIGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LFxuICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgbG9naW4gY3JlZGVudGlhbHMnLFxuICAgICAgICAgICAgICBzdGF0dXM6IDQwMCxcbiAgICAgICAgICAgICAgbmFtZTogJ0F1dGhBcGlFcnJvcicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgbW9ja0NyZWF0ZUNsaWVudC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VwYWJhc2VDbGllbnQgYXMgYW55KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBtb2NrU3VwYWJhc2VDbGllbnQuYXV0aC5zaWduSW5XaXRoUGFzc3dvcmQoe1xuICAgICAgICBlbWFpbDogJ25vbmV4aXN0ZW50QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcGFzc3dvcmQ6ICdBbnlQYXNzd29yZDEyMyEnLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGVycm9yKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGVycm9yLm1lc3NhZ2UpLnRvQmUoJ0ludmFsaWQgbG9naW4gY3JlZGVudGlhbHMnKTtcbiAgICAgIGV4cGVjdChkYXRhLnNlc3Npb24pLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoZGF0YS51c2VyKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgYXV0aGVudGljYXRpb24gd2l0aCBtYWxmb3JtZWQgZW1haWwnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBtb2NrU3VwYWJhc2VDbGllbnQgPSB7XG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICBzaWduSW5XaXRoUGFzc3dvcmQ6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICBkYXRhOiB7IHNlc3Npb246IG51bGwsIHVzZXI6IG51bGwgfSxcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGVtYWlsIGZvcm1hdCcsXG4gICAgICAgICAgICAgIHN0YXR1czogNDIyLFxuICAgICAgICAgICAgICBuYW1lOiAnVmFsaWRhdGlvbkVycm9yJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBtb2NrQ3JlYXRlQ2xpZW50Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdXBhYmFzZUNsaWVudCBhcyBhbnkpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IG1vY2tTdXBhYmFzZUNsaWVudC5hdXRoLnNpZ25JbldpdGhQYXNzd29yZCh7XG4gICAgICAgIGVtYWlsOiAnbm90LWFuLWVtYWlsJyxcbiAgICAgICAgcGFzc3dvcmQ6ICdQYXNzd29yZDEyMyEnLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGVycm9yKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignZW1haWwnKTtcbiAgICAgIGV4cGVjdChkYXRhLnNlc3Npb24pLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBhdXRoZW50aWNhdGlvbiB3aXRoIGVtcHR5IGNyZWRlbnRpYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgbW9ja1N1cGFiYXNlQ2xpZW50ID0ge1xuICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgc2lnbkluV2l0aFBhc3N3b3JkOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgZGF0YTogeyBzZXNzaW9uOiBudWxsLCB1c2VyOiBudWxsIH0sXG4gICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICBtZXNzYWdlOiAnRW1haWwgYW5kIHBhc3N3b3JkIGFyZSByZXF1aXJlZCcsXG4gICAgICAgICAgICAgIHN0YXR1czogNDIyLFxuICAgICAgICAgICAgICBuYW1lOiAnVmFsaWRhdGlvbkVycm9yJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBtb2NrQ3JlYXRlQ2xpZW50Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdXBhYmFzZUNsaWVudCBhcyBhbnkpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IG1vY2tTdXBhYmFzZUNsaWVudC5hdXRoLnNpZ25JbldpdGhQYXNzd29yZCh7XG4gICAgICAgIGVtYWlsOiAnJyxcbiAgICAgICAgcGFzc3dvcmQ6ICcnLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGVycm9yKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbigncmVxdWlyZWQnKTtcbiAgICAgIGV4cGVjdChkYXRhLnNlc3Npb24pLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByYXRlIGxpbWl0aW5nIGZvciB0b28gbWFueSBmYWlsZWQgYXR0ZW1wdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBtb2NrU3VwYWJhc2VDbGllbnQgPSB7XG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICBzaWduSW5XaXRoUGFzc3dvcmQ6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICBkYXRhOiB7IHNlc3Npb246IG51bGwsIHVzZXI6IG51bGwgfSxcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdUb28gbWFueSByZXF1ZXN0cy4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4nLFxuICAgICAgICAgICAgICBzdGF0dXM6IDQyOSxcbiAgICAgICAgICAgICAgbmFtZTogJ1JhdGVMaW1pdEVycm9yJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBtb2NrQ3JlYXRlQ2xpZW50Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdXBhYmFzZUNsaWVudCBhcyBhbnkpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IG1vY2tTdXBhYmFzZUNsaWVudC5hdXRoLnNpZ25JbldpdGhQYXNzd29yZCh7XG4gICAgICAgIGVtYWlsOiAndXNlckBleGFtcGxlLmNvbScsXG4gICAgICAgIHBhc3N3b3JkOiAnV3JvbmdQYXNzd29yZCcsXG4gICAgICB9KTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZXJyb3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZXJyb3Iuc3RhdHVzKS50b0JlKDQyOSk7XG4gICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdUb28gbWFueSByZXF1ZXN0cycpO1xuICAgICAgZXhwZWN0KGRhdGEuc2Vzc2lvbikudG9CZU51bGwoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Rlc3QgODogTUZBIFRva2VuIFZlcmlmaWNhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHN1Y2Nlc3NmdWxseSB2ZXJpZnkgdmFsaWQgVE9UUCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHVzZXJJZCA9ICd1c2VyLW1mYS1lbmFibGVkJztcbiAgICAgIGNvbnN0IHZhbGlkVG9rZW4gPSAnMTIzNDU2JztcblxuICAgICAgY29uc3QgbW9ja1Byb2ZpbGUgPSB7XG4gICAgICAgIGlkOiB1c2VySWQsXG4gICAgICAgIG1mYV9lbmFibGVkOiB0cnVlLFxuICAgICAgICBtZmFfc2VjcmV0OiAnSkJTV1kzRFBFSFBLM1BYUCcsXG4gICAgICAgIG1mYV9iYWNrdXBfY29kZXM6IFtdLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1N1cGFiYXNlQ2xpZW50ID0ge1xuICAgICAgICBmcm9tOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgZGF0YTogbW9ja1Byb2ZpbGUsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSkpLFxuICAgICAgfTtcblxuICAgICAgbW9ja0NyZWF0ZUNsaWVudC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VwYWJhc2VDbGllbnQgYXMgYW55KTtcblxuICAgICAgLy8gTW9jayBhdXRoZW50aWNhdG9yLnZlcmlmeSB0byByZXR1cm4gdHJ1ZVxuICAgICAgY29uc3QgeyBhdXRoZW50aWNhdG9yIH0gPSBhd2FpdCBpbXBvcnQoJ290cGxpYicpO1xuICAgICAgKGF1dGhlbnRpY2F0b3IudmVyaWZ5IGFzIGplc3QuTW9jaykubW9ja1JldHVyblZhbHVlKHRydWUpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZlcmlmeU1GQVRva2VuKHVzZXJJZCwgdmFsaWRUb2tlbik7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgIGV4cGVjdChhdXRoZW50aWNhdG9yLnZlcmlmeSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB0b2tlbjogdmFsaWRUb2tlbixcbiAgICAgICAgc2VjcmV0OiBtb2NrUHJvZmlsZS5tZmFfc2VjcmV0LFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBpbnZhbGlkIFRPVFAgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB1c2VySWQgPSAndXNlci1tZmEtaW52YWxpZCc7XG4gICAgICBjb25zdCBpbnZhbGlkVG9rZW4gPSAnMDAwMDAwJztcblxuICAgICAgY29uc3QgbW9ja1Byb2ZpbGUgPSB7XG4gICAgICAgIGlkOiB1c2VySWQsXG4gICAgICAgIG1mYV9lbmFibGVkOiB0cnVlLFxuICAgICAgICBtZmFfc2VjcmV0OiAnSkJTV1kzRFBFSFBLM1BYUCcsXG4gICAgICAgIG1mYV9iYWNrdXBfY29kZXM6IFtdLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1N1cGFiYXNlQ2xpZW50ID0ge1xuICAgICAgICBmcm9tOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgZGF0YTogbW9ja1Byb2ZpbGUsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSkpLFxuICAgICAgfTtcblxuICAgICAgbW9ja0NyZWF0ZUNsaWVudC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VwYWJhc2VDbGllbnQgYXMgYW55KTtcblxuICAgICAgLy8gTW9jayBhdXRoZW50aWNhdG9yLnZlcmlmeSB0byByZXR1cm4gZmFsc2VcbiAgICAgIGNvbnN0IHsgYXV0aGVudGljYXRvciB9ID0gYXdhaXQgaW1wb3J0KCdvdHBsaWInKTtcbiAgICAgIChhdXRoZW50aWNhdG9yLnZlcmlmeSBhcyBqZXN0Lk1vY2spLm1vY2tSZXR1cm5WYWx1ZShmYWxzZSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmVyaWZ5TUZBVG9rZW4odXNlcklkLCBpbnZhbGlkVG9rZW4pO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9CZSgnSW52YWxpZCB2ZXJpZmljYXRpb24gY29kZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgTUZBIHZlcmlmaWNhdGlvbiB3aGVuIE1GQSBpcyBub3QgZW5hYmxlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHVzZXJJZCA9ICd1c2VyLW1mYS1ub3QtZW5hYmxlZCc7XG4gICAgICBjb25zdCB0b2tlbiA9ICcxMjM0NTYnO1xuXG4gICAgICBjb25zdCBtb2NrUHJvZmlsZSA9IHtcbiAgICAgICAgaWQ6IHVzZXJJZCxcbiAgICAgICAgbWZhX2VuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBtZmFfc2VjcmV0OiBudWxsLFxuICAgICAgICBtZmFfYmFja3VwX2NvZGVzOiBbXSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tTdXBhYmFzZUNsaWVudCA9IHtcbiAgICAgICAgZnJvbTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgIGRhdGE6IG1vY2tQcm9maWxlLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pKSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tDcmVhdGVDbGllbnQubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1cGFiYXNlQ2xpZW50IGFzIGFueSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmVyaWZ5TUZBVG9rZW4odXNlcklkLCB0b2tlbik7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0JlKCdNRkEgbm90IGVuYWJsZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgVE9UUCB0b2tlbiBmb3JtYXQgKDYgZGlnaXRzKScsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2UgJiBBY3QgJiBBc3NlcnRcbiAgICAgIGV4cGVjdChpc1ZhbGlkTUZBVG9rZW5Gb3JtYXQoJzEyMzQ1NicpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGlzVmFsaWRNRkFUb2tlbkZvcm1hdCgnMDAwMDAwJykpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoaXNWYWxpZE1GQVRva2VuRm9ybWF0KCc5OTk5OTknKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChpc1ZhbGlkTUZBVG9rZW5Gb3JtYXQoJzEyMzQ1JykpLnRvQmUoZmFsc2UpOyAvLyBUb28gc2hvcnRcbiAgICAgIGV4cGVjdChpc1ZhbGlkTUZBVG9rZW5Gb3JtYXQoJzEyMzQ1NjcnKSkudG9CZShmYWxzZSk7IC8vIFRvbyBsb25nXG4gICAgICBleHBlY3QoaXNWYWxpZE1GQVRva2VuRm9ybWF0KCcxMjM0NWEnKSkudG9CZShmYWxzZSk7IC8vIENvbnRhaW5zIGxldHRlclxuICAgICAgZXhwZWN0KGlzVmFsaWRNRkFUb2tlbkZvcm1hdCgnJykpLnRvQmUoZmFsc2UpOyAvLyBFbXB0eVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBiYWNrdXAgY29kZSBmb3JtYXQgKFhYWFgtWFhYWCknLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlICYgQWN0ICYgQXNzZXJ0XG4gICAgICBleHBlY3QoaXNWYWxpZE1GQVRva2VuRm9ybWF0KCdBQkNELTEyMzQnKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChpc1ZhbGlkTUZBVG9rZW5Gb3JtYXQoJ0FCMjMtWFk4OScpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGlzVmFsaWRNRkFUb2tlbkZvcm1hdCgnYWJjZC0xMjM0JykpLnRvQmUoZmFsc2UpOyAvLyBMb3dlcmNhc2Ugbm90IGFsbG93ZWRcbiAgICAgIGV4cGVjdChpc1ZhbGlkTUZBVG9rZW5Gb3JtYXQoJ0FCQ0QxMjM0JykpLnRvQmUoZmFsc2UpOyAvLyBNaXNzaW5nIGh5cGhlblxuICAgICAgZXhwZWN0KGlzVmFsaWRNRkFUb2tlbkZvcm1hdCgnQUJDLTEyMzQnKSkudG9CZShmYWxzZSk7IC8vIFRvbyBzaG9ydFxuICAgICAgZXhwZWN0KGlzVmFsaWRNRkFUb2tlbkZvcm1hdCgnQUJDREUtMTIzNCcpKS50b0JlKGZhbHNlKTsgLy8gVG9vIGxvbmdcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZ2V0IGNvcnJlY3QgTUZBIHN0YXR1cyBmb3IgdXNlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHVzZXJJZCA9ICd1c2VyLW1mYS1zdGF0dXMnO1xuXG4gICAgICBjb25zdCBtb2NrUHJvZmlsZSA9IHtcbiAgICAgICAgaWQ6IHVzZXJJZCxcbiAgICAgICAgbWZhX2VuYWJsZWQ6IHRydWUsXG4gICAgICAgIG1mYV9lbnJvbGxlZF9hdDogJzIwMjQtMDEtMTVUMTA6MzA6MDBaJyxcbiAgICAgICAgbWZhX2JhY2t1cF9jb2RlczogWydjb2RlMScsICdjb2RlMicsICdjb2RlMycsICdjb2RlNCcsICdjb2RlNSddLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1N1cGFiYXNlQ2xpZW50ID0ge1xuICAgICAgICBmcm9tOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgZGF0YTogbW9ja1Byb2ZpbGUsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSkpLFxuICAgICAgfTtcblxuICAgICAgbW9ja0NyZWF0ZUNsaWVudC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VwYWJhc2VDbGllbnQgYXMgYW55KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCBnZXRNRkFTdGF0dXModXNlcklkKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3Qoc3RhdHVzLmVuYWJsZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3Qoc3RhdHVzLmVucm9sbGVkQXQpLnRvQmUoJzIwMjQtMDEtMTVUMTA6MzA6MDBaJyk7XG4gICAgICBleHBlY3Qoc3RhdHVzLmJhY2t1cENvZGVzUmVtYWluaW5nKS50b0JlKDUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZGVmYXVsdCBzdGF0dXMgd2hlbiB1c2VyIG5vdCBmb3VuZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHVzZXJJZCA9ICdub24tZXhpc3RlbnQtdXNlcic7XG5cbiAgICAgIGNvbnN0IG1vY2tTdXBhYmFzZUNsaWVudCA9IHtcbiAgICAgICAgZnJvbTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnVXNlciBub3QgZm91bmQnIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pKSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tDcmVhdGVDbGllbnQubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1cGFiYXNlQ2xpZW50IGFzIGFueSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgZ2V0TUZBU3RhdHVzKHVzZXJJZCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHN0YXR1cy5lbmFibGVkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChzdGF0dXMuZW5yb2xsZWRBdCkudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChzdGF0dXMuYmFja3VwQ29kZXNSZW1haW5pbmcpLnRvQmUoMCk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJhdXRoZW50aWNhdG9yIiwidmVyaWZ5IiwiZm4iLCJvcHRpb25zIiwiZGVzY3JpYmUiLCJtb2NrQ3JlYXRlQ2xpZW50IiwiY3JlYXRlQ2xpZW50IiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJpdCIsIm1vY2tVc2VyIiwiaWQiLCJlbWFpbCIsInVzZXJfbWV0YWRhdGEiLCJmdWxsX25hbWUiLCJtb2NrU2Vzc2lvbiIsInVzZXIiLCJhY2Nlc3NfdG9rZW4iLCJyZWZyZXNoX3Rva2VuIiwiZXhwaXJlc19hdCIsIkRhdGUiLCJub3ciLCJtb2NrU3VwYWJhc2VDbGllbnQiLCJhdXRoIiwic2lnbkluV2l0aFBhc3N3b3JkIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJkYXRhIiwic2Vzc2lvbiIsImVycm9yIiwiZ2V0U2Vzc2lvbiIsInBhc3N3b3JkIiwiZXhwZWN0IiwidG9CZU51bGwiLCJ0b0JlRGVmaW5lZCIsInRvQmUiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIm1vY2tQcm9maWxlIiwib3JnYW5pemF0aW9uX2lkIiwicm9sZSIsInBlcm1pc3Npb25zIiwiY2FuX21hbmFnZV91c2VycyIsImNhbl92aWV3X2FuYWx5dGljcyIsImxhc3Rfc2VlbiIsInRvSVNPU3RyaW5nIiwiZnJvbSIsInNlbGVjdCIsIm1vY2tSZXR1cm5UaGlzIiwiZXEiLCJzaW5nbGUiLCJhdXRoRGF0YSIsImF1dGhFcnJvciIsInByb2ZpbGVEYXRhIiwiZXhwaXJlc0F0IiwidG9CZUdyZWF0ZXJUaGFuIiwidG9CZUxlc3NUaGFuT3JFcXVhbCIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJuYW1lIiwidG9Db250YWluIiwidXNlcklkIiwidmFsaWRUb2tlbiIsIm1mYV9lbmFibGVkIiwibWZhX3NlY3JldCIsIm1mYV9iYWNrdXBfY29kZXMiLCJtb2NrUmV0dXJuVmFsdWUiLCJyZXN1bHQiLCJ2ZXJpZnlNRkFUb2tlbiIsInZhbGlkIiwidG9CZVVuZGVmaW5lZCIsInRva2VuIiwic2VjcmV0IiwiaW52YWxpZFRva2VuIiwiaXNWYWxpZE1GQVRva2VuRm9ybWF0IiwibWZhX2Vucm9sbGVkX2F0IiwiZ2V0TUZBU3RhdHVzIiwiZW5hYmxlZCIsImVucm9sbGVkQXQiLCJiYWNrdXBDb2Rlc1JlbWFpbmluZyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Q0FPQztBQVVELHVCQUF1QjtBQUN2QkEsS0FBS0MsSUFBSSxDQUFDO0FBQ1ZELEtBQUtDLElBQUksQ0FBQyxVQUFVLElBQU8sQ0FBQTtRQUN6QkMsZUFBZTtZQUNiQyxRQUFRSCxLQUFLSSxFQUFFO1lBQ2ZDLFNBQVMsQ0FBQztRQUNaO0lBQ0YsQ0FBQTs7Ozt3QkFmNkI7cUJBTXRCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXUEMsU0FBUyxrQkFBa0I7SUFDekIsTUFBTUMsbUJBQW1CQyxvQkFBWTtJQUVyQ0MsV0FBVztRQUNUVCxLQUFLVSxhQUFhO0lBQ3BCO0lBRUFKLFNBQVMsNkNBQTZDO1FBQ3BESyxHQUFHLHlFQUF5RTtZQUMxRSxVQUFVO1lBQ1YsTUFBTUMsV0FBVztnQkFDZkMsSUFBSTtnQkFDSkMsT0FBTztnQkFDUEMsZUFBZTtvQkFDYkMsV0FBVztnQkFDYjtZQUNGO1lBRUEsTUFBTUMsY0FBYztnQkFDbEJDLE1BQU1OO2dCQUNOTyxjQUFjO2dCQUNkQyxlQUFlO2dCQUNmQyxZQUFZQyxLQUFLQyxHQUFHLEtBQUs7WUFDM0I7WUFFQSxNQUFNQyxxQkFBcUI7Z0JBQ3pCQyxNQUFNO29CQUNKQyxvQkFBb0IxQixLQUFLSSxFQUFFLEdBQUd1QixpQkFBaUIs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