{"version":3,"sources":["C:\\Ai Projecten\\ADSapp\\src\\lib\\security\\input-validation.ts"],"sourcesContent":["/**\n * Input Validation Library for SQL Injection Prevention\n *\n * Provides comprehensive validation and sanitization functions for all user inputs\n * that will be used in database queries. This library follows a whitelist-first\n * approach and ensures that all inputs meet strict security criteria before\n * being passed to RPC functions or database queries.\n *\n * Security Standards:\n * - OWASP Top 10 Compliance\n * - Parameterized query enforcement\n * - Strict type validation\n * - Whitelist-based validation\n * - Maximum length enforcement\n * - Special character escaping\n *\n * @module input-validation\n */\n\n// ============================================================================\n// TYPE DEFINITIONS\n// ============================================================================\n\nexport interface ValidationResult {\n  isValid: boolean;\n  sanitizedValue?: any;\n  error?: string;\n  errorCode?: string;\n}\n\nexport interface ValidationOptions {\n  allowNull?: boolean;\n  maxLength?: number;\n  minLength?: number;\n  pattern?: RegExp;\n  allowedValues?: any[];\n  customValidator?: (value: any) => boolean;\n}\n\n// ============================================================================\n// VALIDATION ERROR CODES\n// ============================================================================\n\nexport const ValidationErrorCodes = {\n  INVALID_TYPE: 'INVALID_TYPE',\n  INVALID_FORMAT: 'INVALID_FORMAT',\n  INVALID_LENGTH: 'INVALID_LENGTH',\n  INVALID_VALUE: 'INVALID_VALUE',\n  NULL_NOT_ALLOWED: 'NULL_NOT_ALLOWED',\n  SQL_INJECTION_DETECTED: 'SQL_INJECTION_DETECTED',\n  XSS_DETECTED: 'XSS_DETECTED',\n  INVALID_UUID: 'INVALID_UUID',\n  INVALID_EMAIL: 'INVALID_EMAIL',\n  INVALID_PHONE: 'INVALID_PHONE',\n  INVALID_URL: 'INVALID_URL',\n  INVALID_JSON: 'INVALID_JSON',\n} as const;\n\n// ============================================================================\n// REGEX PATTERNS\n// ============================================================================\n\nconst PATTERNS = {\n  // UUID v4 strict format\n  UUID: /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i,\n\n  // Email validation (RFC 5322 simplified)\n  EMAIL: /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,\n\n  // Phone number (international format)\n  PHONE: /^\\+?[1-9]\\d{1,14}$/,\n\n  // URL validation\n  URL: /^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)$/,\n\n  // Alphanumeric with common safe characters\n  ALPHANUMERIC_SAFE: /^[a-zA-Z0-9\\s\\-\\_\\.]+$/,\n\n  // Text without SQL injection patterns\n  SAFE_TEXT: /^[^';\\\"\\\\]+$/,\n\n  // Integer\n  INTEGER: /^-?\\d+$/,\n\n  // Decimal/Float\n  DECIMAL: /^-?\\d+(\\.\\d+)?$/,\n\n  // Date ISO 8601\n  ISO_DATE: /^\\d{4}-\\d{2}-\\d{2}$/,\n\n  // DateTime ISO 8601\n  ISO_DATETIME: /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{3})?Z?$/,\n};\n\n// Common SQL injection patterns to detect and block\nconst SQL_INJECTION_PATTERNS = [\n  /(\\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|EXECUTE|UNION|SCRIPT)\\b)/i,\n  /(--|\\/\\*|\\*\\/|;|'|\")/,\n  /(\\bOR\\b|\\bAND\\b)\\s+['\"]?\\d+['\"]?\\s*=\\s*['\"]?\\d+['\"]?/i,\n  /\\b(WAITFOR|DELAY|SLEEP|BENCHMARK)\\b/i,\n  /xp_cmdshell|sp_executesql/i,\n  /\\b(INTO\\s+OUTFILE|INTO\\s+DUMPFILE)\\b/i,\n];\n\n// Common XSS patterns to detect and block\nconst XSS_PATTERNS = [\n  /<script[^>]*>.*?<\\/script>/gi,\n  /javascript:/gi,\n  /on\\w+\\s*=\\s*[\"'][^\"']*[\"']/gi,\n  /<iframe[^>]*>/gi,\n  /<embed[^>]*>/gi,\n  /<object[^>]*>/gi,\n];\n\n// ============================================================================\n// CORE VALIDATION FUNCTIONS\n// ============================================================================\n\n/**\n * Validates and sanitizes a UUID value\n */\nexport function validateUUID(value: any, options: ValidationOptions = {}): ValidationResult {\n  // Handle null values\n  if (value === null || value === undefined) {\n    if (options.allowNull) {\n      return { isValid: true, sanitizedValue: null };\n    }\n    return {\n      isValid: false,\n      error: 'UUID cannot be null',\n      errorCode: ValidationErrorCodes.NULL_NOT_ALLOWED,\n    };\n  }\n\n  // Must be a string\n  if (typeof value !== 'string') {\n    return {\n      isValid: false,\n      error: 'UUID must be a string',\n      errorCode: ValidationErrorCodes.INVALID_TYPE,\n    };\n  }\n\n  // Trim whitespace\n  const trimmed = value.trim();\n\n  // Validate UUID format\n  if (!PATTERNS.UUID.test(trimmed)) {\n    return {\n      isValid: false,\n      error: 'Invalid UUID format',\n      errorCode: ValidationErrorCodes.INVALID_UUID,\n    };\n  }\n\n  return {\n    isValid: true,\n    sanitizedValue: trimmed.toLowerCase(), // Normalize to lowercase\n  };\n}\n\n/**\n * Validates and sanitizes an email address\n */\nexport function validateEmail(value: any, options: ValidationOptions = {}): ValidationResult {\n  if (value === null || value === undefined) {\n    if (options.allowNull) {\n      return { isValid: true, sanitizedValue: null };\n    }\n    return {\n      isValid: false,\n      error: 'Email cannot be null',\n      errorCode: ValidationErrorCodes.NULL_NOT_ALLOWED,\n    };\n  }\n\n  if (typeof value !== 'string') {\n    return {\n      isValid: false,\n      error: 'Email must be a string',\n      errorCode: ValidationErrorCodes.INVALID_TYPE,\n    };\n  }\n\n  const trimmed = value.trim().toLowerCase();\n\n  // Length check\n  if (trimmed.length === 0 || trimmed.length > 254) {\n    return {\n      isValid: false,\n      error: 'Email length must be between 1 and 254 characters',\n      errorCode: ValidationErrorCodes.INVALID_LENGTH,\n    };\n  }\n\n  // Format validation\n  if (!PATTERNS.EMAIL.test(trimmed)) {\n    return {\n      isValid: false,\n      error: 'Invalid email format',\n      errorCode: ValidationErrorCodes.INVALID_EMAIL,\n    };\n  }\n\n  // Check for SQL injection patterns\n  if (containsSQLInjection(trimmed)) {\n    return {\n      isValid: false,\n      error: 'Email contains invalid characters',\n      errorCode: ValidationErrorCodes.SQL_INJECTION_DETECTED,\n    };\n  }\n\n  return {\n    isValid: true,\n    sanitizedValue: trimmed,\n  };\n}\n\n/**\n * Validates and sanitizes a phone number\n */\nexport function validatePhoneNumber(value: any, options: ValidationOptions = {}): ValidationResult {\n  if (value === null || value === undefined) {\n    if (options.allowNull) {\n      return { isValid: true, sanitizedValue: null };\n    }\n    return {\n      isValid: false,\n      error: 'Phone number cannot be null',\n      errorCode: ValidationErrorCodes.NULL_NOT_ALLOWED,\n    };\n  }\n\n  if (typeof value !== 'string') {\n    return {\n      isValid: false,\n      error: 'Phone number must be a string',\n      errorCode: ValidationErrorCodes.INVALID_TYPE,\n    };\n  }\n\n  // Remove common formatting characters\n  const cleaned = value.replace(/[\\s\\-\\(\\)\\.]/g, '');\n\n  // Validate format\n  if (!PATTERNS.PHONE.test(cleaned)) {\n    return {\n      isValid: false,\n      error: 'Invalid phone number format',\n      errorCode: ValidationErrorCodes.INVALID_PHONE,\n    };\n  }\n\n  return {\n    isValid: true,\n    sanitizedValue: cleaned,\n  };\n}\n\n/**\n * Validates and sanitizes text input\n */\nexport function validateText(value: any, options: ValidationOptions = {}): ValidationResult {\n  if (value === null || value === undefined) {\n    if (options.allowNull) {\n      return { isValid: true, sanitizedValue: null };\n    }\n    return {\n      isValid: false,\n      error: 'Text cannot be null',\n      errorCode: ValidationErrorCodes.NULL_NOT_ALLOWED,\n    };\n  }\n\n  if (typeof value !== 'string') {\n    return {\n      isValid: false,\n      error: 'Text must be a string',\n      errorCode: ValidationErrorCodes.INVALID_TYPE,\n    };\n  }\n\n  const trimmed = value.trim();\n\n  // Length validation\n  const maxLength = options.maxLength || 10000;\n  const minLength = options.minLength || 0;\n\n  if (trimmed.length < minLength || trimmed.length > maxLength) {\n    return {\n      isValid: false,\n      error: `Text length must be between ${minLength} and ${maxLength} characters`,\n      errorCode: ValidationErrorCodes.INVALID_LENGTH,\n    };\n  }\n\n  // SQL injection check\n  if (containsSQLInjection(trimmed)) {\n    return {\n      isValid: false,\n      error: 'Text contains potentially unsafe characters',\n      errorCode: ValidationErrorCodes.SQL_INJECTION_DETECTED,\n    };\n  }\n\n  // XSS check\n  if (containsXSS(trimmed)) {\n    return {\n      isValid: false,\n      error: 'Text contains potentially unsafe HTML/JavaScript',\n      errorCode: ValidationErrorCodes.XSS_DETECTED,\n    };\n  }\n\n  // Custom pattern validation\n  if (options.pattern && !options.pattern.test(trimmed)) {\n    return {\n      isValid: false,\n      error: 'Text does not match required pattern',\n      errorCode: ValidationErrorCodes.INVALID_FORMAT,\n    };\n  }\n\n  return {\n    isValid: true,\n    sanitizedValue: sanitizeText(trimmed),\n  };\n}\n\n/**\n * Validates and sanitizes an integer\n */\nexport function validateInteger(value: any, options: ValidationOptions = {}): ValidationResult {\n  if (value === null || value === undefined) {\n    if (options.allowNull) {\n      return { isValid: true, sanitizedValue: null };\n    }\n    return {\n      isValid: false,\n      error: 'Integer cannot be null',\n      errorCode: ValidationErrorCodes.NULL_NOT_ALLOWED,\n    };\n  }\n\n  let numValue: number;\n\n  if (typeof value === 'number') {\n    numValue = value;\n  } else if (typeof value === 'string') {\n    if (!PATTERNS.INTEGER.test(value.trim())) {\n      return {\n        isValid: false,\n        error: 'Invalid integer format',\n        errorCode: ValidationErrorCodes.INVALID_FORMAT,\n      };\n    }\n    numValue = parseInt(value.trim(), 10);\n  } else {\n    return {\n      isValid: false,\n      error: 'Integer must be a number or numeric string',\n      errorCode: ValidationErrorCodes.INVALID_TYPE,\n    };\n  }\n\n  // Check if parsing resulted in a valid integer\n  if (!Number.isInteger(numValue) || isNaN(numValue)) {\n    return {\n      isValid: false,\n      error: 'Invalid integer value',\n      errorCode: ValidationErrorCodes.INVALID_VALUE,\n    };\n  }\n\n  return {\n    isValid: true,\n    sanitizedValue: numValue,\n  };\n}\n\n/**\n * Validates and sanitizes JSON data\n */\nexport function validateJSON(value: any, options: ValidationOptions = {}): ValidationResult {\n  if (value === null || value === undefined) {\n    if (options.allowNull) {\n      return { isValid: true, sanitizedValue: null };\n    }\n    return {\n      isValid: false,\n      error: 'JSON cannot be null',\n      errorCode: ValidationErrorCodes.NULL_NOT_ALLOWED,\n    };\n  }\n\n  // If already an object, validate it\n  if (typeof value === 'object') {\n    try {\n      // Sanitize the object\n      const sanitized = sanitizeJSON(value);\n      return {\n        isValid: true,\n        sanitizedValue: sanitized,\n      };\n    } catch (error) {\n      return {\n        isValid: false,\n        error: 'Invalid JSON structure',\n        errorCode: ValidationErrorCodes.INVALID_JSON,\n      };\n    }\n  }\n\n  // If string, try to parse it\n  if (typeof value === 'string') {\n    try {\n      const parsed = JSON.parse(value);\n      const sanitized = sanitizeJSON(parsed);\n      return {\n        isValid: true,\n        sanitizedValue: sanitized,\n      };\n    } catch (error) {\n      return {\n        isValid: false,\n        error: 'Invalid JSON format',\n        errorCode: ValidationErrorCodes.INVALID_JSON,\n      };\n    }\n  }\n\n  return {\n    isValid: false,\n    error: 'JSON must be an object or valid JSON string',\n    errorCode: ValidationErrorCodes.INVALID_TYPE,\n  };\n}\n\n/**\n * Validates a date string (ISO 8601 format)\n */\nexport function validateDate(value: any, options: ValidationOptions = {}): ValidationResult {\n  if (value === null || value === undefined) {\n    if (options.allowNull) {\n      return { isValid: true, sanitizedValue: null };\n    }\n    return {\n      isValid: false,\n      error: 'Date cannot be null',\n      errorCode: ValidationErrorCodes.NULL_NOT_ALLOWED,\n    };\n  }\n\n  if (typeof value !== 'string') {\n    return {\n      isValid: false,\n      error: 'Date must be a string',\n      errorCode: ValidationErrorCodes.INVALID_TYPE,\n    };\n  }\n\n  const trimmed = value.trim();\n\n  // Validate ISO date format\n  if (!PATTERNS.ISO_DATE.test(trimmed) && !PATTERNS.ISO_DATETIME.test(trimmed)) {\n    return {\n      isValid: false,\n      error: 'Invalid date format (use ISO 8601: YYYY-MM-DD or YYYY-MM-DDTHH:mm:ss.sssZ)',\n      errorCode: ValidationErrorCodes.INVALID_FORMAT,\n    };\n  }\n\n  // Validate that it's a valid date\n  const date = new Date(trimmed);\n  if (isNaN(date.getTime())) {\n    return {\n      isValid: false,\n      error: 'Invalid date value',\n      errorCode: ValidationErrorCodes.INVALID_VALUE,\n    };\n  }\n\n  return {\n    isValid: true,\n    sanitizedValue: trimmed,\n  };\n}\n\n/**\n * Validates an enum value against allowed values\n */\nexport function validateEnum<T extends string>(\n  value: any,\n  allowedValues: T[],\n  options: ValidationOptions = {}\n): ValidationResult {\n  if (value === null || value === undefined) {\n    if (options.allowNull) {\n      return { isValid: true, sanitizedValue: null };\n    }\n    return {\n      isValid: false,\n      error: 'Enum value cannot be null',\n      errorCode: ValidationErrorCodes.NULL_NOT_ALLOWED,\n    };\n  }\n\n  if (typeof value !== 'string') {\n    return {\n      isValid: false,\n      error: 'Enum value must be a string',\n      errorCode: ValidationErrorCodes.INVALID_TYPE,\n    };\n  }\n\n  const trimmed = value.trim();\n\n  if (!allowedValues.includes(trimmed as T)) {\n    return {\n      isValid: false,\n      error: `Value must be one of: ${allowedValues.join(', ')}`,\n      errorCode: ValidationErrorCodes.INVALID_VALUE,\n    };\n  }\n\n  return {\n    isValid: true,\n    sanitizedValue: trimmed,\n  };\n}\n\n/**\n * Validates and sanitizes a URL\n */\nexport function validateURL(value: any, options: ValidationOptions = {}): ValidationResult {\n  if (value === null || value === undefined) {\n    if (options.allowNull) {\n      return { isValid: true, sanitizedValue: null };\n    }\n    return {\n      isValid: false,\n      error: 'URL cannot be null',\n      errorCode: ValidationErrorCodes.NULL_NOT_ALLOWED,\n    };\n  }\n\n  if (typeof value !== 'string') {\n    return {\n      isValid: false,\n      error: 'URL must be a string',\n      errorCode: ValidationErrorCodes.INVALID_TYPE,\n    };\n  }\n\n  const trimmed = value.trim();\n\n  // Length check\n  if (trimmed.length === 0 || trimmed.length > 2048) {\n    return {\n      isValid: false,\n      error: 'URL length must be between 1 and 2048 characters',\n      errorCode: ValidationErrorCodes.INVALID_LENGTH,\n    };\n  }\n\n  // Format validation\n  if (!PATTERNS.URL.test(trimmed)) {\n    return {\n      isValid: false,\n      error: 'Invalid URL format',\n      errorCode: ValidationErrorCodes.INVALID_URL,\n    };\n  }\n\n  // Additional security checks\n  try {\n    const url = new URL(trimmed);\n\n    // Block dangerous protocols\n    if (!['http:', 'https:'].includes(url.protocol)) {\n      return {\n        isValid: false,\n        error: 'Only HTTP and HTTPS protocols are allowed',\n        errorCode: ValidationErrorCodes.INVALID_URL,\n      };\n    }\n\n    return {\n      isValid: true,\n      sanitizedValue: trimmed,\n    };\n  } catch (error) {\n    return {\n      isValid: false,\n      error: 'Invalid URL format',\n      errorCode: ValidationErrorCodes.INVALID_URL,\n    };\n  }\n}\n\n/**\n * Sanitizes a search query for full-text search\n * Prevents SQL injection and regex DOS attacks\n */\nexport function sanitizeSearchQuery(query: string, maxLength: number = 100): string {\n  if (!query || typeof query !== 'string') {\n    return '';\n  }\n\n  // Trim and limit length\n  let sanitized = query.trim().substring(0, maxLength);\n\n  // Remove SQL injection patterns\n  sanitized = sanitized\n    .replace(/[';\\\\]/g, '') // Remove quotes and backslashes\n    .replace(/--/g, '') // Remove SQL comments\n    .replace(/\\/\\*/g, '') // Remove block comments\n    .replace(/\\*\\//g, '')\n    .replace(/\\bOR\\b/gi, '') // Remove OR keyword\n    .replace(/\\bAND\\b/gi, '') // Remove AND keyword\n    .replace(/\\bUNION\\b/gi, '') // Remove UNION\n    .replace(/\\bSELECT\\b/gi, '') // Remove SELECT\n    .replace(/\\bDROP\\b/gi, '') // Remove DROP\n    .replace(/\\bDELETE\\b/gi, '') // Remove DELETE\n    .replace(/\\bINSERT\\b/gi, '') // Remove INSERT\n    .replace(/\\bUPDATE\\b/gi, ''); // Remove UPDATE\n\n  // Remove control characters\n  sanitized = sanitized.replace(/[\\x00-\\x1F\\x7F]/g, '');\n\n  // Escape regex special characters for safe pattern matching\n  sanitized = sanitized.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n  return sanitized;\n}\n\n/**\n * Escapes regex special characters to prevent ReDoS attacks\n */\nexport function escapeRegex(value: string): string {\n  if (typeof value !== 'string') {\n    return '';\n  }\n\n  // Escape all regex special characters\n  return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n/**\n * Validates a string input against a custom regex pattern\n */\nexport function validatePattern(\n  value: any,\n  pattern: RegExp,\n  errorMessage?: string,\n  options: ValidationOptions = {}\n): ValidationResult {\n  if (value === null || value === undefined) {\n    if (options.allowNull) {\n      return { isValid: true, sanitizedValue: null };\n    }\n    return {\n      isValid: false,\n      error: 'Value cannot be null',\n      errorCode: ValidationErrorCodes.NULL_NOT_ALLOWED,\n    };\n  }\n\n  if (typeof value !== 'string') {\n    return {\n      isValid: false,\n      error: 'Value must be a string',\n      errorCode: ValidationErrorCodes.INVALID_TYPE,\n    };\n  }\n\n  const trimmed = value.trim();\n\n  // Check length constraints if provided\n  const maxLength = options.maxLength || 10000;\n  const minLength = options.minLength || 0;\n\n  if (trimmed.length < minLength || trimmed.length > maxLength) {\n    return {\n      isValid: false,\n      error: `Length must be between ${minLength} and ${maxLength} characters`,\n      errorCode: ValidationErrorCodes.INVALID_LENGTH,\n    };\n  }\n\n  if (!pattern.test(trimmed)) {\n    return {\n      isValid: false,\n      error: errorMessage || 'Value does not match required pattern',\n      errorCode: ValidationErrorCodes.INVALID_FORMAT,\n    };\n  }\n\n  return {\n    isValid: true,\n    sanitizedValue: trimmed,\n  };\n}\n\n// ============================================================================\n// SANITIZATION FUNCTIONS\n// ============================================================================\n\n/**\n * Sanitizes text by escaping special characters\n */\nexport function sanitizeText(value: string): string {\n  return value\n    .replace(/'/g, \"''\")  // Escape single quotes for SQL\n    .replace(/\\\\/g, '\\\\\\\\')  // Escape backslashes\n    .replace(/\\0/g, '')  // Remove null bytes\n    .replace(/\\n/g, ' ')  // Replace newlines with spaces\n    .replace(/\\r/g, ' ')  // Replace carriage returns with spaces\n    .replace(/\\t/g, ' ')  // Replace tabs with spaces\n    .replace(/[\\x00-\\x1F\\x7F]/g, '');  // Remove control characters\n}\n\n/**\n * Sanitizes JSON data recursively\n */\nexport function sanitizeJSON(obj: any, depth: number = 0): any {\n  // Prevent deep recursion attacks\n  if (depth > 10) {\n    throw new Error('JSON nesting depth exceeded');\n  }\n\n  if (obj === null || obj === undefined) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(item => sanitizeJSON(item, depth + 1));\n  }\n\n  if (typeof obj === 'object') {\n    const sanitized: any = {};\n    for (const [key, value] of Object.entries(obj)) {\n      // Sanitize key\n      const sanitizedKey = sanitizeText(key);\n\n      // Sanitize value\n      if (typeof value === 'string') {\n        sanitized[sanitizedKey] = sanitizeText(value);\n      } else if (typeof value === 'object') {\n        sanitized[sanitizedKey] = sanitizeJSON(value, depth + 1);\n      } else {\n        sanitized[sanitizedKey] = value;\n      }\n    }\n    return sanitized;\n  }\n\n  if (typeof obj === 'string') {\n    return sanitizeText(obj);\n  }\n\n  return obj;\n}\n\n/**\n * Sanitizes an array of values\n */\nexport function sanitizeArray<T>(values: T[], validator: (value: T) => ValidationResult): T[] {\n  return values\n    .map(value => {\n      const result = validator(value);\n      return result.isValid ? result.sanitizedValue : null;\n    })\n    .filter(value => value !== null);\n}\n\n// ============================================================================\n// DETECTION FUNCTIONS\n// ============================================================================\n\n/**\n * Checks if a string contains SQL injection patterns\n */\nexport function containsSQLInjection(value: string): boolean {\n  return SQL_INJECTION_PATTERNS.some(pattern => pattern.test(value));\n}\n\n/**\n * Checks if a string contains XSS patterns\n */\nexport function containsXSS(value: string): boolean {\n  return XSS_PATTERNS.some(pattern => pattern.test(value));\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Validates multiple parameters at once\n */\nexport function validateParameters(\n  params: Record<string, any>,\n  validators: Record<string, (value: any, options?: ValidationOptions) => ValidationResult>\n): { isValid: boolean; sanitizedParams: Record<string, any>; errors: Record<string, string> } {\n  const sanitizedParams: Record<string, any> = {};\n  const errors: Record<string, string> = {};\n  let isValid = true;\n\n  for (const [key, value] of Object.entries(params)) {\n    const validator = validators[key];\n    if (!validator) {\n      // If no validator specified, pass through the value\n      sanitizedParams[key] = value;\n      continue;\n    }\n\n    const result = validator(value);\n    if (result.isValid) {\n      sanitizedParams[key] = result.sanitizedValue;\n    } else {\n      isValid = false;\n      errors[key] = result.error || 'Validation failed';\n    }\n  }\n\n  return { isValid, sanitizedParams, errors };\n}\n\n/**\n * Creates a validator function with default options\n */\nexport function createValidator(\n  validatorFn: (value: any, options: ValidationOptions) => ValidationResult,\n  defaultOptions: ValidationOptions = {}\n): (value: any) => ValidationResult {\n  return (value: any) => validatorFn(value, defaultOptions);\n}\n\n/**\n * Validates an object against a schema\n */\nexport interface ValidationSchema {\n  [key: string]: {\n    validator: (value: any, options?: ValidationOptions) => ValidationResult;\n    required?: boolean;\n    options?: ValidationOptions;\n  };\n}\n\nexport function validateSchema(\n  data: Record<string, any>,\n  schema: ValidationSchema\n): { isValid: boolean; sanitizedData: Record<string, any>; errors: Record<string, string> } {\n  const sanitizedData: Record<string, any> = {};\n  const errors: Record<string, string> = {};\n  let isValid = true;\n\n  // Check required fields\n  for (const [key, config] of Object.entries(schema)) {\n    const value = data[key];\n\n    if (config.required && (value === null || value === undefined)) {\n      isValid = false;\n      errors[key] = `${key} is required`;\n      continue;\n    }\n\n    if (value === undefined) {\n      continue; // Skip optional fields that aren't provided\n    }\n\n    const result = config.validator(value, config.options);\n    if (result.isValid) {\n      sanitizedData[key] = result.sanitizedValue;\n    } else {\n      isValid = false;\n      errors[key] = result.error || 'Validation failed';\n    }\n  }\n\n  return { isValid, sanitizedData, errors };\n}\n\n// ============================================================================\n// EXPORTS\n// ============================================================================\n\nexport const InputValidator = {\n  validateUUID,\n  validateEmail,\n  validatePhoneNumber,\n  validateText,\n  validateInteger,\n  validateJSON,\n  validateDate,\n  validateEnum,\n  validateURL,\n  validatePattern,\n  sanitizeText,\n  sanitizeJSON,\n  sanitizeArray,\n  sanitizeSearchQuery,\n  escapeRegex,\n  containsSQLInjection,\n  containsXSS,\n  validateParameters,\n  validateSchema,\n  createValidator,\n  ValidationErrorCodes,\n};\n\nexport default InputValidator;\n"],"names":["InputValidator","ValidationErrorCodes","containsSQLInjection","containsXSS","createValidator","escapeRegex","sanitizeArray","sanitizeJSON","sanitizeSearchQuery","sanitizeText","validateDate","validateEmail","validateEnum","validateInteger","validateJSON","validateParameters","validatePattern","validatePhoneNumber","validateSchema","validateText","validateURL","validateUUID","INVALID_TYPE","INVALID_FORMAT","INVALID_LENGTH","INVALID_VALUE","NULL_NOT_ALLOWED","SQL_INJECTION_DETECTED","XSS_DETECTED","INVALID_UUID","INVALID_EMAIL","INVALID_PHONE","INVALID_URL","INVALID_JSON","PATTERNS","UUID","EMAIL","PHONE","URL","ALPHANUMERIC_SAFE","SAFE_TEXT","INTEGER","DECIMAL","ISO_DATE","ISO_DATETIME","SQL_INJECTION_PATTERNS","XSS_PATTERNS","value","options","undefined","allowNull","isValid","sanitizedValue","error","errorCode","trimmed","trim","test","toLowerCase","length","cleaned","replace","maxLength","minLength","pattern","numValue","parseInt","Number","isInteger","isNaN","sanitized","parsed","JSON","parse","date","Date","getTime","allowedValues","includes","join","url","protocol","query","substring","errorMessage","obj","depth","Error","Array","isArray","map","item","key","Object","entries","sanitizedKey","values","validator","result","filter","some","params","validators","sanitizedParams","errors","validatorFn","defaultOptions","data","schema","sanitizedData","config","required"],"mappings":"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"}