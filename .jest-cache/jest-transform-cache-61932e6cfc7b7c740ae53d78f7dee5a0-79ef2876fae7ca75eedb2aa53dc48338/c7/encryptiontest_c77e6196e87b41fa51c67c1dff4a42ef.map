{"version":3,"sources":["C:\\Ai Projecten\\ADSapp\\tests\\unit\\crypto\\encryption.test.ts"],"sourcesContent":["/**\n * Encryption Library Unit Tests\n *\n * Tests for AES-256-GCM encryption and decryption functions.\n * Covers: encryption, decryption, IV randomness, key management, and error handling.\n *\n * @group unit\n * @group crypto\n * @group security\n */\n\nimport {\n  encrypt,\n  decrypt,\n  generateIV,\n  validateEncryptedData,\n  encryptBatch,\n  decryptBatch,\n  testEncryption,\n  getEncryptionStatus,\n  __testing__,\n} from '@/lib/crypto/encryption';\nimport * as crypto from 'crypto';\n\ndescribe('Encryption Library', () => {\n  // Set up encryption key for tests\n  beforeAll(() => {\n    // Generate a test encryption key (32 bytes for AES-256)\n    const testKey = crypto.randomBytes(32).toString('base64');\n    process.env.ENCRYPTION_KEY = testKey;\n  });\n\n  afterAll(() => {\n    delete process.env.ENCRYPTION_KEY;\n  });\n\n  // =========================================================================\n  // TEST 1: Encrypt produces different output each time (IV randomness)\n  // =========================================================================\n  describe('encrypt', () => {\n    it('should produce different encrypted output each time due to random IV', () => {\n      // Arrange\n      const plaintext = '+1234567890'; // Sample phone number\n\n      // Act\n      const encrypted1 = encrypt(plaintext);\n      const encrypted2 = encrypt(plaintext);\n      const encrypted3 = encrypt(plaintext);\n\n      // Assert\n      expect(encrypted1.encrypted).not.toBe(encrypted2.encrypted);\n      expect(encrypted2.encrypted).not.toBe(encrypted3.encrypted);\n      expect(encrypted1.encrypted).not.toBe(encrypted3.encrypted);\n\n      // Verify all have different IVs\n      expect(encrypted1.iv).not.toBe(encrypted2.iv);\n      expect(encrypted2.iv).not.toBe(encrypted3.iv);\n\n      // Verify all have same version and algorithm\n      expect(encrypted1.version).toBe(encrypted2.version);\n      expect(encrypted1.algorithm).toBe(encrypted2.algorithm);\n    });\n\n    it('should produce valid base64 encoded output', () => {\n      // Arrange\n      const plaintext = 'test-data-123';\n\n      // Act\n      const result = encrypt(plaintext);\n\n      // Assert\n      expect(() => Buffer.from(result.encrypted, 'base64')).not.toThrow();\n      expect(() => Buffer.from(result.iv, 'base64')).not.toThrow();\n      expect(() => Buffer.from(result.authTag, 'base64')).not.toThrow();\n    });\n\n    it('should include metadata in encryption result', () => {\n      // Arrange\n      const plaintext = 'sensitive data';\n\n      // Act\n      const result = encrypt(plaintext);\n\n      // Assert\n      expect(result).toHaveProperty('encrypted');\n      expect(result).toHaveProperty('version');\n      expect(result).toHaveProperty('algorithm');\n      expect(result).toHaveProperty('iv');\n      expect(result).toHaveProperty('authTag');\n      expect(typeof result.encrypted).toBe('string');\n      expect(result.version).toBe('v1');\n      expect(result.algorithm).toBe('aes-256-gcm');\n    });\n  });\n\n  // =========================================================================\n  // TEST 2: Decrypt returns original plaintext\n  // =========================================================================\n  describe('decrypt', () => {\n    it('should decrypt data back to original plaintext', () => {\n      // Arrange\n      const originalText = 'Hello, World! This is a test message.';\n\n      // Act\n      const encrypted = encrypt(originalText);\n      const decrypted = decrypt(encrypted.encrypted, encrypted.version);\n\n      // Assert\n      expect(decrypted.plaintext).toBe(originalText);\n      expect(decrypted.version).toBe(encrypted.version);\n      expect(decrypted.algorithm).toBe(encrypted.algorithm);\n    });\n\n    it('should successfully decrypt various data types as strings', () => {\n      // Arrange\n      const testCases = [\n        'Simple string',\n        'String with special chars: !@#$%^&*()',\n        '1234567890',\n        'email@example.com',\n        '+1-555-0123',\n        'Multi\\nLine\\nString',\n        'Unicode: ä½ å¥½ä¸–ç•Œ ðŸŒ',\n      ];\n\n      // Act & Assert\n      testCases.forEach((testCase) => {\n        const encrypted = encrypt(testCase);\n        const decrypted = decrypt(encrypted.encrypted, encrypted.version);\n        expect(decrypted.plaintext).toBe(testCase);\n      });\n    });\n  });\n\n  // =========================================================================\n  // TEST 3: Encryption with empty string\n  // =========================================================================\n  describe('Empty string encryption', () => {\n    it('should handle empty string encryption and decryption', () => {\n      // Arrange\n      const emptyString = '';\n\n      // Act\n      const encrypted = encrypt(emptyString);\n      const decrypted = decrypt(encrypted.encrypted, encrypted.version);\n\n      // Assert\n      expect(decrypted.plaintext).toBe(emptyString);\n      expect(encrypted.encrypted).toBeTruthy(); // Should still produce encrypted output\n    });\n\n    it('should produce different encrypted outputs for empty strings', () => {\n      // Arrange\n      const emptyString = '';\n\n      // Act\n      const encrypted1 = encrypt(emptyString);\n      const encrypted2 = encrypt(emptyString);\n\n      // Assert\n      expect(encrypted1.encrypted).not.toBe(encrypted2.encrypted);\n      expect(encrypted1.iv).not.toBe(encrypted2.iv);\n    });\n  });\n\n  // =========================================================================\n  // TEST 4: Encryption with long strings (>1MB)\n  // =========================================================================\n  describe('Long string encryption', () => {\n    it('should handle large data encryption (1MB)', () => {\n      // Arrange\n      const largeString = 'A'.repeat(1024 * 1024); // 1 MB string\n\n      // Act\n      const startTime = Date.now();\n      const encrypted = encrypt(largeString);\n      const encryptionTime = Date.now() - startTime;\n\n      const decrypted = decrypt(encrypted.encrypted, encrypted.version);\n      const totalTime = Date.now() - startTime;\n\n      // Assert\n      expect(decrypted.plaintext).toBe(largeString);\n      expect(decrypted.plaintext.length).toBe(1024 * 1024);\n\n      // Performance check - should complete within reasonable time\n      expect(encryptionTime).toBeLessThan(5000); // 5 seconds\n      expect(totalTime).toBeLessThan(10000); // 10 seconds total\n    }, 15000); // 15 second timeout\n\n    it('should handle moderately large data (100KB)', () => {\n      // Arrange\n      const mediumString = 'Test data with some variety! '.repeat(3500); // ~100KB\n\n      // Act\n      const encrypted = encrypt(mediumString);\n      const decrypted = decrypt(encrypted.encrypted, encrypted.version);\n\n      // Assert\n      expect(decrypted.plaintext).toBe(mediumString);\n      expect(decrypted.plaintext.length).toBeGreaterThan(100000);\n    });\n  });\n\n  // =========================================================================\n  // TEST 5: Decrypt with wrong key fails gracefully\n  // =========================================================================\n  describe('Error handling', () => {\n    it('should fail gracefully when decrypting with wrong key', () => {\n      // Arrange\n      const originalKey = process.env.ENCRYPTION_KEY;\n      const plaintext = 'secret message';\n\n      // Encrypt with original key\n      const encrypted = encrypt(plaintext);\n\n      // Change the key\n      const wrongKey = crypto.randomBytes(32).toString('base64');\n      process.env.ENCRYPTION_KEY = wrongKey;\n\n      // Act & Assert\n      expect(() => {\n        decrypt(encrypted.encrypted, encrypted.version);\n      }).toThrow();\n\n      // Restore original key\n      process.env.ENCRYPTION_KEY = originalKey;\n    });\n\n    it('should throw error for invalid encrypted data', () => {\n      // Arrange\n      const invalidData = 'not-valid-encrypted-data';\n\n      // Act & Assert\n      expect(() => {\n        decrypt(invalidData, 'v1');\n      }).toThrow();\n    });\n\n    it('should throw error for tampered encrypted data', () => {\n      // Arrange\n      const plaintext = 'important data';\n      const encrypted = encrypt(plaintext);\n\n      // Tamper with the encrypted data (flip a bit)\n      const tamperedData = Buffer.from(encrypted.encrypted, 'base64');\n      tamperedData[10] = tamperedData[10] ^ 0xFF; // Flip bits\n      const tamperedBase64 = tamperedData.toString('base64');\n\n      // Act & Assert\n      expect(() => {\n        decrypt(tamperedBase64, encrypted.version);\n      }).toThrow(); // Authentication tag verification should fail\n    });\n\n    it('should throw error when encryption key is missing', () => {\n      // Arrange\n      const originalKey = process.env.ENCRYPTION_KEY;\n      delete process.env.ENCRYPTION_KEY;\n\n      // Act & Assert\n      expect(() => {\n        encrypt('test');\n      }).toThrow(/ENCRYPTION_KEY/);\n\n      // Restore\n      process.env.ENCRYPTION_KEY = originalKey;\n    });\n  });\n\n  // =========================================================================\n  // BONUS TESTS\n  // =========================================================================\n  describe('Batch operations', () => {\n    it('should encrypt multiple values in batch', () => {\n      // Arrange\n      const values = ['value1', 'value2', 'value3', 'value4'];\n\n      // Act\n      const encrypted = encryptBatch(values);\n\n      // Assert\n      expect(encrypted).toHaveLength(4);\n      encrypted.forEach((result, index) => {\n        expect(result.encrypted).toBeTruthy();\n        expect(result.version).toBe('v1');\n\n        // Verify decryption\n        const decrypted = decrypt(result.encrypted, result.version);\n        expect(decrypted.plaintext).toBe(values[index]);\n      });\n    });\n\n    it('should decrypt multiple values in batch', () => {\n      // Arrange\n      const values = ['data1', 'data2', 'data3'];\n      const encrypted = encryptBatch(values);\n      const encryptedData = encrypted.map((e) => ({ data: e.encrypted, version: e.version }));\n\n      // Act\n      const decrypted = decryptBatch(encryptedData);\n\n      // Assert\n      expect(decrypted).toHaveLength(3);\n      decrypted.forEach((result, index) => {\n        expect(result.plaintext).toBe(values[index]);\n      });\n    });\n  });\n\n  describe('IV generation', () => {\n    it('should generate random IVs of correct length', () => {\n      // Act\n      const iv1 = generateIV();\n      const iv2 = generateIV();\n      const iv3 = generateIV();\n\n      // Assert\n      expect(iv1.length).toBe(12); // Default GCM IV length\n      expect(iv2.length).toBe(12);\n      expect(iv3.length).toBe(12);\n\n      // Verify randomness\n      expect(iv1).not.toEqual(iv2);\n      expect(iv2).not.toEqual(iv3);\n      expect(iv1).not.toEqual(iv3);\n    });\n\n    it('should generate IVs of custom length', () => {\n      // Act\n      const iv16 = generateIV(16);\n      const iv32 = generateIV(32);\n\n      // Assert\n      expect(iv16.length).toBe(16);\n      expect(iv32.length).toBe(32);\n    });\n  });\n\n  describe('Validation', () => {\n    it('should validate encrypted data structure', () => {\n      // Arrange\n      const plaintext = 'test validation';\n      const encrypted = encrypt(plaintext);\n\n      // Act\n      const validation = validateEncryptedData(encrypted.encrypted, encrypted.version);\n\n      // Assert\n      expect(validation.valid).toBe(true);\n      expect(validation.details?.hasVersion).toBe(true);\n      expect(validation.details?.hasEncrypted).toBe(true);\n      expect(validation.details?.isBase64).toBe(true);\n      expect(validation.details?.hasValidStructure).toBe(true);\n    });\n\n    it('should detect invalid encrypted data', () => {\n      // Act\n      const validation = validateEncryptedData('invalid', 'v1');\n\n      // Assert\n      expect(validation.valid).toBe(false);\n      expect(validation.error).toBeTruthy();\n    });\n  });\n\n  describe('System status', () => {\n    it('should report encryption system status', () => {\n      // Act\n      const status = getEncryptionStatus();\n\n      // Assert\n      expect(status.keyLoaded).toBe(true);\n      expect(status.version).toBe('v1');\n      expect(status.algorithm).toBe('aes-256-gcm');\n      expect(status.testPassed).toBe(true);\n    });\n\n    it('should successfully run encryption test', () => {\n      // Act\n      const result = testEncryption();\n\n      // Assert\n      expect(result).toBe(true);\n    });\n\n    it('should test encryption with custom data', () => {\n      // Arrange\n      const customData = 'custom-test-data-12345';\n\n      // Act\n      const result = testEncryption(customData);\n\n      // Assert\n      expect(result).toBe(true);\n    });\n  });\n});\n"],"names":["describe","beforeAll","testKey","crypto","randomBytes","toString","process","env","ENCRYPTION_KEY","afterAll","it","plaintext","encrypted1","encrypt","encrypted2","encrypted3","expect","encrypted","not","toBe","iv","version","algorithm","result","Buffer","from","toThrow","authTag","toHaveProperty","originalText","decrypted","decrypt","testCases","forEach","testCase","emptyString","toBeTruthy","largeString","repeat","startTime","Date","now","encryptionTime","totalTime","length","toBeLessThan","mediumString","toBeGreaterThan","originalKey","wrongKey","invalidData","tamperedData","tamperedBase64","values","encryptBatch","toHaveLength","index","encryptedData","map","e","data","decryptBatch","iv1","generateIV","iv2","iv3","toEqual","iv16","iv32","validation","validateEncryptedData","valid","details","hasVersion","hasEncrypted","isBase64","hasValidStructure","error","status","getEncryptionStatus","keyLoaded","testPassed","testEncryption","customData"],"mappings":"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"}