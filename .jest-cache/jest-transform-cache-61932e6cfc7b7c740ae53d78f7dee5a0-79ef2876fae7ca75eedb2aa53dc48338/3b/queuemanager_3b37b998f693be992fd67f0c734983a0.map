{"version":3,"sources":["C:\\Ai Projecten\\ADSapp\\src\\lib\\queue\\queue-manager.ts"],"sourcesContent":["import { Queue, Worker, QueueEvents, Job } from 'bullmq';\nimport {\n  createQueue,\n  createWorker,\n  createQueueEvents,\n  QueueName,\n  JobPriority,\n  getQueueStats,\n  gracefulShutdown\n} from './bull-config';\nimport { processBulkMessage } from './processors/bulk-message-processor';\nimport { processContactImport } from './processors/contact-import-processor';\nimport { processTemplate } from './processors/template-processor';\nimport { processEmailNotification } from './processors/email-notification-processor';\n\n/**\n * Queue Manager\n *\n * Centralized management for all BullMQ queues and workers.\n * Handles job creation, cancellation, monitoring, and lifecycle management.\n *\n * Features:\n * - Centralized queue management\n * - Worker lifecycle management\n * - Job creation with priority\n * - Job cancellation and retry\n * - Queue monitoring and statistics\n * - Graceful shutdown handling\n *\n * @module queue-manager\n */\n\n/**\n * Job creation options\n */\nexport interface CreateJobOptions {\n  priority?: JobPriority;\n  delay?: number; // Delay in milliseconds\n  attempts?: number;\n  backoff?: {\n    type: 'exponential' | 'fixed';\n    delay: number;\n  };\n  removeOnComplete?: boolean | number;\n  removeOnFail?: boolean | number;\n}\n\n/**\n * Job information\n */\nexport interface JobInfo {\n  id: string;\n  name: string;\n  queueName: string;\n  data: any;\n  progress: number | object;\n  attemptsMade: number;\n  attemptsTotal: number;\n  delay: number;\n  timestamp: number;\n  processedOn?: number;\n  finishedOn?: number;\n  failedReason?: string;\n  stacktrace?: string[];\n  returnValue?: any;\n  state: 'waiting' | 'active' | 'completed' | 'failed' | 'delayed' | 'paused';\n}\n\n/**\n * Queue Manager Class\n */\nexport class QueueManager {\n  private queues: Map<QueueName, Queue>;\n  private workers: Map<QueueName, Worker>;\n  private queueEvents: Map<QueueName, QueueEvents>;\n  private isShuttingDown: boolean = false;\n\n  constructor() {\n    this.queues = new Map();\n    this.workers = new Map();\n    this.queueEvents = new Map();\n  }\n\n  /**\n   * Initialize all queues and workers\n   */\n  async initialize(): Promise<void> {\n    console.log('[QueueManager] Initializing queues and workers...');\n\n    try {\n      // Initialize bulk message queue\n      await this.initializeQueue(QueueName.BULK_MESSAGE, processBulkMessage);\n\n      // Initialize contact import queue\n      await this.initializeQueue(\n        QueueName.CONTACT_IMPORT,\n        processContactImport\n      );\n\n      // Initialize template processing queue\n      await this.initializeQueue(\n        QueueName.TEMPLATE_PROCESSING,\n        processTemplate\n      );\n\n      // Initialize email notification queue\n      await this.initializeQueue(\n        QueueName.EMAIL_NOTIFICATION,\n        processEmailNotification\n      );\n\n      console.log('[QueueManager] All queues and workers initialized');\n    } catch (error) {\n      console.error('[QueueManager] Initialization error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize a single queue with its worker\n   */\n  private async initializeQueue(\n    queueName: QueueName,\n    processor: (job: Job) => Promise<any>\n  ): Promise<void> {\n    try {\n      // Create queue\n      const queue = createQueue(queueName);\n      this.queues.set(queueName, queue);\n\n      // Create worker\n      const worker = createWorker(queueName, processor);\n      this.workers.set(queueName, worker);\n\n      // Create queue events\n      const queueEvents = createQueueEvents(queueName);\n      this.queueEvents.set(queueName, queueEvents);\n\n      console.log(`[QueueManager] Initialized ${queueName}`);\n    } catch (error) {\n      console.error(`[QueueManager] Error initializing ${queueName}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get queue by name\n   */\n  getQueue(queueName: QueueName): Queue | undefined {\n    return this.queues.get(queueName);\n  }\n\n  /**\n   * Add a job to a queue\n   */\n  async addJob(\n    queueName: QueueName,\n    jobName: string,\n    data: any,\n    options?: CreateJobOptions\n  ): Promise<string> {\n    const queue = this.queues.get(queueName);\n\n    if (!queue) {\n      throw new Error(`Queue ${queueName} not initialized`);\n    }\n\n    const job = await queue.add(jobName, data, {\n      priority: options?.priority || JobPriority.NORMAL,\n      delay: options?.delay,\n      attempts: options?.attempts,\n      backoff: options?.backoff,\n      removeOnComplete: options?.removeOnComplete,\n      removeOnFail: options?.removeOnFail\n    });\n\n    console.log(`[QueueManager] Job ${job.id} added to ${queueName}`);\n\n    return job.id?.toString() || '';\n  }\n\n  /**\n   * Get job by ID\n   */\n  async getJob(queueName: QueueName, jobId: string): Promise<JobInfo | null> {\n    const queue = this.queues.get(queueName);\n\n    if (!queue) {\n      throw new Error(`Queue ${queueName} not initialized`);\n    }\n\n    const job = await queue.getJob(jobId);\n\n    if (!job) {\n      return null;\n    }\n\n    const state = await job.getState();\n\n    return {\n      id: job.id?.toString() || '',\n      name: job.name,\n      queueName: queue.name,\n      data: job.data,\n      progress: job.progress,\n      attemptsMade: job.attemptsMade,\n      attemptsTotal: job.opts.attempts || 0,\n      delay: job.opts.delay || 0,\n      timestamp: job.timestamp,\n      processedOn: job.processedOn,\n      finishedOn: job.finishedOn,\n      failedReason: job.failedReason,\n      stacktrace: job.stacktrace,\n      returnValue: job.returnvalue,\n      state: state as any\n    };\n  }\n\n  /**\n   * Cancel a job\n   */\n  async cancelJob(queueName: QueueName, jobId: string): Promise<boolean> {\n    const queue = this.queues.get(queueName);\n\n    if (!queue) {\n      throw new Error(`Queue ${queueName} not initialized`);\n    }\n\n    const job = await queue.getJob(jobId);\n\n    if (!job) {\n      return false;\n    }\n\n    await job.remove();\n\n    console.log(`[QueueManager] Job ${jobId} cancelled from ${queueName}`);\n\n    return true;\n  }\n\n  /**\n   * Retry a failed job\n   */\n  async retryJob(queueName: QueueName, jobId: string): Promise<boolean> {\n    const queue = this.queues.get(queueName);\n\n    if (!queue) {\n      throw new Error(`Queue ${queueName} not initialized`);\n    }\n\n    const job = await queue.getJob(jobId);\n\n    if (!job) {\n      return false;\n    }\n\n    await job.retry();\n\n    console.log(`[QueueManager] Job ${jobId} retried in ${queueName}`);\n\n    return true;\n  }\n\n  /**\n   * Get queue statistics\n   */\n  async getQueueStatistics(queueName: QueueName) {\n    const queue = this.queues.get(queueName);\n\n    if (!queue) {\n      throw new Error(`Queue ${queueName} not initialized`);\n    }\n\n    return await getQueueStats(queue);\n  }\n\n  /**\n   * Get all queue statistics\n   */\n  async getAllQueueStatistics() {\n    const stats: Record<string, any> = {};\n\n    for (const [queueName, queue] of this.queues) {\n      stats[queueName] = await getQueueStats(queue);\n    }\n\n    return stats;\n  }\n\n  /**\n   * Pause a queue\n   */\n  async pauseQueue(queueName: QueueName): Promise<void> {\n    const queue = this.queues.get(queueName);\n\n    if (!queue) {\n      throw new Error(`Queue ${queueName} not initialized`);\n    }\n\n    await queue.pause();\n\n    console.log(`[QueueManager] Queue ${queueName} paused`);\n  }\n\n  /**\n   * Resume a queue\n   */\n  async resumeQueue(queueName: QueueName): Promise<void> {\n    const queue = this.queues.get(queueName);\n\n    if (!queue) {\n      throw new Error(`Queue ${queueName} not initialized`);\n    }\n\n    await queue.resume();\n\n    console.log(`[QueueManager] Queue ${queueName} resumed`);\n  }\n\n  /**\n   * Get failed jobs\n   */\n  async getFailedJobs(\n    queueName: QueueName,\n    start: number = 0,\n    end: number = 10\n  ): Promise<JobInfo[]> {\n    const queue = this.queues.get(queueName);\n\n    if (!queue) {\n      throw new Error(`Queue ${queueName} not initialized`);\n    }\n\n    const failedJobs = await queue.getFailed(start, end);\n\n    return Promise.all(\n      failedJobs.map(async (job) => {\n        const state = await job.getState();\n\n        return {\n          id: job.id?.toString() || '',\n          name: job.name,\n          queueName: queue.name,\n          data: job.data,\n          progress: job.progress,\n          attemptsMade: job.attemptsMade,\n          attemptsTotal: job.opts.attempts || 0,\n          delay: job.opts.delay || 0,\n          timestamp: job.timestamp,\n          processedOn: job.processedOn,\n          finishedOn: job.finishedOn,\n          failedReason: job.failedReason,\n          stacktrace: job.stacktrace,\n          returnValue: job.returnvalue,\n          state: state as any\n        };\n      })\n    );\n  }\n\n  /**\n   * Clean completed jobs\n   */\n  async cleanCompletedJobs(\n    queueName: QueueName,\n    grace: number = 3600000\n  ): Promise<string[]> {\n    const queue = this.queues.get(queueName);\n\n    if (!queue) {\n      throw new Error(`Queue ${queueName} not initialized`);\n    }\n\n    const cleaned = await queue.clean(grace, 1000, 'completed');\n\n    console.log(\n      `[QueueManager] Cleaned ${cleaned.length} completed jobs from ${queueName}`\n    );\n\n    return cleaned;\n  }\n\n  /**\n   * Clean failed jobs\n   */\n  async cleanFailedJobs(\n    queueName: QueueName,\n    grace: number = 86400000\n  ): Promise<string[]> {\n    const queue = this.queues.get(queueName);\n\n    if (!queue) {\n      throw new Error(`Queue ${queueName} not initialized`);\n    }\n\n    const cleaned = await queue.clean(grace, 1000, 'failed');\n\n    console.log(\n      `[QueueManager] Cleaned ${cleaned.length} failed jobs from ${queueName}`\n    );\n\n    return cleaned;\n  }\n\n  /**\n   * Graceful shutdown of all queues and workers\n   */\n  async shutdown(): Promise<void> {\n    if (this.isShuttingDown) {\n      console.log('[QueueManager] Shutdown already in progress');\n      return;\n    }\n\n    this.isShuttingDown = true;\n\n    console.log('[QueueManager] Starting graceful shutdown...');\n\n    const shutdownPromises: Promise<void>[] = [];\n\n    for (const [queueName, queue] of this.queues) {\n      const worker = this.workers.get(queueName);\n      const queueEvents = this.queueEvents.get(queueName);\n\n      if (worker && queueEvents) {\n        shutdownPromises.push(gracefulShutdown(queue, worker, queueEvents));\n      }\n    }\n\n    await Promise.all(shutdownPromises);\n\n    this.queues.clear();\n    this.workers.clear();\n    this.queueEvents.clear();\n\n    console.log('[QueueManager] Graceful shutdown complete');\n  }\n\n  /**\n   * Health check for all queues\n   */\n  async healthCheck(): Promise<{\n    healthy: boolean;\n    queues: Record<string, any>;\n  }> {\n    const queueHealth: Record<string, any> = {};\n    let allHealthy = true;\n\n    for (const [queueName, queue] of this.queues) {\n      try {\n        const stats = await getQueueStats(queue);\n        queueHealth[queueName] = {\n          healthy: true,\n          stats\n        };\n      } catch (error) {\n        allHealthy = false;\n        queueHealth[queueName] = {\n          healthy: false,\n          error: error instanceof Error ? error.message : 'Unknown error'\n        };\n      }\n    }\n\n    return {\n      healthy: allHealthy,\n      queues: queueHealth\n    };\n  }\n}\n\n/**\n * Singleton instance\n */\nlet queueManagerInstance: QueueManager | null = null;\n\n/**\n * Get queue manager instance\n */\nexport function getQueueManager(): QueueManager {\n  if (!queueManagerInstance) {\n    queueManagerInstance = new QueueManager();\n  }\n\n  return queueManagerInstance;\n}\n\n/**\n * Initialize queue manager (call once at application startup)\n */\nexport async function initializeQueueManager(): Promise<QueueManager> {\n  const manager = getQueueManager();\n  await manager.initialize();\n  return manager;\n}\n"],"names":["QueueManager","getQueueManager","initializeQueueManager","isShuttingDown","queues","Map","workers","queueEvents","initialize","console","log","initializeQueue","QueueName","BULK_MESSAGE","processBulkMessage","CONTACT_IMPORT","processContactImport","TEMPLATE_PROCESSING","processTemplate","EMAIL_NOTIFICATION","processEmailNotification","error","queueName","processor","queue","createQueue","set","worker","createWorker","createQueueEvents","getQueue","get","addJob","jobName","data","options","Error","job","add","priority","JobPriority","NORMAL","delay","attempts","backoff","removeOnComplete","removeOnFail","id","toString","getJob","jobId","state","getState","name","progress","attemptsMade","attemptsTotal","opts","timestamp","processedOn","finishedOn","failedReason","stacktrace","returnValue","returnvalue","cancelJob","remove","retryJob","retry","getQueueStatistics","getQueueStats","getAllQueueStatistics","stats","pauseQueue","pause","resumeQueue","resume","getFailedJobs","start","end","failedJobs","getFailed","Promise","all","map","cleanCompletedJobs","grace","cleaned","clean","length","cleanFailedJobs","shutdown","shutdownPromises","push","gracefulShutdown","clear","healthCheck","queueHealth","allHealthy","healthy","message","queueManagerInstance","manager"],"mappings":"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"}