21134d1f8e97dda81e574c5d9cab25d5
/**
 * KMS Client Unit Tests
 *
 * Tests for AWS KMS integration and encryption key management
 */ "use strict";
// Mock AWS SDK
jest.mock('@aws-sdk/client-kms', ()=>({
        KMSClient: jest.fn().mockImplementation(()=>({
                send: jest.fn(),
                destroy: jest.fn()
            })),
        GenerateDataKeyCommand: jest.fn(),
        DecryptCommand: jest.fn(),
        EncryptCommand: jest.fn(),
        DescribeKeyCommand: jest.fn(),
        KMSServiceException: class KMSServiceException extends Error {
            constructor(message){
                super(message);
                this.name = 'KMSServiceException';
            }
        }
    }));
jest.mock('@aws-sdk/credential-providers', ()=>({
        fromEnv: jest.fn(()=>({
                accessKeyId: 'test-access-key',
                secretAccessKey: 'test-secret-key'
            }))
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _kmsclient = require("../../src/lib/security/kms-client");
const _types = require("../../src/lib/crypto/types");
describe('KMSClient', ()=>{
    let kmsClient;
    beforeEach(()=>{
        // Set environment variables
        process.env.AWS_REGION = 'us-east-1';
        process.env.AWS_KMS_KEY_ID = '12345678-1234-1234-1234-123456789012';
        process.env.AWS_ACCESS_KEY_ID = 'test-access-key';
        process.env.AWS_SECRET_ACCESS_KEY = 'test-secret-key';
        (0, _kmsclient.resetKMSClient)();
    });
    afterEach(()=>{
        jest.clearAllMocks();
        (0, _kmsclient.resetKMSClient)();
    });
    describe('Configuration', ()=>{
        it('should load configuration from environment variables', ()=>{
            expect(()=>new _kmsclient.KMSClient()).not.toThrow();
        });
        it('should accept custom configuration', ()=>{
            const config = {
                region: 'us-west-2',
                keyId: 'custom-key-id',
                maxRetries: 5
            };
            expect(()=>new _kmsclient.KMSClient(config)).not.toThrow();
        });
        it('should throw error if AWS_KMS_KEY_ID is missing', ()=>{
            delete process.env.AWS_KMS_KEY_ID;
            expect(()=>new _kmsclient.KMSClient()).toThrow(_types.KeyManagementError);
            expect(()=>new _kmsclient.KMSClient()).toThrow('AWS_KMS_KEY_ID is required');
        });
        it('should validate key ID format', ()=>{
            process.env.AWS_KMS_KEY_ID = 'invalid-key-format';
            expect(()=>new _kmsclient.KMSClient()).toThrow(_types.KeyManagementError);
            expect(()=>new _kmsclient.KMSClient()).toThrow('Invalid KMS Key ID format');
        });
        it('should accept ARN format key ID', ()=>{
            process.env.AWS_KMS_KEY_ID = 'arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012';
            expect(()=>new _kmsclient.KMSClient()).not.toThrow();
        });
        it('should accept alias format key ID', ()=>{
            process.env.AWS_KMS_KEY_ID = 'alias/my-key';
            expect(()=>new _kmsclient.KMSClient()).not.toThrow();
        });
    });
    describe('generateDataKey', ()=>{
        it('should generate a data key for a tenant', async ()=>{
            const mockSend = jest.fn().mockResolvedValue({
                CiphertextBlob: Buffer.from('encrypted-key'),
                Plaintext: Buffer.from('a'.repeat(32)),
                KeyId: process.env.AWS_KMS_KEY_ID
            });
            const { KMSClient: MockKMSClient } = require('@aws-sdk/client-kms');
            MockKMSClient.mockImplementation(()=>({
                    send: mockSend,
                    destroy: jest.fn()
                }));
            kmsClient = new _kmsclient.KMSClient();
            const result = await kmsClient.generateDataKey('tenant-123');
            expect(result).toHaveProperty('ciphertext');
            expect(result).toHaveProperty('plaintext');
            expect(result).toHaveProperty('keyId');
            expect(result.plaintext).toBeInstanceOf(Buffer);
            expect(result.plaintext.length).toBe(32);
            expect(mockSend).toHaveBeenCalledTimes(1);
        });
        it('should include encryption context with tenant ID', async ()=>{
            const mockSend = jest.fn().mockResolvedValue({
                CiphertextBlob: Buffer.from('encrypted-key'),
                Plaintext: Buffer.from('a'.repeat(32)),
                KeyId: process.env.AWS_KMS_KEY_ID
            });
            const { KMSClient: MockKMSClient } = require('@aws-sdk/client-kms');
            MockKMSClient.mockImplementation(()=>({
                    send: mockSend,
                    destroy: jest.fn()
                }));
            kmsClient = new _kmsclient.KMSClient();
            await kmsClient.generateDataKey('tenant-123');
            const callArgs = mockSend.mock.calls[0][0];
            expect(callArgs.input.EncryptionContext).toHaveProperty('TenantId', 'tenant-123');
        });
        it('should cache the generated key', async ()=>{
            const mockSend = jest.fn().mockResolvedValue({
                CiphertextBlob: Buffer.from('encrypted-key'),
                Plaintext: Buffer.from('a'.repeat(32)),
                KeyId: process.env.AWS_KMS_KEY_ID
            });
            const { KMSClient: MockKMSClient } = require('@aws-sdk/client-kms');
            MockKMSClient.mockImplementation(()=>({
                    send: mockSend,
                    destroy: jest.fn()
                }));
            kmsClient = new _kmsclient.KMSClient();
            await kmsClient.generateDataKey('tenant-123');
            // Call decryptDataKey to verify cache
            await kmsClient.decryptDataKey('encrypted-key', 'tenant-123');
            // Should only call generateDataKey once, decrypt should use cache
            expect(mockSend).toHaveBeenCalledTimes(1);
        });
        it('should handle KMS errors gracefully', async ()=>{
            const mockSend = jest.fn().mockRejectedValue(new Error('KMS service unavailable'));
            const { KMSClient: MockKMSClient } = require('@aws-sdk/client-kms');
            MockKMSClient.mockImplementation(()=>({
                    send: mockSend,
                    destroy: jest.fn()
                }));
            kmsClient = new _kmsclient.KMSClient();
            await expect(kmsClient.generateDataKey('tenant-123')).rejects.toThrow(_types.KeyManagementError);
        });
    });
    describe('decryptDataKey', ()=>{
        it('should decrypt a data key', async ()=>{
            const mockSend = jest.fn().mockResolvedValue({
                Plaintext: Buffer.from('b'.repeat(32)),
                KeyId: process.env.AWS_KMS_KEY_ID
            });
            const { KMSClient: MockKMSClient } = require('@aws-sdk/client-kms');
            MockKMSClient.mockImplementation(()=>({
                    send: mockSend,
                    destroy: jest.fn()
                }));
            kmsClient = new _kmsclient.KMSClient();
            const result = await kmsClient.decryptDataKey(Buffer.from('encrypted-key').toString('base64'), 'tenant-123');
            expect(result).toHaveProperty('plaintext');
            expect(result).toHaveProperty('keyId');
            expect(result.plaintext).toBeInstanceOf(Buffer);
            expect(result.plaintext.length).toBe(32);
            expect(mockSend).toHaveBeenCalledTimes(1);
        });
        it('should return cached key if available', async ()=>{
            const mockSend = jest.fn().mockResolvedValue({
                Plaintext: Buffer.from('c'.repeat(32)),
                KeyId: process.env.AWS_KMS_KEY_ID
            });
            const { KMSClient: MockKMSClient } = require('@aws-sdk/client-kms');
            MockKMSClient.mockImplementation(()=>({
                    send: mockSend,
                    destroy: jest.fn()
                }));
            kmsClient = new _kmsclient.KMSClient();
            // First call - should hit KMS
            await kmsClient.decryptDataKey('encrypted-key', 'tenant-123');
            // Second call - should use cache
            await kmsClient.decryptDataKey('encrypted-key', 'tenant-123');
            expect(mockSend).toHaveBeenCalledTimes(1); // Only one KMS call
        });
        it('should include encryption context for tenant validation', async ()=>{
            const mockSend = jest.fn().mockResolvedValue({
                Plaintext: Buffer.from('d'.repeat(32)),
                KeyId: process.env.AWS_KMS_KEY_ID
            });
            const { KMSClient: MockKMSClient } = require('@aws-sdk/client-kms');
            MockKMSClient.mockImplementation(()=>({
                    send: mockSend,
                    destroy: jest.fn()
                }));
            kmsClient = new _kmsclient.KMSClient();
            await kmsClient.decryptDataKey('encrypted-key', 'tenant-456');
            const callArgs = mockSend.mock.calls[0][0];
            expect(callArgs.input.EncryptionContext).toHaveProperty('TenantId', 'tenant-456');
        });
    });
    describe('Cache Management', ()=>{
        it('should clear cache for specific tenant', async ()=>{
            const mockSend = jest.fn().mockResolvedValue({
                Plaintext: Buffer.from('e'.repeat(32)),
                KeyId: process.env.AWS_KMS_KEY_ID
            });
            const { KMSClient: MockKMSClient } = require('@aws-sdk/client-kms');
            MockKMSClient.mockImplementation(()=>({
                    send: mockSend,
                    destroy: jest.fn()
                }));
            kmsClient = new _kmsclient.KMSClient();
            // Cache a key
            await kmsClient.decryptDataKey('encrypted-key', 'tenant-123');
            // Clear cache
            kmsClient.clearCache('tenant-123');
            // Should call KMS again
            await kmsClient.decryptDataKey('encrypted-key', 'tenant-123');
            expect(mockSend).toHaveBeenCalledTimes(2);
        });
        it('should clear all caches when no tenant specified', async ()=>{
            const mockSend = jest.fn().mockResolvedValue({
                Plaintext: Buffer.from('f'.repeat(32)),
                KeyId: process.env.AWS_KMS_KEY_ID
            });
            const { KMSClient: MockKMSClient } = require('@aws-sdk/client-kms');
            MockKMSClient.mockImplementation(()=>({
                    send: mockSend,
                    destroy: jest.fn()
                }));
            kmsClient = new _kmsclient.KMSClient();
            // Cache keys for multiple tenants
            await kmsClient.decryptDataKey('encrypted-key-1', 'tenant-1');
            await kmsClient.decryptDataKey('encrypted-key-2', 'tenant-2');
            // Clear all caches
            kmsClient.clearCache();
            // Should call KMS again for both
            await kmsClient.decryptDataKey('encrypted-key-1', 'tenant-1');
            await kmsClient.decryptDataKey('encrypted-key-2', 'tenant-2');
            expect(mockSend).toHaveBeenCalledTimes(4); // 2 initial + 2 after clear
        });
    });
    describe('Statistics', ()=>{
        it('should track operation statistics', async ()=>{
            const mockSend = jest.fn().mockResolvedValue({
                Plaintext: Buffer.from('g'.repeat(32)),
                KeyId: process.env.AWS_KMS_KEY_ID
            });
            const { KMSClient: MockKMSClient } = require('@aws-sdk/client-kms');
            MockKMSClient.mockImplementation(()=>({
                    send: mockSend,
                    destroy: jest.fn()
                }));
            kmsClient = new _kmsclient.KMSClient();
            await kmsClient.decryptDataKey('encrypted-key', 'tenant-123');
            const stats = kmsClient.getStats();
            expect(stats.totalOperations).toBe(1);
            expect(stats.successful).toBe(1);
            expect(stats.failed).toBe(0);
        });
        it('should reset statistics', async ()=>{
            const mockSend = jest.fn().mockResolvedValue({
                Plaintext: Buffer.from('h'.repeat(32)),
                KeyId: process.env.AWS_KMS_KEY_ID
            });
            const { KMSClient: MockKMSClient } = require('@aws-sdk/client-kms');
            MockKMSClient.mockImplementation(()=>({
                    send: mockSend,
                    destroy: jest.fn()
                }));
            kmsClient = new _kmsclient.KMSClient();
            await kmsClient.decryptDataKey('encrypted-key', 'tenant-123');
            kmsClient.resetStats();
            const stats = kmsClient.getStats();
            expect(stats.totalOperations).toBe(0);
            expect(stats.successful).toBe(0);
        });
    });
    describe('Connection Test', ()=>{
        it('should test KMS connectivity successfully', async ()=>{
            const mockSend = jest.fn().mockResolvedValue({
                KeyMetadata: {
                    KeyId: process.env.AWS_KMS_KEY_ID,
                    Arn: `arn:aws:kms:us-east-1:123456789012:key/${process.env.AWS_KMS_KEY_ID}`,
                    KeyState: 'Enabled',
                    CreationDate: new Date()
                }
            });
            const { KMSClient: MockKMSClient } = require('@aws-sdk/client-kms');
            MockKMSClient.mockImplementation(()=>({
                    send: mockSend,
                    destroy: jest.fn()
                }));
            kmsClient = new _kmsclient.KMSClient();
            const result = await kmsClient.testConnection();
            expect(result).toBe(true);
        });
        it('should return false on connection failure', async ()=>{
            const mockSend = jest.fn().mockRejectedValue(new Error('Connection failed'));
            const { KMSClient: MockKMSClient } = require('@aws-sdk/client-kms');
            MockKMSClient.mockImplementation(()=>({
                    send: mockSend,
                    destroy: jest.fn()
                }));
            kmsClient = new _kmsclient.KMSClient();
            const result = await kmsClient.testConnection();
            expect(result).toBe(false);
        });
    });
    describe('Singleton', ()=>{
        it('should return same instance for getKMSClient', ()=>{
            const instance1 = (0, _kmsclient.getKMSClient)();
            const instance2 = (0, _kmsclient.getKMSClient)();
            expect(instance1).toBe(instance2);
        });
        it('should create new instance after reset', ()=>{
            const instance1 = (0, _kmsclient.getKMSClient)();
            (0, _kmsclient.resetKMSClient)();
            const instance2 = (0, _kmsclient.getKMSClient)();
            expect(instance1).not.toBe(instance2);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxBaSBQcm9qZWN0ZW5cXEFEU2FwcFxcdGVzdHNcXHVuaXRcXGttcy1jbGllbnQudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEtNUyBDbGllbnQgVW5pdCBUZXN0c1xuICpcbiAqIFRlc3RzIGZvciBBV1MgS01TIGludGVncmF0aW9uIGFuZCBlbmNyeXB0aW9uIGtleSBtYW5hZ2VtZW50XG4gKi9cblxuaW1wb3J0IHsgS01TQ2xpZW50LCBnZXRLTVNDbGllbnQsIHJlc2V0S01TQ2xpZW50IH0gZnJvbSAnQC9saWIvc2VjdXJpdHkva21zLWNsaWVudCc7XG5pbXBvcnQgeyBLZXlNYW5hZ2VtZW50RXJyb3IgfSBmcm9tICdAL2xpYi9jcnlwdG8vdHlwZXMnO1xuXG4vLyBNb2NrIEFXUyBTREtcbmplc3QubW9jaygnQGF3cy1zZGsvY2xpZW50LWttcycsICgpID0+ICh7XG4gIEtNU0NsaWVudDogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAoe1xuICAgIHNlbmQ6IGplc3QuZm4oKSxcbiAgICBkZXN0cm95OiBqZXN0LmZuKCksXG4gIH0pKSxcbiAgR2VuZXJhdGVEYXRhS2V5Q29tbWFuZDogamVzdC5mbigpLFxuICBEZWNyeXB0Q29tbWFuZDogamVzdC5mbigpLFxuICBFbmNyeXB0Q29tbWFuZDogamVzdC5mbigpLFxuICBEZXNjcmliZUtleUNvbW1hbmQ6IGplc3QuZm4oKSxcbiAgS01TU2VydmljZUV4Y2VwdGlvbjogY2xhc3MgS01TU2VydmljZUV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5uYW1lID0gJ0tNU1NlcnZpY2VFeGNlcHRpb24nO1xuICAgIH1cbiAgfSxcbn0pKTtcblxuamVzdC5tb2NrKCdAYXdzLXNkay9jcmVkZW50aWFsLXByb3ZpZGVycycsICgpID0+ICh7XG4gIGZyb21FbnY6IGplc3QuZm4oKCkgPT4gKHtcbiAgICBhY2Nlc3NLZXlJZDogJ3Rlc3QtYWNjZXNzLWtleScsXG4gICAgc2VjcmV0QWNjZXNzS2V5OiAndGVzdC1zZWNyZXQta2V5JyxcbiAgfSkpLFxufSkpO1xuXG5kZXNjcmliZSgnS01TQ2xpZW50JywgKCkgPT4ge1xuICBsZXQga21zQ2xpZW50OiBLTVNDbGllbnQ7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgLy8gU2V0IGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIHByb2Nlc3MuZW52LkFXU19SRUdJT04gPSAndXMtZWFzdC0xJztcbiAgICBwcm9jZXNzLmVudi5BV1NfS01TX0tFWV9JRCA9ICcxMjM0NTY3OC0xMjM0LTEyMzQtMTIzNC0xMjM0NTY3ODkwMTInO1xuICAgIHByb2Nlc3MuZW52LkFXU19BQ0NFU1NfS0VZX0lEID0gJ3Rlc3QtYWNjZXNzLWtleSc7XG4gICAgcHJvY2Vzcy5lbnYuQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZID0gJ3Rlc3Qtc2VjcmV0LWtleSc7XG5cbiAgICByZXNldEtNU0NsaWVudCgpO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIHJlc2V0S01TQ2xpZW50KCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb25maWd1cmF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbG9hZCBjb25maWd1cmF0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KCgpID0+IG5ldyBLTVNDbGllbnQoKSkubm90LnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYWNjZXB0IGN1c3RvbSBjb25maWd1cmF0aW9uJywgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICByZWdpb246ICd1cy13ZXN0LTInLFxuICAgICAgICBrZXlJZDogJ2N1c3RvbS1rZXktaWQnLFxuICAgICAgICBtYXhSZXRyaWVzOiA1LFxuICAgICAgfTtcblxuICAgICAgZXhwZWN0KCgpID0+IG5ldyBLTVNDbGllbnQoY29uZmlnKSkubm90LnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgZXJyb3IgaWYgQVdTX0tNU19LRVlfSUQgaXMgbWlzc2luZycsICgpID0+IHtcbiAgICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5BV1NfS01TX0tFWV9JRDtcblxuICAgICAgZXhwZWN0KCgpID0+IG5ldyBLTVNDbGllbnQoKSkudG9UaHJvdyhLZXlNYW5hZ2VtZW50RXJyb3IpO1xuICAgICAgZXhwZWN0KCgpID0+IG5ldyBLTVNDbGllbnQoKSkudG9UaHJvdygnQVdTX0tNU19LRVlfSUQgaXMgcmVxdWlyZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUga2V5IElEIGZvcm1hdCcsICgpID0+IHtcbiAgICAgIHByb2Nlc3MuZW52LkFXU19LTVNfS0VZX0lEID0gJ2ludmFsaWQta2V5LWZvcm1hdCc7XG5cbiAgICAgIGV4cGVjdCgoKSA9PiBuZXcgS01TQ2xpZW50KCkpLnRvVGhyb3coS2V5TWFuYWdlbWVudEVycm9yKTtcbiAgICAgIGV4cGVjdCgoKSA9PiBuZXcgS01TQ2xpZW50KCkpLnRvVGhyb3coJ0ludmFsaWQgS01TIEtleSBJRCBmb3JtYXQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYWNjZXB0IEFSTiBmb3JtYXQga2V5IElEJywgKCkgPT4ge1xuICAgICAgcHJvY2Vzcy5lbnYuQVdTX0tNU19LRVlfSUQgPVxuICAgICAgICAnYXJuOmF3czprbXM6dXMtZWFzdC0xOjEyMzQ1Njc4OTAxMjprZXkvMTIzNDU2NzgtMTIzNC0xMjM0LTEyMzQtMTIzNDU2Nzg5MDEyJztcblxuICAgICAgZXhwZWN0KCgpID0+IG5ldyBLTVNDbGllbnQoKSkubm90LnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYWNjZXB0IGFsaWFzIGZvcm1hdCBrZXkgSUQnLCAoKSA9PiB7XG4gICAgICBwcm9jZXNzLmVudi5BV1NfS01TX0tFWV9JRCA9ICdhbGlhcy9teS1rZXknO1xuXG4gICAgICBleHBlY3QoKCkgPT4gbmV3IEtNU0NsaWVudCgpKS5ub3QudG9UaHJvdygpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2VuZXJhdGVEYXRhS2V5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgYSBkYXRhIGtleSBmb3IgYSB0ZW5hbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2VuZCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIENpcGhlcnRleHRCbG9iOiBCdWZmZXIuZnJvbSgnZW5jcnlwdGVkLWtleScpLFxuICAgICAgICBQbGFpbnRleHQ6IEJ1ZmZlci5mcm9tKCdhJy5yZXBlYXQoMzIpKSwgLy8gMzIgYnl0ZXMgZm9yIEFFUy0yNTZcbiAgICAgICAgS2V5SWQ6IHByb2Nlc3MuZW52LkFXU19LTVNfS0VZX0lELFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHsgS01TQ2xpZW50OiBNb2NrS01TQ2xpZW50IH0gPSByZXF1aXJlKCdAYXdzLXNkay9jbGllbnQta21zJyk7XG4gICAgICBNb2NrS01TQ2xpZW50Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAoe1xuICAgICAgICBzZW5kOiBtb2NrU2VuZCxcbiAgICAgICAgZGVzdHJveTogamVzdC5mbigpLFxuICAgICAgfSkpO1xuXG4gICAgICBrbXNDbGllbnQgPSBuZXcgS01TQ2xpZW50KCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBrbXNDbGllbnQuZ2VuZXJhdGVEYXRhS2V5KCd0ZW5hbnQtMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvSGF2ZVByb3BlcnR5KCdjaXBoZXJ0ZXh0Jyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0hhdmVQcm9wZXJ0eSgncGxhaW50ZXh0Jyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0hhdmVQcm9wZXJ0eSgna2V5SWQnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucGxhaW50ZXh0KS50b0JlSW5zdGFuY2VPZihCdWZmZXIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5wbGFpbnRleHQubGVuZ3RoKS50b0JlKDMyKTtcbiAgICAgIGV4cGVjdChtb2NrU2VuZCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBpbmNsdWRlIGVuY3J5cHRpb24gY29udGV4dCB3aXRoIHRlbmFudCBJRCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZW5kID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgQ2lwaGVydGV4dEJsb2I6IEJ1ZmZlci5mcm9tKCdlbmNyeXB0ZWQta2V5JyksXG4gICAgICAgIFBsYWludGV4dDogQnVmZmVyLmZyb20oJ2EnLnJlcGVhdCgzMikpLFxuICAgICAgICBLZXlJZDogcHJvY2Vzcy5lbnYuQVdTX0tNU19LRVlfSUQsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgeyBLTVNDbGllbnQ6IE1vY2tLTVNDbGllbnQgfSA9IHJlcXVpcmUoJ0Bhd3Mtc2RrL2NsaWVudC1rbXMnKTtcbiAgICAgIE1vY2tLTVNDbGllbnQubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+ICh7XG4gICAgICAgIHNlbmQ6IG1vY2tTZW5kLFxuICAgICAgICBkZXN0cm95OiBqZXN0LmZuKCksXG4gICAgICB9KSk7XG5cbiAgICAgIGttc0NsaWVudCA9IG5ldyBLTVNDbGllbnQoKTtcbiAgICAgIGF3YWl0IGttc0NsaWVudC5nZW5lcmF0ZURhdGFLZXkoJ3RlbmFudC0xMjMnKTtcblxuICAgICAgY29uc3QgY2FsbEFyZ3MgPSBtb2NrU2VuZC5tb2NrLmNhbGxzWzBdWzBdO1xuICAgICAgZXhwZWN0KGNhbGxBcmdzLmlucHV0LkVuY3J5cHRpb25Db250ZXh0KS50b0hhdmVQcm9wZXJ0eSgnVGVuYW50SWQnLCAndGVuYW50LTEyMycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjYWNoZSB0aGUgZ2VuZXJhdGVkIGtleScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZW5kID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgQ2lwaGVydGV4dEJsb2I6IEJ1ZmZlci5mcm9tKCdlbmNyeXB0ZWQta2V5JyksXG4gICAgICAgIFBsYWludGV4dDogQnVmZmVyLmZyb20oJ2EnLnJlcGVhdCgzMikpLFxuICAgICAgICBLZXlJZDogcHJvY2Vzcy5lbnYuQVdTX0tNU19LRVlfSUQsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgeyBLTVNDbGllbnQ6IE1vY2tLTVNDbGllbnQgfSA9IHJlcXVpcmUoJ0Bhd3Mtc2RrL2NsaWVudC1rbXMnKTtcbiAgICAgIE1vY2tLTVNDbGllbnQubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+ICh7XG4gICAgICAgIHNlbmQ6IG1vY2tTZW5kLFxuICAgICAgICBkZXN0cm95OiBqZXN0LmZuKCksXG4gICAgICB9KSk7XG5cbiAgICAgIGttc0NsaWVudCA9IG5ldyBLTVNDbGllbnQoKTtcbiAgICAgIGF3YWl0IGttc0NsaWVudC5nZW5lcmF0ZURhdGFLZXkoJ3RlbmFudC0xMjMnKTtcblxuICAgICAgLy8gQ2FsbCBkZWNyeXB0RGF0YUtleSB0byB2ZXJpZnkgY2FjaGVcbiAgICAgIGF3YWl0IGttc0NsaWVudC5kZWNyeXB0RGF0YUtleSgnZW5jcnlwdGVkLWtleScsICd0ZW5hbnQtMTIzJyk7XG5cbiAgICAgIC8vIFNob3VsZCBvbmx5IGNhbGwgZ2VuZXJhdGVEYXRhS2V5IG9uY2UsIGRlY3J5cHQgc2hvdWxkIHVzZSBjYWNoZVxuICAgICAgZXhwZWN0KG1vY2tTZW5kKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBLTVMgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2VuZCA9IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShcbiAgICAgICAgbmV3IEVycm9yKCdLTVMgc2VydmljZSB1bmF2YWlsYWJsZScpXG4gICAgICApO1xuXG4gICAgICBjb25zdCB7IEtNU0NsaWVudDogTW9ja0tNU0NsaWVudCB9ID0gcmVxdWlyZSgnQGF3cy1zZGsvY2xpZW50LWttcycpO1xuICAgICAgTW9ja0tNU0NsaWVudC5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gKHtcbiAgICAgICAgc2VuZDogbW9ja1NlbmQsXG4gICAgICAgIGRlc3Ryb3k6IGplc3QuZm4oKSxcbiAgICAgIH0pKTtcblxuICAgICAga21zQ2xpZW50ID0gbmV3IEtNU0NsaWVudCgpO1xuXG4gICAgICBhd2FpdCBleHBlY3Qoa21zQ2xpZW50LmdlbmVyYXRlRGF0YUtleSgndGVuYW50LTEyMycpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgIEtleU1hbmFnZW1lbnRFcnJvclxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2RlY3J5cHREYXRhS2V5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZGVjcnlwdCBhIGRhdGEga2V5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1NlbmQgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBQbGFpbnRleHQ6IEJ1ZmZlci5mcm9tKCdiJy5yZXBlYXQoMzIpKSxcbiAgICAgICAgS2V5SWQ6IHByb2Nlc3MuZW52LkFXU19LTVNfS0VZX0lELFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHsgS01TQ2xpZW50OiBNb2NrS01TQ2xpZW50IH0gPSByZXF1aXJlKCdAYXdzLXNkay9jbGllbnQta21zJyk7XG4gICAgICBNb2NrS01TQ2xpZW50Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAoe1xuICAgICAgICBzZW5kOiBtb2NrU2VuZCxcbiAgICAgICAgZGVzdHJveTogamVzdC5mbigpLFxuICAgICAgfSkpO1xuXG4gICAgICBrbXNDbGllbnQgPSBuZXcgS01TQ2xpZW50KCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBrbXNDbGllbnQuZGVjcnlwdERhdGFLZXkoXG4gICAgICAgIEJ1ZmZlci5mcm9tKCdlbmNyeXB0ZWQta2V5JykudG9TdHJpbmcoJ2Jhc2U2NCcpLFxuICAgICAgICAndGVuYW50LTEyMydcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvSGF2ZVByb3BlcnR5KCdwbGFpbnRleHQnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvSGF2ZVByb3BlcnR5KCdrZXlJZCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5wbGFpbnRleHQpLnRvQmVJbnN0YW5jZU9mKEJ1ZmZlcik7XG4gICAgICBleHBlY3QocmVzdWx0LnBsYWludGV4dC5sZW5ndGgpLnRvQmUoMzIpO1xuICAgICAgZXhwZWN0KG1vY2tTZW5kKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBjYWNoZWQga2V5IGlmIGF2YWlsYWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZW5kID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgUGxhaW50ZXh0OiBCdWZmZXIuZnJvbSgnYycucmVwZWF0KDMyKSksXG4gICAgICAgIEtleUlkOiBwcm9jZXNzLmVudi5BV1NfS01TX0tFWV9JRCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IEtNU0NsaWVudDogTW9ja0tNU0NsaWVudCB9ID0gcmVxdWlyZSgnQGF3cy1zZGsvY2xpZW50LWttcycpO1xuICAgICAgTW9ja0tNU0NsaWVudC5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gKHtcbiAgICAgICAgc2VuZDogbW9ja1NlbmQsXG4gICAgICAgIGRlc3Ryb3k6IGplc3QuZm4oKSxcbiAgICAgIH0pKTtcblxuICAgICAga21zQ2xpZW50ID0gbmV3IEtNU0NsaWVudCgpO1xuXG4gICAgICAvLyBGaXJzdCBjYWxsIC0gc2hvdWxkIGhpdCBLTVNcbiAgICAgIGF3YWl0IGttc0NsaWVudC5kZWNyeXB0RGF0YUtleSgnZW5jcnlwdGVkLWtleScsICd0ZW5hbnQtMTIzJyk7XG5cbiAgICAgIC8vIFNlY29uZCBjYWxsIC0gc2hvdWxkIHVzZSBjYWNoZVxuICAgICAgYXdhaXQga21zQ2xpZW50LmRlY3J5cHREYXRhS2V5KCdlbmNyeXB0ZWQta2V5JywgJ3RlbmFudC0xMjMnKTtcblxuICAgICAgZXhwZWN0KG1vY2tTZW5kKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7IC8vIE9ubHkgb25lIEtNUyBjYWxsXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGluY2x1ZGUgZW5jcnlwdGlvbiBjb250ZXh0IGZvciB0ZW5hbnQgdmFsaWRhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZW5kID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgUGxhaW50ZXh0OiBCdWZmZXIuZnJvbSgnZCcucmVwZWF0KDMyKSksXG4gICAgICAgIEtleUlkOiBwcm9jZXNzLmVudi5BV1NfS01TX0tFWV9JRCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IEtNU0NsaWVudDogTW9ja0tNU0NsaWVudCB9ID0gcmVxdWlyZSgnQGF3cy1zZGsvY2xpZW50LWttcycpO1xuICAgICAgTW9ja0tNU0NsaWVudC5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gKHtcbiAgICAgICAgc2VuZDogbW9ja1NlbmQsXG4gICAgICAgIGRlc3Ryb3k6IGplc3QuZm4oKSxcbiAgICAgIH0pKTtcblxuICAgICAga21zQ2xpZW50ID0gbmV3IEtNU0NsaWVudCgpO1xuICAgICAgYXdhaXQga21zQ2xpZW50LmRlY3J5cHREYXRhS2V5KCdlbmNyeXB0ZWQta2V5JywgJ3RlbmFudC00NTYnKTtcblxuICAgICAgY29uc3QgY2FsbEFyZ3MgPSBtb2NrU2VuZC5tb2NrLmNhbGxzWzBdWzBdO1xuICAgICAgZXhwZWN0KGNhbGxBcmdzLmlucHV0LkVuY3J5cHRpb25Db250ZXh0KS50b0hhdmVQcm9wZXJ0eSgnVGVuYW50SWQnLCAndGVuYW50LTQ1NicpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ2FjaGUgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNsZWFyIGNhY2hlIGZvciBzcGVjaWZpYyB0ZW5hbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2VuZCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIFBsYWludGV4dDogQnVmZmVyLmZyb20oJ2UnLnJlcGVhdCgzMikpLFxuICAgICAgICBLZXlJZDogcHJvY2Vzcy5lbnYuQVdTX0tNU19LRVlfSUQsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgeyBLTVNDbGllbnQ6IE1vY2tLTVNDbGllbnQgfSA9IHJlcXVpcmUoJ0Bhd3Mtc2RrL2NsaWVudC1rbXMnKTtcbiAgICAgIE1vY2tLTVNDbGllbnQubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+ICh7XG4gICAgICAgIHNlbmQ6IG1vY2tTZW5kLFxuICAgICAgICBkZXN0cm95OiBqZXN0LmZuKCksXG4gICAgICB9KSk7XG5cbiAgICAgIGttc0NsaWVudCA9IG5ldyBLTVNDbGllbnQoKTtcblxuICAgICAgLy8gQ2FjaGUgYSBrZXlcbiAgICAgIGF3YWl0IGttc0NsaWVudC5kZWNyeXB0RGF0YUtleSgnZW5jcnlwdGVkLWtleScsICd0ZW5hbnQtMTIzJyk7XG5cbiAgICAgIC8vIENsZWFyIGNhY2hlXG4gICAgICBrbXNDbGllbnQuY2xlYXJDYWNoZSgndGVuYW50LTEyMycpO1xuXG4gICAgICAvLyBTaG91bGQgY2FsbCBLTVMgYWdhaW5cbiAgICAgIGF3YWl0IGttc0NsaWVudC5kZWNyeXB0RGF0YUtleSgnZW5jcnlwdGVkLWtleScsICd0ZW5hbnQtMTIzJyk7XG5cbiAgICAgIGV4cGVjdChtb2NrU2VuZCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjbGVhciBhbGwgY2FjaGVzIHdoZW4gbm8gdGVuYW50IHNwZWNpZmllZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZW5kID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgUGxhaW50ZXh0OiBCdWZmZXIuZnJvbSgnZicucmVwZWF0KDMyKSksXG4gICAgICAgIEtleUlkOiBwcm9jZXNzLmVudi5BV1NfS01TX0tFWV9JRCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IEtNU0NsaWVudDogTW9ja0tNU0NsaWVudCB9ID0gcmVxdWlyZSgnQGF3cy1zZGsvY2xpZW50LWttcycpO1xuICAgICAgTW9ja0tNU0NsaWVudC5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gKHtcbiAgICAgICAgc2VuZDogbW9ja1NlbmQsXG4gICAgICAgIGRlc3Ryb3k6IGplc3QuZm4oKSxcbiAgICAgIH0pKTtcblxuICAgICAga21zQ2xpZW50ID0gbmV3IEtNU0NsaWVudCgpO1xuXG4gICAgICAvLyBDYWNoZSBrZXlzIGZvciBtdWx0aXBsZSB0ZW5hbnRzXG4gICAgICBhd2FpdCBrbXNDbGllbnQuZGVjcnlwdERhdGFLZXkoJ2VuY3J5cHRlZC1rZXktMScsICd0ZW5hbnQtMScpO1xuICAgICAgYXdhaXQga21zQ2xpZW50LmRlY3J5cHREYXRhS2V5KCdlbmNyeXB0ZWQta2V5LTInLCAndGVuYW50LTInKTtcblxuICAgICAgLy8gQ2xlYXIgYWxsIGNhY2hlc1xuICAgICAga21zQ2xpZW50LmNsZWFyQ2FjaGUoKTtcblxuICAgICAgLy8gU2hvdWxkIGNhbGwgS01TIGFnYWluIGZvciBib3RoXG4gICAgICBhd2FpdCBrbXNDbGllbnQuZGVjcnlwdERhdGFLZXkoJ2VuY3J5cHRlZC1rZXktMScsICd0ZW5hbnQtMScpO1xuICAgICAgYXdhaXQga21zQ2xpZW50LmRlY3J5cHREYXRhS2V5KCdlbmNyeXB0ZWQta2V5LTInLCAndGVuYW50LTInKTtcblxuICAgICAgZXhwZWN0KG1vY2tTZW5kKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoNCk7IC8vIDIgaW5pdGlhbCArIDIgYWZ0ZXIgY2xlYXJcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1N0YXRpc3RpY3MnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB0cmFjayBvcGVyYXRpb24gc3RhdGlzdGljcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZW5kID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgUGxhaW50ZXh0OiBCdWZmZXIuZnJvbSgnZycucmVwZWF0KDMyKSksXG4gICAgICAgIEtleUlkOiBwcm9jZXNzLmVudi5BV1NfS01TX0tFWV9JRCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IEtNU0NsaWVudDogTW9ja0tNU0NsaWVudCB9ID0gcmVxdWlyZSgnQGF3cy1zZGsvY2xpZW50LWttcycpO1xuICAgICAgTW9ja0tNU0NsaWVudC5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gKHtcbiAgICAgICAgc2VuZDogbW9ja1NlbmQsXG4gICAgICAgIGRlc3Ryb3k6IGplc3QuZm4oKSxcbiAgICAgIH0pKTtcblxuICAgICAga21zQ2xpZW50ID0gbmV3IEtNU0NsaWVudCgpO1xuXG4gICAgICBhd2FpdCBrbXNDbGllbnQuZGVjcnlwdERhdGFLZXkoJ2VuY3J5cHRlZC1rZXknLCAndGVuYW50LTEyMycpO1xuXG4gICAgICBjb25zdCBzdGF0cyA9IGttc0NsaWVudC5nZXRTdGF0cygpO1xuXG4gICAgICBleHBlY3Qoc3RhdHMudG90YWxPcGVyYXRpb25zKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KHN0YXRzLnN1Y2Nlc3NmdWwpLnRvQmUoMSk7XG4gICAgICBleHBlY3Qoc3RhdHMuZmFpbGVkKS50b0JlKDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXNldCBzdGF0aXN0aWNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1NlbmQgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBQbGFpbnRleHQ6IEJ1ZmZlci5mcm9tKCdoJy5yZXBlYXQoMzIpKSxcbiAgICAgICAgS2V5SWQ6IHByb2Nlc3MuZW52LkFXU19LTVNfS0VZX0lELFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHsgS01TQ2xpZW50OiBNb2NrS01TQ2xpZW50IH0gPSByZXF1aXJlKCdAYXdzLXNkay9jbGllbnQta21zJyk7XG4gICAgICBNb2NrS01TQ2xpZW50Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAoe1xuICAgICAgICBzZW5kOiBtb2NrU2VuZCxcbiAgICAgICAgZGVzdHJveTogamVzdC5mbigpLFxuICAgICAgfSkpO1xuXG4gICAgICBrbXNDbGllbnQgPSBuZXcgS01TQ2xpZW50KCk7XG5cbiAgICAgIGF3YWl0IGttc0NsaWVudC5kZWNyeXB0RGF0YUtleSgnZW5jcnlwdGVkLWtleScsICd0ZW5hbnQtMTIzJyk7XG5cbiAgICAgIGttc0NsaWVudC5yZXNldFN0YXRzKCk7XG5cbiAgICAgIGNvbnN0IHN0YXRzID0ga21zQ2xpZW50LmdldFN0YXRzKCk7XG5cbiAgICAgIGV4cGVjdChzdGF0cy50b3RhbE9wZXJhdGlvbnMpLnRvQmUoMCk7XG4gICAgICBleHBlY3Qoc3RhdHMuc3VjY2Vzc2Z1bCkudG9CZSgwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Nvbm5lY3Rpb24gVGVzdCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHRlc3QgS01TIGNvbm5lY3Rpdml0eSBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2VuZCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIEtleU1ldGFkYXRhOiB7XG4gICAgICAgICAgS2V5SWQ6IHByb2Nlc3MuZW52LkFXU19LTVNfS0VZX0lELFxuICAgICAgICAgIEFybjogYGFybjphd3M6a21zOnVzLWVhc3QtMToxMjM0NTY3ODkwMTI6a2V5LyR7cHJvY2Vzcy5lbnYuQVdTX0tNU19LRVlfSUR9YCxcbiAgICAgICAgICBLZXlTdGF0ZTogJ0VuYWJsZWQnLFxuICAgICAgICAgIENyZWF0aW9uRGF0ZTogbmV3IERhdGUoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IEtNU0NsaWVudDogTW9ja0tNU0NsaWVudCB9ID0gcmVxdWlyZSgnQGF3cy1zZGsvY2xpZW50LWttcycpO1xuICAgICAgTW9ja0tNU0NsaWVudC5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gKHtcbiAgICAgICAgc2VuZDogbW9ja1NlbmQsXG4gICAgICAgIGRlc3Ryb3k6IGplc3QuZm4oKSxcbiAgICAgIH0pKTtcblxuICAgICAga21zQ2xpZW50ID0gbmV3IEtNU0NsaWVudCgpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQga21zQ2xpZW50LnRlc3RDb25uZWN0aW9uKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBmYWxzZSBvbiBjb25uZWN0aW9uIGZhaWx1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2VuZCA9IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZmFpbGVkJykpO1xuXG4gICAgICBjb25zdCB7IEtNU0NsaWVudDogTW9ja0tNU0NsaWVudCB9ID0gcmVxdWlyZSgnQGF3cy1zZGsvY2xpZW50LWttcycpO1xuICAgICAgTW9ja0tNU0NsaWVudC5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gKHtcbiAgICAgICAgc2VuZDogbW9ja1NlbmQsXG4gICAgICAgIGRlc3Ryb3k6IGplc3QuZm4oKSxcbiAgICAgIH0pKTtcblxuICAgICAga21zQ2xpZW50ID0gbmV3IEtNU0NsaWVudCgpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQga21zQ2xpZW50LnRlc3RDb25uZWN0aW9uKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2luZ2xldG9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHNhbWUgaW5zdGFuY2UgZm9yIGdldEtNU0NsaWVudCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlMSA9IGdldEtNU0NsaWVudCgpO1xuICAgICAgY29uc3QgaW5zdGFuY2UyID0gZ2V0S01TQ2xpZW50KCk7XG5cbiAgICAgIGV4cGVjdChpbnN0YW5jZTEpLnRvQmUoaW5zdGFuY2UyKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY3JlYXRlIG5ldyBpbnN0YW5jZSBhZnRlciByZXNldCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlMSA9IGdldEtNU0NsaWVudCgpO1xuXG4gICAgICByZXNldEtNU0NsaWVudCgpO1xuXG4gICAgICBjb25zdCBpbnN0YW5jZTIgPSBnZXRLTVNDbGllbnQoKTtcblxuICAgICAgZXhwZWN0KGluc3RhbmNlMSkubm90LnRvQmUoaW5zdGFuY2UyKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsIktNU0NsaWVudCIsImZuIiwibW9ja0ltcGxlbWVudGF0aW9uIiwic2VuZCIsImRlc3Ryb3kiLCJHZW5lcmF0ZURhdGFLZXlDb21tYW5kIiwiRGVjcnlwdENvbW1hbmQiLCJFbmNyeXB0Q29tbWFuZCIsIkRlc2NyaWJlS2V5Q29tbWFuZCIsIktNU1NlcnZpY2VFeGNlcHRpb24iLCJFcnJvciIsIm1lc3NhZ2UiLCJuYW1lIiwiZnJvbUVudiIsImFjY2Vzc0tleUlkIiwic2VjcmV0QWNjZXNzS2V5IiwiZGVzY3JpYmUiLCJrbXNDbGllbnQiLCJiZWZvcmVFYWNoIiwicHJvY2VzcyIsImVudiIsIkFXU19SRUdJT04iLCJBV1NfS01TX0tFWV9JRCIsIkFXU19BQ0NFU1NfS0VZX0lEIiwiQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZIiwicmVzZXRLTVNDbGllbnQiLCJhZnRlckVhY2giLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJleHBlY3QiLCJub3QiLCJ0b1Rocm93IiwiY29uZmlnIiwicmVnaW9uIiwia2V5SWQiLCJtYXhSZXRyaWVzIiwiS2V5TWFuYWdlbWVudEVycm9yIiwibW9ja1NlbmQiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsIkNpcGhlcnRleHRCbG9iIiwiQnVmZmVyIiwiZnJvbSIsIlBsYWludGV4dCIsInJlcGVhdCIsIktleUlkIiwiTW9ja0tNU0NsaWVudCIsInJlcXVpcmUiLCJyZXN1bHQiLCJnZW5lcmF0ZURhdGFLZXkiLCJ0b0hhdmVQcm9wZXJ0eSIsInBsYWludGV4dCIsInRvQmVJbnN0YW5jZU9mIiwibGVuZ3RoIiwidG9CZSIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsImNhbGxBcmdzIiwiY2FsbHMiLCJpbnB1dCIsIkVuY3J5cHRpb25Db250ZXh0IiwiZGVjcnlwdERhdGFLZXkiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsInJlamVjdHMiLCJ0b1N0cmluZyIsImNsZWFyQ2FjaGUiLCJzdGF0cyIsImdldFN0YXRzIiwidG90YWxPcGVyYXRpb25zIiwic3VjY2Vzc2Z1bCIsImZhaWxlZCIsInJlc2V0U3RhdHMiLCJLZXlNZXRhZGF0YSIsIkFybiIsIktleVN0YXRlIiwiQ3JlYXRpb25EYXRlIiwiRGF0ZSIsInRlc3RDb25uZWN0aW9uIiwiaW5zdGFuY2UxIiwiZ2V0S01TQ2xpZW50IiwiaW5zdGFuY2UyIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDO0FBS0QsZUFBZTtBQUNmQSxLQUFLQyxJQUFJLENBQUMsdUJBQXVCLElBQU8sQ0FBQTtRQUN0Q0MsV0FBV0YsS0FBS0csRUFBRSxHQUFHQyxrQkFBa0IsQ0FBQyxJQUFPLENBQUE7Z0JBQzdDQyxNQUFNTCxLQUFLRyxFQUFFO2dCQUNiRyxTQUFTTixLQUFLRyxFQUFFO1lBQ2xCLENB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