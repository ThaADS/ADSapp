{"version":3,"sources":["C:\\Ai Projecten\\ADSapp\\src\\lib\\auth\\mfa.ts"],"sourcesContent":["/**\n * Multi-Factor Authentication (MFA) Service\n *\n * Provides TOTP-based two-factor authentication with backup codes.\n * Security: AES-256 encrypted backup codes, SHA-256 hashed storage\n * Standard: RFC 6238 (TOTP) compliant\n */\n\nimport { createClient } from '@/lib/supabase/server';\nimport * as crypto from 'crypto';\nimport { authenticator } from 'otplib';\n\n// Configure TOTP settings\nauthenticator.options = {\n  window: 1, // Allow 1 step before/after for time drift\n  step: 30, // 30 second time step\n};\n\nexport interface MFAEnrollmentData {\n  secret: string;\n  qrCode: string;\n  backupCodes: string[];\n}\n\nexport interface MFAStatus {\n  enabled: boolean;\n  enrolledAt: string | null;\n  backupCodesRemaining: number;\n}\n\nexport interface MFAVerification {\n  valid: boolean;\n  error?: string;\n}\n\n/**\n * Generate MFA secret and QR code for enrollment\n */\nexport async function generateMFAEnrollment(userId: string): Promise<MFAEnrollmentData> {\n  const supabase = await createClient();\n\n  // Get user profile for QR code generation\n  const { data: profile, error: profileError } = await supabase\n    .from('profiles')\n    .select('email, full_name')\n    .eq('id', userId)\n    .single();\n\n  if (profileError || !profile) {\n    throw new Error('User profile not found');\n  }\n\n  // Generate TOTP secret\n  const secret = authenticator.generateSecret();\n\n  // Generate QR code data URL\n  const otpauthUrl = authenticator.keyuri(\n    profile.email,\n    'ADSapp',\n    secret\n  );\n\n  // Use qrcode library to generate QR code\n  const QRCode = require('qrcode');\n  const qrCode = await QRCode.toDataURL(otpauthUrl);\n\n  // Generate 10 backup codes (8 characters each, alphanumeric)\n  const backupCodes = generateBackupCodes(10);\n\n  // Hash backup codes for secure storage\n  const hashedBackupCodes = backupCodes.map(code => hashBackupCode(code));\n\n  // Store MFA enrollment data (not yet enabled)\n  const { error: updateError } = await supabase\n    .from('profiles')\n    .update({\n      mfa_secret: secret,\n      mfa_backup_codes: hashedBackupCodes,\n      mfa_enrolled_at: null, // Not enabled until verified\n      updated_at: new Date().toISOString()\n    })\n    .eq('id', userId);\n\n  if (updateError) {\n    throw new Error('Failed to store MFA enrollment data');\n  }\n\n  return {\n    secret,\n    qrCode,\n    backupCodes // Return unhashed codes to user (only time they'll see them)\n  };\n}\n\n/**\n * Verify TOTP token and complete MFA enrollment\n */\nexport async function verifyAndEnableMFA(\n  userId: string,\n  token: string\n): Promise<MFAVerification> {\n  const supabase = await createClient();\n\n  // Get user's MFA secret\n  const { data: profile, error: profileError } = await supabase\n    .from('profiles')\n    .select('mfa_secret, mfa_enabled')\n    .eq('id', userId)\n    .single();\n\n  if (profileError || !profile) {\n    return { valid: false, error: 'User not found' };\n  }\n\n  if (!profile.mfa_secret) {\n    return { valid: false, error: 'MFA not enrolled. Start enrollment first.' };\n  }\n\n  // Verify TOTP token\n  const isValid = authenticator.verify({\n    token,\n    secret: profile.mfa_secret\n  });\n\n  if (!isValid) {\n    return { valid: false, error: 'Invalid verification code' };\n  }\n\n  // Enable MFA\n  const { error: updateError } = await supabase\n    .from('profiles')\n    .update({\n      mfa_enabled: true,\n      mfa_enrolled_at: new Date().toISOString(),\n      updated_at: new Date().toISOString()\n    })\n    .eq('id', userId);\n\n  if (updateError) {\n    return { valid: false, error: 'Failed to enable MFA' };\n  }\n\n  return { valid: true };\n}\n\n/**\n * Verify TOTP token during login\n */\nexport async function verifyMFAToken(\n  userId: string,\n  token: string\n): Promise<MFAVerification> {\n  const supabase = await createClient();\n\n  // Get user's MFA configuration\n  const { data: profile, error: profileError } = await supabase\n    .from('profiles')\n    .select('mfa_secret, mfa_enabled, mfa_backup_codes')\n    .eq('id', userId)\n    .single();\n\n  if (profileError || !profile) {\n    return { valid: false, error: 'User not found' };\n  }\n\n  if (!profile.mfa_enabled || !profile.mfa_secret) {\n    return { valid: false, error: 'MFA not enabled' };\n  }\n\n  // Try TOTP verification first\n  const isValidTOTP = authenticator.verify({\n    token,\n    secret: profile.mfa_secret\n  });\n\n  if (isValidTOTP) {\n    return { valid: true };\n  }\n\n  // Try backup code verification if TOTP failed\n  const backupCodeResult = await verifyBackupCode(userId, token, profile.mfa_backup_codes);\n  if (backupCodeResult.valid) {\n    return { valid: true };\n  }\n\n  return { valid: false, error: 'Invalid verification code' };\n}\n\n/**\n * Verify backup code and mark as used\n */\nasync function verifyBackupCode(\n  userId: string,\n  code: string,\n  hashedBackupCodes: string[]\n): Promise<MFAVerification> {\n  const supabase = await createClient();\n\n  if (!hashedBackupCodes || hashedBackupCodes.length === 0) {\n    return { valid: false, error: 'No backup codes available' };\n  }\n\n  const hashedInput = hashBackupCode(code);\n\n  // Find matching backup code\n  const matchIndex = hashedBackupCodes.findIndex(hash => hash === hashedInput);\n\n  if (matchIndex === -1) {\n    return { valid: false, error: 'Invalid backup code' };\n  }\n\n  // Remove used backup code\n  const updatedBackupCodes = hashedBackupCodes.filter((_, index) => index !== matchIndex);\n\n  // Update database\n  const { error: updateError } = await supabase\n    .from('profiles')\n    .update({\n      mfa_backup_codes: updatedBackupCodes,\n      updated_at: new Date().toISOString()\n    })\n    .eq('id', userId);\n\n  if (updateError) {\n    return { valid: false, error: 'Failed to update backup codes' };\n  }\n\n  // Log backup code usage\n  await supabase.from('audit_logs').insert({\n    user_id: userId,\n    action: 'mfa_backup_code_used',\n    details: { remaining_codes: updatedBackupCodes.length },\n    timestamp: new Date().toISOString()\n  });\n\n  return { valid: true };\n}\n\n/**\n * Disable MFA for user\n */\nexport async function disableMFA(userId: string, password: string): Promise<boolean> {\n  const supabase = await createClient();\n\n  // Verify password before disabling MFA (security requirement)\n  const { data: { user }, error: authError } = await supabase.auth.signInWithPassword({\n    email: '', // Will be validated by userId\n    password\n  });\n\n  if (authError || user?.id !== userId) {\n    throw new Error('Password verification failed');\n  }\n\n  // Disable MFA and clear secrets\n  const { error: updateError } = await supabase\n    .from('profiles')\n    .update({\n      mfa_enabled: false,\n      mfa_secret: null,\n      mfa_backup_codes: null,\n      mfa_enrolled_at: null,\n      updated_at: new Date().toISOString()\n    })\n    .eq('id', userId);\n\n  if (updateError) {\n    throw new Error('Failed to disable MFA');\n  }\n\n  // Log MFA disable action\n  await supabase.from('audit_logs').insert({\n    user_id: userId,\n    action: 'mfa_disabled',\n    timestamp: new Date().toISOString()\n  });\n\n  return true;\n}\n\n/**\n * Get MFA status for user\n */\nexport async function getMFAStatus(userId: string): Promise<MFAStatus> {\n  const supabase = await createClient();\n\n  const { data: profile, error } = await supabase\n    .from('profiles')\n    .select('mfa_enabled, mfa_enrolled_at, mfa_backup_codes')\n    .eq('id', userId)\n    .single();\n\n  if (error || !profile) {\n    return {\n      enabled: false,\n      enrolledAt: null,\n      backupCodesRemaining: 0\n    };\n  }\n\n  return {\n    enabled: profile.mfa_enabled || false,\n    enrolledAt: profile.mfa_enrolled_at,\n    backupCodesRemaining: profile.mfa_backup_codes?.length || 0\n  };\n}\n\n/**\n * Regenerate backup codes (requires password verification)\n */\nexport async function regenerateBackupCodes(\n  userId: string,\n  password: string\n): Promise<string[]> {\n  const supabase = await createClient();\n\n  // Verify password\n  const { data: { user }, error: authError } = await supabase.auth.signInWithPassword({\n    email: '', // Will be validated by userId\n    password\n  });\n\n  if (authError || user?.id !== userId) {\n    throw new Error('Password verification failed');\n  }\n\n  // Generate new backup codes\n  const newBackupCodes = generateBackupCodes(10);\n  const hashedBackupCodes = newBackupCodes.map(code => hashBackupCode(code));\n\n  // Update database\n  const { error: updateError } = await supabase\n    .from('profiles')\n    .update({\n      mfa_backup_codes: hashedBackupCodes,\n      updated_at: new Date().toISOString()\n    })\n    .eq('id', userId);\n\n  if (updateError) {\n    throw new Error('Failed to regenerate backup codes');\n  }\n\n  // Log backup code regeneration\n  await supabase.from('audit_logs').insert({\n    user_id: userId,\n    action: 'mfa_backup_codes_regenerated',\n    timestamp: new Date().toISOString()\n  });\n\n  return newBackupCodes;\n}\n\n/**\n * Generate random backup codes\n */\nfunction generateBackupCodes(count: number): string[] {\n  const codes: string[] = [];\n  const characters = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Exclude confusing chars\n\n  for (let i = 0; i < count; i++) {\n    let code = '';\n    for (let j = 0; j < 8; j++) {\n      const randomIndex = crypto.randomInt(0, characters.length);\n      code += characters[randomIndex];\n    }\n    // Format as XXXX-XXXX for readability\n    code = `${code.substring(0, 4)}-${code.substring(4, 8)}`;\n    codes.push(code);\n  }\n\n  return codes;\n}\n\n/**\n * Hash backup code for secure storage (SHA-256)\n */\nfunction hashBackupCode(code: string): string {\n  return crypto\n    .createHash('sha256')\n    .update(code.replace('-', '')) // Remove hyphen before hashing\n    .digest('hex');\n}\n\n/**\n * Check if MFA is required for user\n */\nexport async function isMFARequired(userId: string): Promise<boolean> {\n  const status = await getMFAStatus(userId);\n  return status.enabled;\n}\n\n/**\n * Validate MFA token format\n */\nexport function isValidMFATokenFormat(token: string): boolean {\n  // TOTP: 6 digits\n  if (/^\\d{6}$/.test(token)) {\n    return true;\n  }\n\n  // Backup code: XXXX-XXXX format\n  if (/^[A-Z0-9]{4}-[A-Z0-9]{4}$/.test(token)) {\n    return true;\n  }\n\n  return false;\n}\n"],"names":["disableMFA","generateMFAEnrollment","getMFAStatus","isMFARequired","isValidMFATokenFormat","regenerateBackupCodes","verifyAndEnableMFA","verifyMFAToken","authenticator","options","window","step","userId","supabase","createClient","data","profile","error","profileError","from","select","eq","single","Error","secret","generateSecret","otpauthUrl","keyuri","email","QRCode","require","qrCode","toDataURL","backupCodes","generateBackupCodes","hashedBackupCodes","map","code","hashBackupCode","updateError","update","mfa_secret","mfa_backup_codes","mfa_enrolled_at","updated_at","Date","toISOString","token","valid","isValid","verify","mfa_enabled","isValidTOTP","backupCodeResult","verifyBackupCode","length","hashedInput","matchIndex","findIndex","hash","updatedBackupCodes","filter","_","index","insert","user_id","action","details","remaining_codes","timestamp","password","user","authError","auth","signInWithPassword","id","enabled","enrolledAt","backupCodesRemaining","newBackupCodes","count","codes","characters","i","j","randomIndex","crypto","randomInt","substring","push","createHash","replace","digest","status","test"],"mappings":"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"}