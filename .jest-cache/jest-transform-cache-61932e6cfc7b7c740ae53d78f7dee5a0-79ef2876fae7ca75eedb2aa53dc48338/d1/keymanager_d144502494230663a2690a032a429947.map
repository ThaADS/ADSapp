{"version":3,"sources":["C:\\Ai Projecten\\ADSapp\\src\\lib\\security\\key-manager.ts"],"sourcesContent":["/**\n * Key Manager Service\n *\n * Manages encryption keys using AWS KMS with support for:\n * - Multi-tenant key isolation\n * - Automatic key rotation (90-day schedule)\n * - Key versioning for backward compatibility\n * - Tenant-specific key derivation\n * - Performance caching\n *\n * @module security/key-manager\n */\n\nimport { createClient } from '@/lib/supabase/server';\nimport { getKMSClient, KMSClient, DataKeyResult } from './kms-client';\nimport { KeyManagementError } from '@/lib/crypto/types';\nimport * as crypto from 'crypto';\n\n/**\n * Key version information\n */\nexport interface KeyVersion {\n  /** Version ID */\n  id: string;\n  /** Tenant ID this key belongs to */\n  tenantId: string;\n  /** KMS Key ID used */\n  kmsKeyId: string;\n  /** Encrypted data key (ciphertext) */\n  encryptedDataKey: string;\n  /** Key version number */\n  version: number;\n  /** Whether this is the current/active key */\n  isActive: boolean;\n  /** When the key was created */\n  createdAt: Date;\n  /** When the key was rotated (null if still active) */\n  rotatedAt?: Date;\n  /** When the key expires (90 days from creation) */\n  expiresAt: Date;\n}\n\n/**\n * Key retrieval options\n */\nexport interface KeyRetrievalOptions {\n  /** Force refresh from KMS (skip cache) */\n  forceRefresh?: boolean;\n  /** Specific key version to retrieve */\n  version?: number;\n  /** Include expired keys */\n  includeExpired?: boolean;\n}\n\n/**\n * Key rotation result\n */\nexport interface KeyRotationResult {\n  /** Number of keys successfully rotated */\n  rotated: number;\n  /** Number of keys that failed rotation */\n  failed: number;\n  /** List of tenant IDs that were rotated */\n  tenantIds: string[];\n  /** List of errors that occurred */\n  errors: Array<{ tenantId: string; error: string }>;\n  /** Duration of rotation in milliseconds */\n  duration: number;\n}\n\n/**\n * Key statistics\n */\nexport interface KeyStats {\n  /** Total keys managed */\n  totalKeys: number;\n  /** Active keys */\n  activeKeys: number;\n  /** Expired keys */\n  expiredKeys: number;\n  /** Keys pending rotation */\n  pendingRotation: number;\n  /** Average key age in days */\n  averageKeyAge: number;\n}\n\n/**\n * Key Manager for encryption key lifecycle management\n */\nexport class KeyManager {\n  private kmsClient: KMSClient;\n  private keyCache: Map<string, { key: Buffer; timestamp: number; version: number }>;\n  private readonly CACHE_TTL = 3600000; // 1 hour\n  private readonly KEY_ROTATION_DAYS = 90;\n  private readonly KEY_ROTATION_WARNING_DAYS = 7;\n\n  constructor(kmsClient?: KMSClient) {\n    this.kmsClient = kmsClient || getKMSClient();\n    this.keyCache = new Map();\n  }\n\n  /**\n   * Get encryption key for a tenant\n   * Automatically creates a new key if none exists\n   *\n   * @param tenantId - Tenant identifier\n   * @param options - Retrieval options\n   * @returns Decrypted encryption key\n   * @throws {KeyManagementError} If key retrieval fails\n   */\n  async getEncryptionKey(\n    tenantId: string,\n    options: KeyRetrievalOptions = {}\n  ): Promise<Buffer> {\n    try {\n      // Check cache first unless force refresh\n      if (!options.forceRefresh) {\n        const cached = this.getCachedKey(tenantId);\n        if (cached) {\n          return cached;\n        }\n      }\n\n      // Get active key from database\n      const keyVersion = await this.getActiveKeyVersion(tenantId);\n\n      if (!keyVersion) {\n        // No key exists, create one\n        return await this.createKey(tenantId);\n      }\n\n      // Check if key is expired and needs rotation\n      if (this.isKeyExpired(keyVersion.expiresAt)) {\n        console.warn(`Key for tenant ${tenantId} has expired, rotating...`);\n        return await this.rotateKey(tenantId);\n      }\n\n      // Check if key is approaching expiration\n      if (this.isKeyNearExpiration(keyVersion.expiresAt)) {\n        console.info(`Key for tenant ${tenantId} is approaching expiration`);\n        // Trigger async rotation in background (don't wait)\n        this.rotateKey(tenantId).catch((error) => {\n          console.error(`Background key rotation failed for ${tenantId}:`, error);\n        });\n      }\n\n      // Decrypt the data key using KMS\n      const decrypted = await this.kmsClient.decryptDataKey(\n        keyVersion.encryptedDataKey,\n        tenantId\n      );\n\n      // Cache the decrypted key\n      this.cacheKey(tenantId, decrypted.plaintext, keyVersion.version);\n\n      return decrypted.plaintext;\n    } catch (error) {\n      throw new KeyManagementError(\n        `Failed to get encryption key for tenant ${tenantId}`,\n        'GET_KEY_FAILED',\n        {\n          tenantId,\n          originalError: error instanceof Error ? error.message : String(error),\n        }\n      );\n    }\n  }\n\n  /**\n   * Create a new encryption key for a tenant\n   *\n   * @param tenantId - Tenant identifier\n   * @returns Newly created encryption key\n   * @throws {KeyManagementError} If key creation fails\n   */\n  async createKey(tenantId: string): Promise<Buffer> {\n    try {\n      // Generate data key from KMS\n      const dataKey = await this.kmsClient.generateDataKey(tenantId);\n\n      // Get the next version number\n      const version = await this.getNextVersion(tenantId);\n\n      // Calculate expiration date (90 days from now)\n      const expiresAt = new Date();\n      expiresAt.setDate(expiresAt.getDate() + this.KEY_ROTATION_DAYS);\n\n      // Store in database\n      const supabase = await createClient();\n      const { error } = await supabase.from('encryption_keys').insert({\n        tenant_id: tenantId,\n        kms_key_id: dataKey.keyId,\n        encrypted_data_key: dataKey.ciphertext,\n        version: version,\n        is_active: true,\n        created_at: new Date().toISOString(),\n        expires_at: expiresAt.toISOString(),\n      });\n\n      if (error) {\n        throw new Error(`Database insert failed: ${error.message}`);\n      }\n\n      // Log key creation\n      await this.logKeyOperation('create', tenantId, version, true);\n\n      // Cache the key\n      this.cacheKey(tenantId, dataKey.plaintext, version);\n\n      return dataKey.plaintext;\n    } catch (error) {\n      await this.logKeyOperation('create', tenantId, 0, false, error);\n\n      throw new KeyManagementError(\n        `Failed to create key for tenant ${tenantId}`,\n        'CREATE_KEY_FAILED',\n        {\n          tenantId,\n          originalError: error instanceof Error ? error.message : String(error),\n        }\n      );\n    }\n  }\n\n  /**\n   * Rotate encryption key for a tenant\n   *\n   * @param tenantId - Tenant identifier\n   * @returns New encryption key\n   * @throws {KeyManagementError} If rotation fails\n   */\n  async rotateKey(tenantId: string): Promise<Buffer> {\n    try {\n      const supabase = await createClient();\n\n      // Get current active key\n      const currentKey = await this.getActiveKeyVersion(tenantId);\n      if (!currentKey) {\n        throw new Error('No active key found to rotate');\n      }\n\n      // Mark current key as inactive and set rotated_at\n      const { error: updateError } = await supabase\n        .from('encryption_keys')\n        .update({\n          is_active: false,\n          rotated_at: new Date().toISOString(),\n        })\n        .eq('id', currentKey.id);\n\n      if (updateError) {\n        throw new Error(`Failed to deactivate old key: ${updateError.message}`);\n      }\n\n      // Create new key\n      const newKey = await this.createKey(tenantId);\n\n      // Log rotation\n      await this.logKeyRotation(tenantId, currentKey.version, currentKey.version + 1);\n\n      // Clear cache to force refresh\n      this.clearCache(tenantId);\n\n      return newKey;\n    } catch (error) {\n      throw new KeyManagementError(\n        `Failed to rotate key for tenant ${tenantId}`,\n        'ROTATE_KEY_FAILED',\n        {\n          tenantId,\n          originalError: error instanceof Error ? error.message : String(error),\n        }\n      );\n    }\n  }\n\n  /**\n   * Rotate keys for multiple tenants or all tenants\n   *\n   * @param tenantId - Optional specific tenant ID\n   * @returns Rotation results\n   */\n  async rotateKeys(tenantId?: string): Promise<KeyRotationResult> {\n    const startTime = Date.now();\n    const result: KeyRotationResult = {\n      rotated: 0,\n      failed: 0,\n      tenantIds: [],\n      errors: [],\n      duration: 0,\n    };\n\n    try {\n      // Get tenants that need rotation\n      const tenantsToRotate = tenantId\n        ? [tenantId]\n        : await this.getTenantsNeedingRotation();\n\n      for (const tid of tenantsToRotate) {\n        try {\n          await this.rotateKey(tid);\n          result.rotated++;\n          result.tenantIds.push(tid);\n        } catch (error) {\n          result.failed++;\n          result.errors.push({\n            tenantId: tid,\n            error: error instanceof Error ? error.message : String(error),\n          });\n        }\n      }\n\n      result.duration = Date.now() - startTime;\n      return result;\n    } catch (error) {\n      result.duration = Date.now() - startTime;\n      throw new KeyManagementError(\n        'Batch key rotation failed',\n        'BATCH_ROTATION_FAILED',\n        {\n          result,\n          originalError: error instanceof Error ? error.message : String(error),\n        }\n      );\n    }\n  }\n\n  /**\n   * Schedule automatic key rotation\n   * Should be called by a cron job or scheduled function\n   *\n   * @returns Promise that resolves when rotation is scheduled\n   */\n  async scheduleRotation(): Promise<void> {\n    try {\n      const tenantsNeedingRotation = await this.getTenantsNeedingRotation();\n\n      if (tenantsNeedingRotation.length === 0) {\n        console.info('No tenants need key rotation at this time');\n        return;\n      }\n\n      console.info(`Scheduling rotation for ${tenantsNeedingRotation.length} tenants`);\n\n      // Rotate keys in batches to avoid overwhelming the system\n      const batchSize = 10;\n      for (let i = 0; i < tenantsNeedingRotation.length; i += batchSize) {\n        const batch = tenantsNeedingRotation.slice(i, i + batchSize);\n        await Promise.allSettled(\n          batch.map((tenantId) => this.rotateKey(tenantId))\n        );\n      }\n\n      console.info('Key rotation scheduling completed');\n    } catch (error) {\n      console.error('Failed to schedule key rotation:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get key statistics\n   *\n   * @param tenantId - Optional tenant ID for specific stats\n   * @returns Key statistics\n   */\n  async getKeyStats(tenantId?: string): Promise<KeyStats> {\n    try {\n      const supabase = await createClient();\n      let query = supabase.from('encryption_keys').select('*');\n\n      if (tenantId) {\n        query = query.eq('tenant_id', tenantId);\n      }\n\n      const { data: keys, error } = await query;\n\n      if (error) {\n        throw new Error(`Failed to fetch key stats: ${error.message}`);\n      }\n\n      const now = new Date();\n      const stats: KeyStats = {\n        totalKeys: keys?.length || 0,\n        activeKeys: keys?.filter((k) => k.is_active).length || 0,\n        expiredKeys:\n          keys?.filter((k) => new Date(k.expires_at) < now).length || 0,\n        pendingRotation: 0,\n        averageKeyAge: 0,\n      };\n\n      // Calculate pending rotation\n      const warningDate = new Date();\n      warningDate.setDate(warningDate.getDate() + this.KEY_ROTATION_WARNING_DAYS);\n      stats.pendingRotation =\n        keys?.filter(\n          (k) =>\n            k.is_active &&\n            new Date(k.expires_at) <= warningDate &&\n            new Date(k.expires_at) > now\n        ).length || 0;\n\n      // Calculate average key age\n      if (keys && keys.length > 0) {\n        const totalAge = keys.reduce((sum, k) => {\n          const age = now.getTime() - new Date(k.created_at).getTime();\n          return sum + age / (1000 * 60 * 60 * 24); // Convert to days\n        }, 0);\n        stats.averageKeyAge = totalAge / keys.length;\n      }\n\n      return stats;\n    } catch (error) {\n      throw new KeyManagementError(\n        'Failed to get key statistics',\n        'GET_STATS_FAILED',\n        {\n          tenantId,\n          originalError: error instanceof Error ? error.message : String(error),\n        }\n      );\n    }\n  }\n\n  /**\n   * Get key version history for a tenant\n   *\n   * @param tenantId - Tenant identifier\n   * @returns Array of key versions\n   */\n  async getKeyHistory(tenantId: string): Promise<KeyVersion[]> {\n    try {\n      const supabase = await createClient();\n      const { data, error } = await supabase\n        .from('encryption_keys')\n        .select('*')\n        .eq('tenant_id', tenantId)\n        .order('version', { ascending: false });\n\n      if (error) {\n        throw new Error(`Failed to fetch key history: ${error.message}`);\n      }\n\n      return (\n        data?.map((row) => ({\n          id: row.id,\n          tenantId: row.tenant_id,\n          kmsKeyId: row.kms_key_id,\n          encryptedDataKey: row.encrypted_data_key,\n          version: row.version,\n          isActive: row.is_active,\n          createdAt: new Date(row.created_at),\n          rotatedAt: row.rotated_at ? new Date(row.rotated_at) : undefined,\n          expiresAt: new Date(row.expires_at),\n        })) || []\n      );\n    } catch (error) {\n      throw new KeyManagementError(\n        `Failed to get key history for tenant ${tenantId}`,\n        'GET_HISTORY_FAILED',\n        {\n          tenantId,\n          originalError: error instanceof Error ? error.message : String(error),\n        }\n      );\n    }\n  }\n\n  /**\n   * Clear key cache\n   *\n   * @param tenantId - Optional tenant ID to clear specific cache\n   */\n  clearCache(tenantId?: string): void {\n    if (tenantId) {\n      this.keyCache.delete(tenantId);\n    } else {\n      this.keyCache.clear();\n    }\n  }\n\n  /**\n   * Get active key version from database\n   */\n  private async getActiveKeyVersion(\n    tenantId: string\n  ): Promise<KeyVersion | null> {\n    const supabase = await createClient();\n    const { data, error } = await supabase\n      .from('encryption_keys')\n      .select('*')\n      .eq('tenant_id', tenantId)\n      .eq('is_active', true)\n      .single();\n\n    if (error || !data) {\n      return null;\n    }\n\n    return {\n      id: data.id,\n      tenantId: data.tenant_id,\n      kmsKeyId: data.kms_key_id,\n      encryptedDataKey: data.encrypted_data_key,\n      version: data.version,\n      isActive: data.is_active,\n      createdAt: new Date(data.created_at),\n      rotatedAt: data.rotated_at ? new Date(data.rotated_at) : undefined,\n      expiresAt: new Date(data.expires_at),\n    };\n  }\n\n  /**\n   * Get next version number for a tenant\n   */\n  private async getNextVersion(tenantId: string): Promise<number> {\n    const supabase = await createClient();\n    const { data, error } = await supabase\n      .from('encryption_keys')\n      .select('version')\n      .eq('tenant_id', tenantId)\n      .order('version', { ascending: false })\n      .limit(1)\n      .single();\n\n    if (error || !data) {\n      return 1;\n    }\n\n    return data.version + 1;\n  }\n\n  /**\n   * Get tenants that need key rotation\n   */\n  private async getTenantsNeedingRotation(): Promise<string[]> {\n    const supabase = await createClient();\n\n    // Get keys that are expired or expiring within warning period\n    const warningDate = new Date();\n    warningDate.setDate(warningDate.getDate() + this.KEY_ROTATION_WARNING_DAYS);\n\n    const { data, error } = await supabase\n      .from('encryption_keys')\n      .select('tenant_id')\n      .eq('is_active', true)\n      .lte('expires_at', warningDate.toISOString());\n\n    if (error || !data) {\n      return [];\n    }\n\n    // Return unique tenant IDs\n    return [...new Set(data.map((row) => row.tenant_id))];\n  }\n\n  /**\n   * Check if key is expired\n   */\n  private isKeyExpired(expiresAt: Date): boolean {\n    return new Date() > new Date(expiresAt);\n  }\n\n  /**\n   * Check if key is near expiration\n   */\n  private isKeyNearExpiration(expiresAt: Date): boolean {\n    const warningDate = new Date();\n    warningDate.setDate(warningDate.getDate() + this.KEY_ROTATION_WARNING_DAYS);\n    return new Date(expiresAt) <= warningDate;\n  }\n\n  /**\n   * Cache a decrypted key\n   */\n  private cacheKey(tenantId: string, key: Buffer, version: number): void {\n    this.keyCache.set(tenantId, {\n      key: Buffer.from(key),\n      timestamp: Date.now(),\n      version,\n    });\n  }\n\n  /**\n   * Get cached key if valid\n   */\n  private getCachedKey(tenantId: string): Buffer | null {\n    const cached = this.keyCache.get(tenantId);\n\n    if (!cached) {\n      return null;\n    }\n\n    // Check if cache entry is still valid\n    if (Date.now() - cached.timestamp > this.CACHE_TTL) {\n      this.keyCache.delete(tenantId);\n      return null;\n    }\n\n    return Buffer.from(cached.key);\n  }\n\n  /**\n   * Log key operation for audit trail\n   */\n  private async logKeyOperation(\n    operation: string,\n    tenantId: string,\n    version: number,\n    success: boolean,\n    error?: unknown\n  ): Promise<void> {\n    try {\n      const supabase = await createClient();\n      await supabase.from('key_rotation_log').insert({\n        tenant_id: tenantId,\n        operation,\n        from_version: version,\n        to_version: version,\n        success,\n        error_message: error instanceof Error ? error.message : undefined,\n        performed_at: new Date().toISOString(),\n      });\n    } catch (logError) {\n      console.error('Failed to log key operation:', logError);\n      // Don't throw - logging failure shouldn't stop the operation\n    }\n  }\n\n  /**\n   * Log key rotation\n   */\n  private async logKeyRotation(\n    tenantId: string,\n    fromVersion: number,\n    toVersion: number\n  ): Promise<void> {\n    try {\n      const supabase = await createClient();\n      await supabase.from('key_rotation_log').insert({\n        tenant_id: tenantId,\n        operation: 'rotate',\n        from_version: fromVersion,\n        to_version: toVersion,\n        success: true,\n        performed_at: new Date().toISOString(),\n      });\n    } catch (error) {\n      console.error('Failed to log key rotation:', error);\n    }\n  }\n}\n\n/**\n * Singleton key manager instance\n */\nlet keyManagerInstance: KeyManager | null = null;\n\n/**\n * Get or create key manager singleton\n *\n * @returns Key manager instance\n */\nexport function getKeyManager(): KeyManager {\n  if (!keyManagerInstance) {\n    keyManagerInstance = new KeyManager();\n  }\n  return keyManagerInstance;\n}\n\n/**\n * Reset key manager singleton (useful for testing)\n */\nexport function resetKeyManager(): void {\n  if (keyManagerInstance) {\n    keyManagerInstance.clearCache();\n    keyManagerInstance = null;\n  }\n}\n\n/**\n * Export for testing\n */\nexport const __testing__ = {\n  KeyManager,\n  resetKeyManager,\n};\n"],"names":["KeyManager","__testing__","getKeyManager","resetKeyManager","kmsClient","CACHE_TTL","KEY_ROTATION_DAYS","KEY_ROTATION_WARNING_DAYS","getKMSClient","keyCache","Map","getEncryptionKey","tenantId","options","forceRefresh","cached","getCachedKey","keyVersion","getActiveKeyVersion","createKey","isKeyExpired","expiresAt","console","warn","rotateKey","isKeyNearExpiration","info","catch","error","decrypted","decryptDataKey","encryptedDataKey","cacheKey","plaintext","version","KeyManagementError","originalError","Error","message","String","dataKey","generateDataKey","getNextVersion","Date","setDate","getDate","supabase","createClient","from","insert","tenant_id","kms_key_id","keyId","encrypted_data_key","ciphertext","is_active","created_at","toISOString","expires_at","logKeyOperation","currentKey","updateError","update","rotated_at","eq","id","newKey","logKeyRotation","clearCache","rotateKeys","startTime","now","result","rotated","failed","tenantIds","errors","duration","tenantsToRotate","getTenantsNeedingRotation","tid","push","scheduleRotation","tenantsNeedingRotation","length","batchSize","i","batch","slice","Promise","allSettled","map","getKeyStats","query","select","data","keys","stats","totalKeys","activeKeys","filter","k","expiredKeys","pendingRotation","averageKeyAge","warningDate","totalAge","reduce","sum","age","getTime","getKeyHistory","order","ascending","row","kmsKeyId","isActive","createdAt","rotatedAt","undefined","delete","clear","single","limit","lte","Set","key","set","Buffer","timestamp","get","operation","success","from_version","to_version","error_message","performed_at","logError","fromVersion","toVersion","keyManagerInstance"],"mappings":"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"}