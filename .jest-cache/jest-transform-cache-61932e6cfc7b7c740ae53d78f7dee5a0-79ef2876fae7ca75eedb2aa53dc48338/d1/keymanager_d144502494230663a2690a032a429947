21bf6ae17a167149266e1b9fe6e4e006
/**
 * Key Manager Service
 *
 * Manages encryption keys using AWS KMS with support for:
 * - Multi-tenant key isolation
 * - Automatic key rotation (90-day schedule)
 * - Key versioning for backward compatibility
 * - Tenant-specific key derivation
 * - Performance caching
 *
 * @module security/key-manager
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get KeyManager () {
        return KeyManager;
    },
    get __testing__ () {
        return __testing__;
    },
    get getKeyManager () {
        return getKeyManager;
    },
    get resetKeyManager () {
        return resetKeyManager;
    }
});
const _server = require("../supabase/server");
const _kmsclient = require("./kms-client");
const _types = require("../crypto/types");
class KeyManager {
    constructor(kmsClient){
        this.CACHE_TTL = 3600000; // 1 hour
        this.KEY_ROTATION_DAYS = 90;
        this.KEY_ROTATION_WARNING_DAYS = 7;
        this.kmsClient = kmsClient || (0, _kmsclient.getKMSClient)();
        this.keyCache = new Map();
    }
    /**
   * Get encryption key for a tenant
   * Automatically creates a new key if none exists
   *
   * @param tenantId - Tenant identifier
   * @param options - Retrieval options
   * @returns Decrypted encryption key
   * @throws {KeyManagementError} If key retrieval fails
   */ async getEncryptionKey(tenantId, options = {}) {
        try {
            // Check cache first unless force refresh
            if (!options.forceRefresh) {
                const cached = this.getCachedKey(tenantId);
                if (cached) {
                    return cached;
                }
            }
            // Get active key from database
            const keyVersion = await this.getActiveKeyVersion(tenantId);
            if (!keyVersion) {
                // No key exists, create one
                return await this.createKey(tenantId);
            }
            // Check if key is expired and needs rotation
            if (this.isKeyExpired(keyVersion.expiresAt)) {
                console.warn(`Key for tenant ${tenantId} has expired, rotating...`);
                return await this.rotateKey(tenantId);
            }
            // Check if key is approaching expiration
            if (this.isKeyNearExpiration(keyVersion.expiresAt)) {
                console.info(`Key for tenant ${tenantId} is approaching expiration`);
                // Trigger async rotation in background (don't wait)
                this.rotateKey(tenantId).catch((error)=>{
                    console.error(`Background key rotation failed for ${tenantId}:`, error);
                });
            }
            // Decrypt the data key using KMS
            const decrypted = await this.kmsClient.decryptDataKey(keyVersion.encryptedDataKey, tenantId);
            // Cache the decrypted key
            this.cacheKey(tenantId, decrypted.plaintext, keyVersion.version);
            return decrypted.plaintext;
        } catch (error) {
            throw new _types.KeyManagementError(`Failed to get encryption key for tenant ${tenantId}`, 'GET_KEY_FAILED', {
                tenantId,
                originalError: error instanceof Error ? error.message : String(error)
            });
        }
    }
    /**
   * Create a new encryption key for a tenant
   *
   * @param tenantId - Tenant identifier
   * @returns Newly created encryption key
   * @throws {KeyManagementError} If key creation fails
   */ async createKey(tenantId) {
        try {
            // Generate data key from KMS
            const dataKey = await this.kmsClient.generateDataKey(tenantId);
            // Get the next version number
            const version = await this.getNextVersion(tenantId);
            // Calculate expiration date (90 days from now)
            const expiresAt = new Date();
            expiresAt.setDate(expiresAt.getDate() + this.KEY_ROTATION_DAYS);
            // Store in database
            const supabase = await (0, _server.createClient)();
            const { error } = await supabase.from('encryption_keys').insert({
                tenant_id: tenantId,
                kms_key_id: dataKey.keyId,
                encrypted_data_key: dataKey.ciphertext,
                version: version,
                is_active: true,
                created_at: new Date().toISOString(),
                expires_at: expiresAt.toISOString()
            });
            if (error) {
                throw new Error(`Database insert failed: ${error.message}`);
            }
            // Log key creation
            await this.logKeyOperation('create', tenantId, version, true);
            // Cache the key
            this.cacheKey(tenantId, dataKey.plaintext, version);
            return dataKey.plaintext;
        } catch (error) {
            await this.logKeyOperation('create', tenantId, 0, false, error);
            throw new _types.KeyManagementError(`Failed to create key for tenant ${tenantId}`, 'CREATE_KEY_FAILED', {
                tenantId,
                originalError: error instanceof Error ? error.message : String(error)
            });
        }
    }
    /**
   * Rotate encryption key for a tenant
   *
   * @param tenantId - Tenant identifier
   * @returns New encryption key
   * @throws {KeyManagementError} If rotation fails
   */ async rotateKey(tenantId) {
        try {
            const supabase = await (0, _server.createClient)();
            // Get current active key
            const currentKey = await this.getActiveKeyVersion(tenantId);
            if (!currentKey) {
                throw new Error('No active key found to rotate');
            }
            // Mark current key as inactive and set rotated_at
            const { error: updateError } = await supabase.from('encryption_keys').update({
                is_active: false,
                rotated_at: new Date().toISOString()
            }).eq('id', currentKey.id);
            if (updateError) {
                throw new Error(`Failed to deactivate old key: ${updateError.message}`);
            }
            // Create new key
            const newKey = await this.createKey(tenantId);
            // Log rotation
            await this.logKeyRotation(tenantId, currentKey.version, currentKey.version + 1);
            // Clear cache to force refresh
            this.clearCache(tenantId);
            return newKey;
        } catch (error) {
            throw new _types.KeyManagementError(`Failed to rotate key for tenant ${tenantId}`, 'ROTATE_KEY_FAILED', {
                tenantId,
                originalError: error instanceof Error ? error.message : String(error)
            });
        }
    }
    /**
   * Rotate keys for multiple tenants or all tenants
   *
   * @param tenantId - Optional specific tenant ID
   * @returns Rotation results
   */ async rotateKeys(tenantId) {
        const startTime = Date.now();
        const result = {
            rotated: 0,
            failed: 0,
            tenantIds: [],
            errors: [],
            duration: 0
        };
        try {
            // Get tenants that need rotation
            const tenantsToRotate = tenantId ? [
                tenantId
            ] : await this.getTenantsNeedingRotation();
            for (const tid of tenantsToRotate){
                try {
                    await this.rotateKey(tid);
                    result.rotated++;
                    result.tenantIds.push(tid);
                } catch (error) {
                    result.failed++;
                    result.errors.push({
                        tenantId: tid,
                        error: error instanceof Error ? error.message : String(error)
                    });
                }
            }
            result.duration = Date.now() - startTime;
            return result;
        } catch (error) {
            result.duration = Date.now() - startTime;
            throw new _types.KeyManagementError('Batch key rotation failed', 'BATCH_ROTATION_FAILED', {
                result,
                originalError: error instanceof Error ? error.message : String(error)
            });
        }
    }
    /**
   * Schedule automatic key rotation
   * Should be called by a cron job or scheduled function
   *
   * @returns Promise that resolves when rotation is scheduled
   */ async scheduleRotation() {
        try {
            const tenantsNeedingRotation = await this.getTenantsNeedingRotation();
            if (tenantsNeedingRotation.length === 0) {
                console.info('No tenants need key rotation at this time');
                return;
            }
            console.info(`Scheduling rotation for ${tenantsNeedingRotation.length} tenants`);
            // Rotate keys in batches to avoid overwhelming the system
            const batchSize = 10;
            for(let i = 0; i < tenantsNeedingRotation.length; i += batchSize){
                const batch = tenantsNeedingRotation.slice(i, i + batchSize);
                await Promise.allSettled(batch.map((tenantId)=>this.rotateKey(tenantId)));
            }
            console.info('Key rotation scheduling completed');
        } catch (error) {
            console.error('Failed to schedule key rotation:', error);
            throw error;
        }
    }
    /**
   * Get key statistics
   *
   * @param tenantId - Optional tenant ID for specific stats
   * @returns Key statistics
   */ async getKeyStats(tenantId) {
        try {
            const supabase = await (0, _server.createClient)();
            let query = supabase.from('encryption_keys').select('*');
            if (tenantId) {
                query = query.eq('tenant_id', tenantId);
            }
            const { data: keys, error } = await query;
            if (error) {
                throw new Error(`Failed to fetch key stats: ${error.message}`);
            }
            const now = new Date();
            const stats = {
                totalKeys: keys?.length || 0,
                activeKeys: keys?.filter((k)=>k.is_active).length || 0,
                expiredKeys: keys?.filter((k)=>new Date(k.expires_at) < now).length || 0,
                pendingRotation: 0,
                averageKeyAge: 0
            };
            // Calculate pending rotation
            const warningDate = new Date();
            warningDate.setDate(warningDate.getDate() + this.KEY_ROTATION_WARNING_DAYS);
            stats.pendingRotation = keys?.filter((k)=>k.is_active && new Date(k.expires_at) <= warningDate && new Date(k.expires_at) > now).length || 0;
            // Calculate average key age
            if (keys && keys.length > 0) {
                const totalAge = keys.reduce((sum, k)=>{
                    const age = now.getTime() - new Date(k.created_at).getTime();
                    return sum + age / (1000 * 60 * 60 * 24); // Convert to days
                }, 0);
                stats.averageKeyAge = totalAge / keys.length;
            }
            return stats;
        } catch (error) {
            throw new _types.KeyManagementError('Failed to get key statistics', 'GET_STATS_FAILED', {
                tenantId,
                originalError: error instanceof Error ? error.message : String(error)
            });
        }
    }
    /**
   * Get key version history for a tenant
   *
   * @param tenantId - Tenant identifier
   * @returns Array of key versions
   */ async getKeyHistory(tenantId) {
        try {
            const supabase = await (0, _server.createClient)();
            const { data, error } = await supabase.from('encryption_keys').select('*').eq('tenant_id', tenantId).order('version', {
                ascending: false
            });
            if (error) {
                throw new Error(`Failed to fetch key history: ${error.message}`);
            }
            return data?.map((row)=>({
                    id: row.id,
                    tenantId: row.tenant_id,
                    kmsKeyId: row.kms_key_id,
                    encryptedDataKey: row.encrypted_data_key,
                    version: row.version,
                    isActive: row.is_active,
                    createdAt: new Date(row.created_at),
                    rotatedAt: row.rotated_at ? new Date(row.rotated_at) : undefined,
                    expiresAt: new Date(row.expires_at)
                })) || [];
        } catch (error) {
            throw new _types.KeyManagementError(`Failed to get key history for tenant ${tenantId}`, 'GET_HISTORY_FAILED', {
                tenantId,
                originalError: error instanceof Error ? error.message : String(error)
            });
        }
    }
    /**
   * Clear key cache
   *
   * @param tenantId - Optional tenant ID to clear specific cache
   */ clearCache(tenantId) {
        if (tenantId) {
            this.keyCache.delete(tenantId);
        } else {
            this.keyCache.clear();
        }
    }
    /**
   * Get active key version from database
   */ async getActiveKeyVersion(tenantId) {
        const supabase = await (0, _server.createClient)();
        const { data, error } = await supabase.from('encryption_keys').select('*').eq('tenant_id', tenantId).eq('is_active', true).single();
        if (error || !data) {
            return null;
        }
        return {
            id: data.id,
            tenantId: data.tenant_id,
            kmsKeyId: data.kms_key_id,
            encryptedDataKey: data.encrypted_data_key,
            version: data.version,
            isActive: data.is_active,
            createdAt: new Date(data.created_at),
            rotatedAt: data.rotated_at ? new Date(data.rotated_at) : undefined,
            expiresAt: new Date(data.expires_at)
        };
    }
    /**
   * Get next version number for a tenant
   */ async getNextVersion(tenantId) {
        const supabase = await (0, _server.createClient)();
        const { data, error } = await supabase.from('encryption_keys').select('version').eq('tenant_id', tenantId).order('version', {
            ascending: false
        }).limit(1).single();
        if (error || !data) {
            return 1;
        }
        return data.version + 1;
    }
    /**
   * Get tenants that need key rotation
   */ async getTenantsNeedingRotation() {
        const supabase = await (0, _server.createClient)();
        // Get keys that are expired or expiring within warning period
        const warningDate = new Date();
        warningDate.setDate(warningDate.getDate() + this.KEY_ROTATION_WARNING_DAYS);
        const { data, error } = await supabase.from('encryption_keys').select('tenant_id').eq('is_active', true).lte('expires_at', warningDate.toISOString());
        if (error || !data) {
            return [];
        }
        // Return unique tenant IDs
        return [
            ...new Set(data.map((row)=>row.tenant_id))
        ];
    }
    /**
   * Check if key is expired
   */ isKeyExpired(expiresAt) {
        return new Date() > new Date(expiresAt);
    }
    /**
   * Check if key is near expiration
   */ isKeyNearExpiration(expiresAt) {
        const warningDate = new Date();
        warningDate.setDate(warningDate.getDate() + this.KEY_ROTATION_WARNING_DAYS);
        return new Date(expiresAt) <= warningDate;
    }
    /**
   * Cache a decrypted key
   */ cacheKey(tenantId, key, version) {
        this.keyCache.set(tenantId, {
            key: Buffer.from(key),
            timestamp: Date.now(),
            version
        });
    }
    /**
   * Get cached key if valid
   */ getCachedKey(tenantId) {
        const cached = this.keyCache.get(tenantId);
        if (!cached) {
            return null;
        }
        // Check if cache entry is still valid
        if (Date.now() - cached.timestamp > this.CACHE_TTL) {
            this.keyCache.delete(tenantId);
            return null;
        }
        return Buffer.from(cached.key);
    }
    /**
   * Log key operation for audit trail
   */ async logKeyOperation(operation, tenantId, version, success, error) {
        try {
            const supabase = await (0, _server.createClient)();
            await supabase.from('key_rotation_log').insert({
                tenant_id: tenantId,
                operation,
                from_version: version,
                to_version: version,
                success,
                error_message: error instanceof Error ? error.message : undefined,
                performed_at: new Date().toISOString()
            });
        } catch (logError) {
            console.error('Failed to log key operation:', logError);
        // Don't throw - logging failure shouldn't stop the operation
        }
    }
    /**
   * Log key rotation
   */ async logKeyRotation(tenantId, fromVersion, toVersion) {
        try {
            const supabase = await (0, _server.createClient)();
            await supabase.from('key_rotation_log').insert({
                tenant_id: tenantId,
                operation: 'rotate',
                from_version: fromVersion,
                to_version: toVersion,
                success: true,
                performed_at: new Date().toISOString()
            });
        } catch (error) {
            console.error('Failed to log key rotation:', error);
        }
    }
}
/**
 * Singleton key manager instance
 */ let keyManagerInstance = null;
function getKeyManager() {
    if (!keyManagerInstance) {
        keyManagerInstance = new KeyManager();
    }
    return keyManagerInstance;
}
function resetKeyManager() {
    if (keyManagerInstance) {
        keyManagerInstance.clearCache();
        keyManagerInstance = null;
    }
}
const __testing__ = {
    KeyManager,
    resetKeyManager
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxBaSBQcm9qZWN0ZW5cXEFEU2FwcFxcc3JjXFxsaWJcXHNlY3VyaXR5XFxrZXktbWFuYWdlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEtleSBNYW5hZ2VyIFNlcnZpY2VcbiAqXG4gKiBNYW5hZ2VzIGVuY3J5cHRpb24ga2V5cyB1c2luZyBBV1MgS01TIHdpdGggc3VwcG9ydCBmb3I6XG4gKiAtIE11bHRpLXRlbmFudCBrZXkgaXNvbGF0aW9uXG4gKiAtIEF1dG9tYXRpYyBrZXkgcm90YXRpb24gKDkwLWRheSBzY2hlZHVsZSlcbiAqIC0gS2V5IHZlcnNpb25pbmcgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAqIC0gVGVuYW50LXNwZWNpZmljIGtleSBkZXJpdmF0aW9uXG4gKiAtIFBlcmZvcm1hbmNlIGNhY2hpbmdcbiAqXG4gKiBAbW9kdWxlIHNlY3VyaXR5L2tleS1tYW5hZ2VyXG4gKi9cblxuaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQC9saWIvc3VwYWJhc2Uvc2VydmVyJztcbmltcG9ydCB7IGdldEtNU0NsaWVudCwgS01TQ2xpZW50LCBEYXRhS2V5UmVzdWx0IH0gZnJvbSAnLi9rbXMtY2xpZW50JztcbmltcG9ydCB7IEtleU1hbmFnZW1lbnRFcnJvciB9IGZyb20gJ0AvbGliL2NyeXB0by90eXBlcyc7XG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuLyoqXG4gKiBLZXkgdmVyc2lvbiBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEtleVZlcnNpb24ge1xuICAvKiogVmVyc2lvbiBJRCAqL1xuICBpZDogc3RyaW5nO1xuICAvKiogVGVuYW50IElEIHRoaXMga2V5IGJlbG9uZ3MgdG8gKi9cbiAgdGVuYW50SWQ6IHN0cmluZztcbiAgLyoqIEtNUyBLZXkgSUQgdXNlZCAqL1xuICBrbXNLZXlJZDogc3RyaW5nO1xuICAvKiogRW5jcnlwdGVkIGRhdGEga2V5IChjaXBoZXJ0ZXh0KSAqL1xuICBlbmNyeXB0ZWREYXRhS2V5OiBzdHJpbmc7XG4gIC8qKiBLZXkgdmVyc2lvbiBudW1iZXIgKi9cbiAgdmVyc2lvbjogbnVtYmVyO1xuICAvKiogV2hldGhlciB0aGlzIGlzIHRoZSBjdXJyZW50L2FjdGl2ZSBrZXkgKi9cbiAgaXNBY3RpdmU6IGJvb2xlYW47XG4gIC8qKiBXaGVuIHRoZSBrZXkgd2FzIGNyZWF0ZWQgKi9cbiAgY3JlYXRlZEF0OiBEYXRlO1xuICAvKiogV2hlbiB0aGUga2V5IHdhcyByb3RhdGVkIChudWxsIGlmIHN0aWxsIGFjdGl2ZSkgKi9cbiAgcm90YXRlZEF0PzogRGF0ZTtcbiAgLyoqIFdoZW4gdGhlIGtleSBleHBpcmVzICg5MCBkYXlzIGZyb20gY3JlYXRpb24pICovXG4gIGV4cGlyZXNBdDogRGF0ZTtcbn1cblxuLyoqXG4gKiBLZXkgcmV0cmlldmFsIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLZXlSZXRyaWV2YWxPcHRpb25zIHtcbiAgLyoqIEZvcmNlIHJlZnJlc2ggZnJvbSBLTVMgKHNraXAgY2FjaGUpICovXG4gIGZvcmNlUmVmcmVzaD86IGJvb2xlYW47XG4gIC8qKiBTcGVjaWZpYyBrZXkgdmVyc2lvbiB0byByZXRyaWV2ZSAqL1xuICB2ZXJzaW9uPzogbnVtYmVyO1xuICAvKiogSW5jbHVkZSBleHBpcmVkIGtleXMgKi9cbiAgaW5jbHVkZUV4cGlyZWQ/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEtleSByb3RhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLZXlSb3RhdGlvblJlc3VsdCB7XG4gIC8qKiBOdW1iZXIgb2Yga2V5cyBzdWNjZXNzZnVsbHkgcm90YXRlZCAqL1xuICByb3RhdGVkOiBudW1iZXI7XG4gIC8qKiBOdW1iZXIgb2Yga2V5cyB0aGF0IGZhaWxlZCByb3RhdGlvbiAqL1xuICBmYWlsZWQ6IG51bWJlcjtcbiAgLyoqIExpc3Qgb2YgdGVuYW50IElEcyB0aGF0IHdlcmUgcm90YXRlZCAqL1xuICB0ZW5hbnRJZHM6IHN0cmluZ1tdO1xuICAvKiogTGlzdCBvZiBlcnJvcnMgdGhhdCBvY2N1cnJlZCAqL1xuICBlcnJvcnM6IEFycmF5PHsgdGVuYW50SWQ6IHN0cmluZzsgZXJyb3I6IHN0cmluZyB9PjtcbiAgLyoqIER1cmF0aW9uIG9mIHJvdGF0aW9uIGluIG1pbGxpc2Vjb25kcyAqL1xuICBkdXJhdGlvbjogbnVtYmVyO1xufVxuXG4vKipcbiAqIEtleSBzdGF0aXN0aWNzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS2V5U3RhdHMge1xuICAvKiogVG90YWwga2V5cyBtYW5hZ2VkICovXG4gIHRvdGFsS2V5czogbnVtYmVyO1xuICAvKiogQWN0aXZlIGtleXMgKi9cbiAgYWN0aXZlS2V5czogbnVtYmVyO1xuICAvKiogRXhwaXJlZCBrZXlzICovXG4gIGV4cGlyZWRLZXlzOiBudW1iZXI7XG4gIC8qKiBLZXlzIHBlbmRpbmcgcm90YXRpb24gKi9cbiAgcGVuZGluZ1JvdGF0aW9uOiBudW1iZXI7XG4gIC8qKiBBdmVyYWdlIGtleSBhZ2UgaW4gZGF5cyAqL1xuICBhdmVyYWdlS2V5QWdlOiBudW1iZXI7XG59XG5cbi8qKlxuICogS2V5IE1hbmFnZXIgZm9yIGVuY3J5cHRpb24ga2V5IGxpZmVjeWNsZSBtYW5hZ2VtZW50XG4gKi9cbmV4cG9ydCBjbGFzcyBLZXlNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBrbXNDbGllbnQ6IEtNU0NsaWVudDtcbiAgcHJpdmF0ZSBrZXlDYWNoZTogTWFwPHN0cmluZywgeyBrZXk6IEJ1ZmZlcjsgdGltZXN0YW1wOiBudW1iZXI7IHZlcnNpb246IG51bWJlciB9PjtcbiAgcHJpdmF0ZSByZWFkb25seSBDQUNIRV9UVEwgPSAzNjAwMDAwOyAvLyAxIGhvdXJcbiAgcHJpdmF0ZSByZWFkb25seSBLRVlfUk9UQVRJT05fREFZUyA9IDkwO1xuICBwcml2YXRlIHJlYWRvbmx5IEtFWV9ST1RBVElPTl9XQVJOSU5HX0RBWVMgPSA3O1xuXG4gIGNvbnN0cnVjdG9yKGttc0NsaWVudD86IEtNU0NsaWVudCkge1xuICAgIHRoaXMua21zQ2xpZW50ID0ga21zQ2xpZW50IHx8IGdldEtNU0NsaWVudCgpO1xuICAgIHRoaXMua2V5Q2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGVuY3J5cHRpb24ga2V5IGZvciBhIHRlbmFudFxuICAgKiBBdXRvbWF0aWNhbGx5IGNyZWF0ZXMgYSBuZXcga2V5IGlmIG5vbmUgZXhpc3RzXG4gICAqXG4gICAqIEBwYXJhbSB0ZW5hbnRJZCAtIFRlbmFudCBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmV0cmlldmFsIG9wdGlvbnNcbiAgICogQHJldHVybnMgRGVjcnlwdGVkIGVuY3J5cHRpb24ga2V5XG4gICAqIEB0aHJvd3Mge0tleU1hbmFnZW1lbnRFcnJvcn0gSWYga2V5IHJldHJpZXZhbCBmYWlsc1xuICAgKi9cbiAgYXN5bmMgZ2V0RW5jcnlwdGlvbktleShcbiAgICB0ZW5hbnRJZDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IEtleVJldHJpZXZhbE9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBjYWNoZSBmaXJzdCB1bmxlc3MgZm9yY2UgcmVmcmVzaFxuICAgICAgaWYgKCFvcHRpb25zLmZvcmNlUmVmcmVzaCkge1xuICAgICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLmdldENhY2hlZEtleSh0ZW5hbnRJZCk7XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBhY3RpdmUga2V5IGZyb20gZGF0YWJhc2VcbiAgICAgIGNvbnN0IGtleVZlcnNpb24gPSBhd2FpdCB0aGlzLmdldEFjdGl2ZUtleVZlcnNpb24odGVuYW50SWQpO1xuXG4gICAgICBpZiAoIWtleVZlcnNpb24pIHtcbiAgICAgICAgLy8gTm8ga2V5IGV4aXN0cywgY3JlYXRlIG9uZVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jcmVhdGVLZXkodGVuYW50SWQpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiBrZXkgaXMgZXhwaXJlZCBhbmQgbmVlZHMgcm90YXRpb25cbiAgICAgIGlmICh0aGlzLmlzS2V5RXhwaXJlZChrZXlWZXJzaW9uLmV4cGlyZXNBdCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBLZXkgZm9yIHRlbmFudCAke3RlbmFudElkfSBoYXMgZXhwaXJlZCwgcm90YXRpbmcuLi5gKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucm90YXRlS2V5KHRlbmFudElkKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYga2V5IGlzIGFwcHJvYWNoaW5nIGV4cGlyYXRpb25cbiAgICAgIGlmICh0aGlzLmlzS2V5TmVhckV4cGlyYXRpb24oa2V5VmVyc2lvbi5leHBpcmVzQXQpKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhgS2V5IGZvciB0ZW5hbnQgJHt0ZW5hbnRJZH0gaXMgYXBwcm9hY2hpbmcgZXhwaXJhdGlvbmApO1xuICAgICAgICAvLyBUcmlnZ2VyIGFzeW5jIHJvdGF0aW9uIGluIGJhY2tncm91bmQgKGRvbid0IHdhaXQpXG4gICAgICAgIHRoaXMucm90YXRlS2V5KHRlbmFudElkKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBCYWNrZ3JvdW5kIGtleSByb3RhdGlvbiBmYWlsZWQgZm9yICR7dGVuYW50SWR9OmAsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERlY3J5cHQgdGhlIGRhdGEga2V5IHVzaW5nIEtNU1xuICAgICAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgdGhpcy5rbXNDbGllbnQuZGVjcnlwdERhdGFLZXkoXG4gICAgICAgIGtleVZlcnNpb24uZW5jcnlwdGVkRGF0YUtleSxcbiAgICAgICAgdGVuYW50SWRcbiAgICAgICk7XG5cbiAgICAgIC8vIENhY2hlIHRoZSBkZWNyeXB0ZWQga2V5XG4gICAgICB0aGlzLmNhY2hlS2V5KHRlbmFudElkLCBkZWNyeXB0ZWQucGxhaW50ZXh0LCBrZXlWZXJzaW9uLnZlcnNpb24pO1xuXG4gICAgICByZXR1cm4gZGVjcnlwdGVkLnBsYWludGV4dDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEtleU1hbmFnZW1lbnRFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBnZXQgZW5jcnlwdGlvbiBrZXkgZm9yIHRlbmFudCAke3RlbmFudElkfWAsXG4gICAgICAgICdHRVRfS0VZX0ZBSUxFRCcsXG4gICAgICAgIHtcbiAgICAgICAgICB0ZW5hbnRJZCxcbiAgICAgICAgICBvcmlnaW5hbEVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvciksXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBlbmNyeXB0aW9uIGtleSBmb3IgYSB0ZW5hbnRcbiAgICpcbiAgICogQHBhcmFtIHRlbmFudElkIC0gVGVuYW50IGlkZW50aWZpZXJcbiAgICogQHJldHVybnMgTmV3bHkgY3JlYXRlZCBlbmNyeXB0aW9uIGtleVxuICAgKiBAdGhyb3dzIHtLZXlNYW5hZ2VtZW50RXJyb3J9IElmIGtleSBjcmVhdGlvbiBmYWlsc1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlS2V5KHRlbmFudElkOiBzdHJpbmcpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZW5lcmF0ZSBkYXRhIGtleSBmcm9tIEtNU1xuICAgICAgY29uc3QgZGF0YUtleSA9IGF3YWl0IHRoaXMua21zQ2xpZW50LmdlbmVyYXRlRGF0YUtleSh0ZW5hbnRJZCk7XG5cbiAgICAgIC8vIEdldCB0aGUgbmV4dCB2ZXJzaW9uIG51bWJlclxuICAgICAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IHRoaXMuZ2V0TmV4dFZlcnNpb24odGVuYW50SWQpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgZXhwaXJhdGlvbiBkYXRlICg5MCBkYXlzIGZyb20gbm93KVxuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gbmV3IERhdGUoKTtcbiAgICAgIGV4cGlyZXNBdC5zZXREYXRlKGV4cGlyZXNBdC5nZXREYXRlKCkgKyB0aGlzLktFWV9ST1RBVElPTl9EQVlTKTtcblxuICAgICAgLy8gU3RvcmUgaW4gZGF0YWJhc2VcbiAgICAgIGNvbnN0IHN1cGFiYXNlID0gYXdhaXQgY3JlYXRlQ2xpZW50KCk7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdlbmNyeXB0aW9uX2tleXMnKS5pbnNlcnQoe1xuICAgICAgICB0ZW5hbnRfaWQ6IHRlbmFudElkLFxuICAgICAgICBrbXNfa2V5X2lkOiBkYXRhS2V5LmtleUlkLFxuICAgICAgICBlbmNyeXB0ZWRfZGF0YV9rZXk6IGRhdGFLZXkuY2lwaGVydGV4dCxcbiAgICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdC50b0lTT1N0cmluZygpLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFiYXNlIGluc2VydCBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cblxuICAgICAgLy8gTG9nIGtleSBjcmVhdGlvblxuICAgICAgYXdhaXQgdGhpcy5sb2dLZXlPcGVyYXRpb24oJ2NyZWF0ZScsIHRlbmFudElkLCB2ZXJzaW9uLCB0cnVlKTtcblxuICAgICAgLy8gQ2FjaGUgdGhlIGtleVxuICAgICAgdGhpcy5jYWNoZUtleSh0ZW5hbnRJZCwgZGF0YUtleS5wbGFpbnRleHQsIHZlcnNpb24pO1xuXG4gICAgICByZXR1cm4gZGF0YUtleS5wbGFpbnRleHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGF3YWl0IHRoaXMubG9nS2V5T3BlcmF0aW9uKCdjcmVhdGUnLCB0ZW5hbnRJZCwgMCwgZmFsc2UsIGVycm9yKTtcblxuICAgICAgdGhyb3cgbmV3IEtleU1hbmFnZW1lbnRFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBjcmVhdGUga2V5IGZvciB0ZW5hbnQgJHt0ZW5hbnRJZH1gLFxuICAgICAgICAnQ1JFQVRFX0tFWV9GQUlMRUQnLFxuICAgICAgICB7XG4gICAgICAgICAgdGVuYW50SWQsXG4gICAgICAgICAgb3JpZ2luYWxFcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSb3RhdGUgZW5jcnlwdGlvbiBrZXkgZm9yIGEgdGVuYW50XG4gICAqXG4gICAqIEBwYXJhbSB0ZW5hbnRJZCAtIFRlbmFudCBpZGVudGlmaWVyXG4gICAqIEByZXR1cm5zIE5ldyBlbmNyeXB0aW9uIGtleVxuICAgKiBAdGhyb3dzIHtLZXlNYW5hZ2VtZW50RXJyb3J9IElmIHJvdGF0aW9uIGZhaWxzXG4gICAqL1xuICBhc3luYyByb3RhdGVLZXkodGVuYW50SWQ6IHN0cmluZyk6IFByb21pc2U8QnVmZmVyPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN1cGFiYXNlID0gYXdhaXQgY3JlYXRlQ2xpZW50KCk7XG5cbiAgICAgIC8vIEdldCBjdXJyZW50IGFjdGl2ZSBrZXlcbiAgICAgIGNvbnN0IGN1cnJlbnRLZXkgPSBhd2FpdCB0aGlzLmdldEFjdGl2ZUtleVZlcnNpb24odGVuYW50SWQpO1xuICAgICAgaWYgKCFjdXJyZW50S2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWN0aXZlIGtleSBmb3VuZCB0byByb3RhdGUnKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFyayBjdXJyZW50IGtleSBhcyBpbmFjdGl2ZSBhbmQgc2V0IHJvdGF0ZWRfYXRcbiAgICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnZW5jcnlwdGlvbl9rZXlzJylcbiAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgaXNfYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICByb3RhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pXG4gICAgICAgIC5lcSgnaWQnLCBjdXJyZW50S2V5LmlkKTtcblxuICAgICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlYWN0aXZhdGUgb2xkIGtleTogJHt1cGRhdGVFcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgbmV3IGtleVxuICAgICAgY29uc3QgbmV3S2V5ID0gYXdhaXQgdGhpcy5jcmVhdGVLZXkodGVuYW50SWQpO1xuXG4gICAgICAvLyBMb2cgcm90YXRpb25cbiAgICAgIGF3YWl0IHRoaXMubG9nS2V5Um90YXRpb24odGVuYW50SWQsIGN1cnJlbnRLZXkudmVyc2lvbiwgY3VycmVudEtleS52ZXJzaW9uICsgMSk7XG5cbiAgICAgIC8vIENsZWFyIGNhY2hlIHRvIGZvcmNlIHJlZnJlc2hcbiAgICAgIHRoaXMuY2xlYXJDYWNoZSh0ZW5hbnRJZCk7XG5cbiAgICAgIHJldHVybiBuZXdLZXk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBLZXlNYW5hZ2VtZW50RXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gcm90YXRlIGtleSBmb3IgdGVuYW50ICR7dGVuYW50SWR9YCxcbiAgICAgICAgJ1JPVEFURV9LRVlfRkFJTEVEJyxcbiAgICAgICAge1xuICAgICAgICAgIHRlbmFudElkLFxuICAgICAgICAgIG9yaWdpbmFsRXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUm90YXRlIGtleXMgZm9yIG11bHRpcGxlIHRlbmFudHMgb3IgYWxsIHRlbmFudHNcbiAgICpcbiAgICogQHBhcmFtIHRlbmFudElkIC0gT3B0aW9uYWwgc3BlY2lmaWMgdGVuYW50IElEXG4gICAqIEByZXR1cm5zIFJvdGF0aW9uIHJlc3VsdHNcbiAgICovXG4gIGFzeW5jIHJvdGF0ZUtleXModGVuYW50SWQ/OiBzdHJpbmcpOiBQcm9taXNlPEtleVJvdGF0aW9uUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCByZXN1bHQ6IEtleVJvdGF0aW9uUmVzdWx0ID0ge1xuICAgICAgcm90YXRlZDogMCxcbiAgICAgIGZhaWxlZDogMCxcbiAgICAgIHRlbmFudElkczogW10sXG4gICAgICBlcnJvcnM6IFtdLFxuICAgICAgZHVyYXRpb246IDAsXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgdGVuYW50cyB0aGF0IG5lZWQgcm90YXRpb25cbiAgICAgIGNvbnN0IHRlbmFudHNUb1JvdGF0ZSA9IHRlbmFudElkXG4gICAgICAgID8gW3RlbmFudElkXVxuICAgICAgICA6IGF3YWl0IHRoaXMuZ2V0VGVuYW50c05lZWRpbmdSb3RhdGlvbigpO1xuXG4gICAgICBmb3IgKGNvbnN0IHRpZCBvZiB0ZW5hbnRzVG9Sb3RhdGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnJvdGF0ZUtleSh0aWQpO1xuICAgICAgICAgIHJlc3VsdC5yb3RhdGVkKys7XG4gICAgICAgICAgcmVzdWx0LnRlbmFudElkcy5wdXNoKHRpZCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVzdWx0LmZhaWxlZCsrO1xuICAgICAgICAgIHJlc3VsdC5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICB0ZW5hbnRJZDogdGlkLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQuZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVzdWx0LmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIHRocm93IG5ldyBLZXlNYW5hZ2VtZW50RXJyb3IoXG4gICAgICAgICdCYXRjaCBrZXkgcm90YXRpb24gZmFpbGVkJyxcbiAgICAgICAgJ0JBVENIX1JPVEFUSU9OX0ZBSUxFRCcsXG4gICAgICAgIHtcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgb3JpZ2luYWxFcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZSBhdXRvbWF0aWMga2V5IHJvdGF0aW9uXG4gICAqIFNob3VsZCBiZSBjYWxsZWQgYnkgYSBjcm9uIGpvYiBvciBzY2hlZHVsZWQgZnVuY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gcm90YXRpb24gaXMgc2NoZWR1bGVkXG4gICAqL1xuICBhc3luYyBzY2hlZHVsZVJvdGF0aW9uKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0ZW5hbnRzTmVlZGluZ1JvdGF0aW9uID0gYXdhaXQgdGhpcy5nZXRUZW5hbnRzTmVlZGluZ1JvdGF0aW9uKCk7XG5cbiAgICAgIGlmICh0ZW5hbnRzTmVlZGluZ1JvdGF0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmluZm8oJ05vIHRlbmFudHMgbmVlZCBrZXkgcm90YXRpb24gYXQgdGhpcyB0aW1lJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5pbmZvKGBTY2hlZHVsaW5nIHJvdGF0aW9uIGZvciAke3RlbmFudHNOZWVkaW5nUm90YXRpb24ubGVuZ3RofSB0ZW5hbnRzYCk7XG5cbiAgICAgIC8vIFJvdGF0ZSBrZXlzIGluIGJhdGNoZXMgdG8gYXZvaWQgb3ZlcndoZWxtaW5nIHRoZSBzeXN0ZW1cbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IDEwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW5hbnRzTmVlZGluZ1JvdGF0aW9uLmxlbmd0aDsgaSArPSBiYXRjaFNpemUpIHtcbiAgICAgICAgY29uc3QgYmF0Y2ggPSB0ZW5hbnRzTmVlZGluZ1JvdGF0aW9uLnNsaWNlKGksIGkgKyBiYXRjaFNpemUpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoXG4gICAgICAgICAgYmF0Y2gubWFwKCh0ZW5hbnRJZCkgPT4gdGhpcy5yb3RhdGVLZXkodGVuYW50SWQpKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmluZm8oJ0tleSByb3RhdGlvbiBzY2hlZHVsaW5nIGNvbXBsZXRlZCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2NoZWR1bGUga2V5IHJvdGF0aW9uOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQga2V5IHN0YXRpc3RpY3NcbiAgICpcbiAgICogQHBhcmFtIHRlbmFudElkIC0gT3B0aW9uYWwgdGVuYW50IElEIGZvciBzcGVjaWZpYyBzdGF0c1xuICAgKiBAcmV0dXJucyBLZXkgc3RhdGlzdGljc1xuICAgKi9cbiAgYXN5bmMgZ2V0S2V5U3RhdHModGVuYW50SWQ/OiBzdHJpbmcpOiBQcm9taXNlPEtleVN0YXRzPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN1cGFiYXNlID0gYXdhaXQgY3JlYXRlQ2xpZW50KCk7XG4gICAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZS5mcm9tKCdlbmNyeXB0aW9uX2tleXMnKS5zZWxlY3QoJyonKTtcblxuICAgICAgaWYgKHRlbmFudElkKSB7XG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ3RlbmFudF9pZCcsIHRlbmFudElkKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBkYXRhOiBrZXlzLCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBrZXkgc3RhdHM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHN0YXRzOiBLZXlTdGF0cyA9IHtcbiAgICAgICAgdG90YWxLZXlzOiBrZXlzPy5sZW5ndGggfHwgMCxcbiAgICAgICAgYWN0aXZlS2V5czoga2V5cz8uZmlsdGVyKChrKSA9PiBrLmlzX2FjdGl2ZSkubGVuZ3RoIHx8IDAsXG4gICAgICAgIGV4cGlyZWRLZXlzOlxuICAgICAgICAgIGtleXM/LmZpbHRlcigoaykgPT4gbmV3IERhdGUoay5leHBpcmVzX2F0KSA8IG5vdykubGVuZ3RoIHx8IDAsXG4gICAgICAgIHBlbmRpbmdSb3RhdGlvbjogMCxcbiAgICAgICAgYXZlcmFnZUtleUFnZTogMCxcbiAgICAgIH07XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBwZW5kaW5nIHJvdGF0aW9uXG4gICAgICBjb25zdCB3YXJuaW5nRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICB3YXJuaW5nRGF0ZS5zZXREYXRlKHdhcm5pbmdEYXRlLmdldERhdGUoKSArIHRoaXMuS0VZX1JPVEFUSU9OX1dBUk5JTkdfREFZUyk7XG4gICAgICBzdGF0cy5wZW5kaW5nUm90YXRpb24gPVxuICAgICAgICBrZXlzPy5maWx0ZXIoXG4gICAgICAgICAgKGspID0+XG4gICAgICAgICAgICBrLmlzX2FjdGl2ZSAmJlxuICAgICAgICAgICAgbmV3IERhdGUoay5leHBpcmVzX2F0KSA8PSB3YXJuaW5nRGF0ZSAmJlxuICAgICAgICAgICAgbmV3IERhdGUoay5leHBpcmVzX2F0KSA+IG5vd1xuICAgICAgICApLmxlbmd0aCB8fCAwO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgYXZlcmFnZSBrZXkgYWdlXG4gICAgICBpZiAoa2V5cyAmJiBrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdG90YWxBZ2UgPSBrZXlzLnJlZHVjZSgoc3VtLCBrKSA9PiB7XG4gICAgICAgICAgY29uc3QgYWdlID0gbm93LmdldFRpbWUoKSAtIG5ldyBEYXRlKGsuY3JlYXRlZF9hdCkuZ2V0VGltZSgpO1xuICAgICAgICAgIHJldHVybiBzdW0gKyBhZ2UgLyAoMTAwMCAqIDYwICogNjAgKiAyNCk7IC8vIENvbnZlcnQgdG8gZGF5c1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgc3RhdHMuYXZlcmFnZUtleUFnZSA9IHRvdGFsQWdlIC8ga2V5cy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGF0cztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEtleU1hbmFnZW1lbnRFcnJvcihcbiAgICAgICAgJ0ZhaWxlZCB0byBnZXQga2V5IHN0YXRpc3RpY3MnLFxuICAgICAgICAnR0VUX1NUQVRTX0ZBSUxFRCcsXG4gICAgICAgIHtcbiAgICAgICAgICB0ZW5hbnRJZCxcbiAgICAgICAgICBvcmlnaW5hbEVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvciksXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBrZXkgdmVyc2lvbiBoaXN0b3J5IGZvciBhIHRlbmFudFxuICAgKlxuICAgKiBAcGFyYW0gdGVuYW50SWQgLSBUZW5hbnQgaWRlbnRpZmllclxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBrZXkgdmVyc2lvbnNcbiAgICovXG4gIGFzeW5jIGdldEtleUhpc3RvcnkodGVuYW50SWQ6IHN0cmluZyk6IFByb21pc2U8S2V5VmVyc2lvbltdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN1cGFiYXNlID0gYXdhaXQgY3JlYXRlQ2xpZW50KCk7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnZW5jcnlwdGlvbl9rZXlzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgndGVuYW50X2lkJywgdGVuYW50SWQpXG4gICAgICAgIC5vcmRlcigndmVyc2lvbicsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGtleSBoaXN0b3J5OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIGRhdGE/Lm1hcCgocm93KSA9PiAoe1xuICAgICAgICAgIGlkOiByb3cuaWQsXG4gICAgICAgICAgdGVuYW50SWQ6IHJvdy50ZW5hbnRfaWQsXG4gICAgICAgICAga21zS2V5SWQ6IHJvdy5rbXNfa2V5X2lkLFxuICAgICAgICAgIGVuY3J5cHRlZERhdGFLZXk6IHJvdy5lbmNyeXB0ZWRfZGF0YV9rZXksXG4gICAgICAgICAgdmVyc2lvbjogcm93LnZlcnNpb24sXG4gICAgICAgICAgaXNBY3RpdmU6IHJvdy5pc19hY3RpdmUsXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShyb3cuY3JlYXRlZF9hdCksXG4gICAgICAgICAgcm90YXRlZEF0OiByb3cucm90YXRlZF9hdCA/IG5ldyBEYXRlKHJvdy5yb3RhdGVkX2F0KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKHJvdy5leHBpcmVzX2F0KSxcbiAgICAgICAgfSkpIHx8IFtdXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgS2V5TWFuYWdlbWVudEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIGdldCBrZXkgaGlzdG9yeSBmb3IgdGVuYW50ICR7dGVuYW50SWR9YCxcbiAgICAgICAgJ0dFVF9ISVNUT1JZX0ZBSUxFRCcsXG4gICAgICAgIHtcbiAgICAgICAgICB0ZW5hbnRJZCxcbiAgICAgICAgICBvcmlnaW5hbEVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvciksXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGtleSBjYWNoZVxuICAgKlxuICAgKiBAcGFyYW0gdGVuYW50SWQgLSBPcHRpb25hbCB0ZW5hbnQgSUQgdG8gY2xlYXIgc3BlY2lmaWMgY2FjaGVcbiAgICovXG4gIGNsZWFyQ2FjaGUodGVuYW50SWQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGVuYW50SWQpIHtcbiAgICAgIHRoaXMua2V5Q2FjaGUuZGVsZXRlKHRlbmFudElkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5rZXlDYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWN0aXZlIGtleSB2ZXJzaW9uIGZyb20gZGF0YWJhc2VcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZ2V0QWN0aXZlS2V5VmVyc2lvbihcbiAgICB0ZW5hbnRJZDogc3RyaW5nXG4gICk6IFByb21pc2U8S2V5VmVyc2lvbiB8IG51bGw+IHtcbiAgICBjb25zdCBzdXBhYmFzZSA9IGF3YWl0IGNyZWF0ZUNsaWVudCgpO1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZW5jcnlwdGlvbl9rZXlzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCd0ZW5hbnRfaWQnLCB0ZW5hbnRJZClcbiAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgdGVuYW50SWQ6IGRhdGEudGVuYW50X2lkLFxuICAgICAga21zS2V5SWQ6IGRhdGEua21zX2tleV9pZCxcbiAgICAgIGVuY3J5cHRlZERhdGFLZXk6IGRhdGEuZW5jcnlwdGVkX2RhdGFfa2V5LFxuICAgICAgdmVyc2lvbjogZGF0YS52ZXJzaW9uLFxuICAgICAgaXNBY3RpdmU6IGRhdGEuaXNfYWN0aXZlLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRfYXQpLFxuICAgICAgcm90YXRlZEF0OiBkYXRhLnJvdGF0ZWRfYXQgPyBuZXcgRGF0ZShkYXRhLnJvdGF0ZWRfYXQpIDogdW5kZWZpbmVkLFxuICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShkYXRhLmV4cGlyZXNfYXQpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IG5leHQgdmVyc2lvbiBudW1iZXIgZm9yIGEgdGVuYW50XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldE5leHRWZXJzaW9uKHRlbmFudElkOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGNvbnN0IHN1cGFiYXNlID0gYXdhaXQgY3JlYXRlQ2xpZW50KCk7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdlbmNyeXB0aW9uX2tleXMnKVxuICAgICAgLnNlbGVjdCgndmVyc2lvbicpXG4gICAgICAuZXEoJ3RlbmFudF9pZCcsIHRlbmFudElkKVxuICAgICAgLm9yZGVyKCd2ZXJzaW9uJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICAubGltaXQoMSlcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEudmVyc2lvbiArIDE7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRlbmFudHMgdGhhdCBuZWVkIGtleSByb3RhdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXRUZW5hbnRzTmVlZGluZ1JvdGF0aW9uKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCBzdXBhYmFzZSA9IGF3YWl0IGNyZWF0ZUNsaWVudCgpO1xuXG4gICAgLy8gR2V0IGtleXMgdGhhdCBhcmUgZXhwaXJlZCBvciBleHBpcmluZyB3aXRoaW4gd2FybmluZyBwZXJpb2RcbiAgICBjb25zdCB3YXJuaW5nRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgd2FybmluZ0RhdGUuc2V0RGF0ZSh3YXJuaW5nRGF0ZS5nZXREYXRlKCkgKyB0aGlzLktFWV9ST1RBVElPTl9XQVJOSU5HX0RBWVMpO1xuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdlbmNyeXB0aW9uX2tleXMnKVxuICAgICAgLnNlbGVjdCgndGVuYW50X2lkJylcbiAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcbiAgICAgIC5sdGUoJ2V4cGlyZXNfYXQnLCB3YXJuaW5nRGF0ZS50b0lTT1N0cmluZygpKTtcblxuICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB1bmlxdWUgdGVuYW50IElEc1xuICAgIHJldHVybiBbLi4ubmV3IFNldChkYXRhLm1hcCgocm93KSA9PiByb3cudGVuYW50X2lkKSldO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGtleSBpcyBleHBpcmVkXG4gICAqL1xuICBwcml2YXRlIGlzS2V5RXhwaXJlZChleHBpcmVzQXQ6IERhdGUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKSA+IG5ldyBEYXRlKGV4cGlyZXNBdCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYga2V5IGlzIG5lYXIgZXhwaXJhdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBpc0tleU5lYXJFeHBpcmF0aW9uKGV4cGlyZXNBdDogRGF0ZSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHdhcm5pbmdEYXRlID0gbmV3IERhdGUoKTtcbiAgICB3YXJuaW5nRGF0ZS5zZXREYXRlKHdhcm5pbmdEYXRlLmdldERhdGUoKSArIHRoaXMuS0VZX1JPVEFUSU9OX1dBUk5JTkdfREFZUyk7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGV4cGlyZXNBdCkgPD0gd2FybmluZ0RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQ2FjaGUgYSBkZWNyeXB0ZWQga2V5XG4gICAqL1xuICBwcml2YXRlIGNhY2hlS2V5KHRlbmFudElkOiBzdHJpbmcsIGtleTogQnVmZmVyLCB2ZXJzaW9uOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmtleUNhY2hlLnNldCh0ZW5hbnRJZCwge1xuICAgICAga2V5OiBCdWZmZXIuZnJvbShrZXkpLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgdmVyc2lvbixcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY2FjaGVkIGtleSBpZiB2YWxpZFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRDYWNoZWRLZXkodGVuYW50SWQ6IHN0cmluZyk6IEJ1ZmZlciB8IG51bGwge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMua2V5Q2FjaGUuZ2V0KHRlbmFudElkKTtcblxuICAgIGlmICghY2FjaGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBjYWNoZSBlbnRyeSBpcyBzdGlsbCB2YWxpZFxuICAgIGlmIChEYXRlLm5vdygpIC0gY2FjaGVkLnRpbWVzdGFtcCA+IHRoaXMuQ0FDSEVfVFRMKSB7XG4gICAgICB0aGlzLmtleUNhY2hlLmRlbGV0ZSh0ZW5hbnRJZCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oY2FjaGVkLmtleSk7XG4gIH1cblxuICAvKipcbiAgICogTG9nIGtleSBvcGVyYXRpb24gZm9yIGF1ZGl0IHRyYWlsXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGxvZ0tleU9wZXJhdGlvbihcbiAgICBvcGVyYXRpb246IHN0cmluZyxcbiAgICB0ZW5hbnRJZDogc3RyaW5nLFxuICAgIHZlcnNpb246IG51bWJlcixcbiAgICBzdWNjZXNzOiBib29sZWFuLFxuICAgIGVycm9yPzogdW5rbm93blxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3VwYWJhc2UgPSBhd2FpdCBjcmVhdGVDbGllbnQoKTtcbiAgICAgIGF3YWl0IHN1cGFiYXNlLmZyb20oJ2tleV9yb3RhdGlvbl9sb2cnKS5pbnNlcnQoe1xuICAgICAgICB0ZW5hbnRfaWQ6IHRlbmFudElkLFxuICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgIGZyb21fdmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgdG9fdmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgZXJyb3JfbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiB1bmRlZmluZWQsXG4gICAgICAgIHBlcmZvcm1lZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAobG9nRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2cga2V5IG9wZXJhdGlvbjonLCBsb2dFcnJvcik7XG4gICAgICAvLyBEb24ndCB0aHJvdyAtIGxvZ2dpbmcgZmFpbHVyZSBzaG91bGRuJ3Qgc3RvcCB0aGUgb3BlcmF0aW9uXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvZyBrZXkgcm90YXRpb25cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgbG9nS2V5Um90YXRpb24oXG4gICAgdGVuYW50SWQ6IHN0cmluZyxcbiAgICBmcm9tVmVyc2lvbjogbnVtYmVyLFxuICAgIHRvVmVyc2lvbjogbnVtYmVyXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdXBhYmFzZSA9IGF3YWl0IGNyZWF0ZUNsaWVudCgpO1xuICAgICAgYXdhaXQgc3VwYWJhc2UuZnJvbSgna2V5X3JvdGF0aW9uX2xvZycpLmluc2VydCh7XG4gICAgICAgIHRlbmFudF9pZDogdGVuYW50SWQsXG4gICAgICAgIG9wZXJhdGlvbjogJ3JvdGF0ZScsXG4gICAgICAgIGZyb21fdmVyc2lvbjogZnJvbVZlcnNpb24sXG4gICAgICAgIHRvX3ZlcnNpb246IHRvVmVyc2lvbixcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgcGVyZm9ybWVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvZyBrZXkgcm90YXRpb246JywgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNpbmdsZXRvbiBrZXkgbWFuYWdlciBpbnN0YW5jZVxuICovXG5sZXQga2V5TWFuYWdlckluc3RhbmNlOiBLZXlNYW5hZ2VyIHwgbnVsbCA9IG51bGw7XG5cbi8qKlxuICogR2V0IG9yIGNyZWF0ZSBrZXkgbWFuYWdlciBzaW5nbGV0b25cbiAqXG4gKiBAcmV0dXJucyBLZXkgbWFuYWdlciBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5TWFuYWdlcigpOiBLZXlNYW5hZ2VyIHtcbiAgaWYgKCFrZXlNYW5hZ2VySW5zdGFuY2UpIHtcbiAgICBrZXlNYW5hZ2VySW5zdGFuY2UgPSBuZXcgS2V5TWFuYWdlcigpO1xuICB9XG4gIHJldHVybiBrZXlNYW5hZ2VySW5zdGFuY2U7XG59XG5cbi8qKlxuICogUmVzZXQga2V5IG1hbmFnZXIgc2luZ2xldG9uICh1c2VmdWwgZm9yIHRlc3RpbmcpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNldEtleU1hbmFnZXIoKTogdm9pZCB7XG4gIGlmIChrZXlNYW5hZ2VySW5zdGFuY2UpIHtcbiAgICBrZXlNYW5hZ2VySW5zdGFuY2UuY2xlYXJDYWNoZSgpO1xuICAgIGtleU1hbmFnZXJJbnN0YW5jZSA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvcnQgZm9yIHRlc3RpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IF9fdGVzdGluZ19fID0ge1xuICBLZXlNYW5hZ2VyLFxuICByZXNldEtleU1hbmFnZXIsXG59O1xuIl0sIm5hbWVzIjpbIktleU1hbmFnZXIiLCJfX3Rlc3RpbmdfXyIsImdldEtleU1hbmFnZXIiLCJyZXNldEtleU1hbmFnZXIiLCJrbXNDbGllbnQiLCJDQUNIRV9UVEwiLCJLRVlfUk9UQVRJT05fREFZUyIsIktFWV9ST1RBVElPTl9XQVJOSU5HX0RBWVMiLCJnZXRLTVNDbGllbnQiLCJrZXlDYWNoZSIsIk1hcCIsImdldEVuY3J5cHRpb25LZXkiLCJ0ZW5hbnRJZCIsIm9wdGlvbnMiLCJmb3JjZVJlZnJlc2giLCJjYWNoZWQiLCJnZXRDYWNoZWRLZXkiLCJrZXlWZXJzaW9uIiwiZ2V0QWN0aXZlS2V5VmVyc2lvbiIsImNyZWF0ZUtleSIsImlzS2V5RXhwaXJlZCIsImV4cGlyZXNBdCIsImNvbnNvbGUiLCJ3YXJuIiwicm90YXRlS2V5IiwiaXNLZXlOZWFyRXhwaXJhdGlvbiIsImluZm8iLCJjYXRjaCIsImVycm9yIiwiZGVjcnlwdGVkIiwiZGVjcnlwdERhdGFLZXkiLCJlbmNyeXB0ZWREYXRhS2V5IiwiY2FjaGVLZXkiLCJwbGFpbnRleHQiLCJ2ZXJzaW9uIiwiS2V5TWFuYWdlbWVudEVycm9yIiwib3JpZ2luYWxFcnJvciIsIkVycm9yIiwibWVzc2FnZSIsIlN0cmluZyIsImRhdGFLZXkiLCJnZW5lcmF0ZURhdGFLZXkiLCJnZXROZXh0VmVyc2lvbiIsIkRhdGUiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsInN1cGFiYXNlIiwiY3JlYXRlQ2xpZW50IiwiZnJvbSIsImluc2VydCIsInRlbmFudF9pZCIsImttc19rZXlfaWQiLCJrZXlJZCIsImVuY3J5cHRlZF9kYXRhX2tleSIsImNpcGhlcnRleHQiLCJpc19hY3RpdmUiLCJjcmVhdGVkX2F0IiwidG9JU09TdHJpbmciLCJleHBpcmVzX2F0IiwibG9nS2V5T3BlcmF0aW9uIiwiY3VycmVudEtleSIsInVwZGF0ZUVycm9yIiwidXBkYXRlIiwicm90YXRlZF9hdCIsImVxIiwiaWQiLCJuZXdLZXkiLCJsb2dLZXlSb3RhdGlvbiIsImNsZWFyQ2FjaGUiLCJyb3RhdGVLZXlzIiwic3RhcnRUaW1lIiwibm93IiwicmVzdWx0Iiwicm90YXRlZCIsImZhaWxlZCIsInRlbmFudElkcyIsImVycm9ycyIsImR1cmF0aW9uIiwidGVuYW50c1RvUm90YXRlIiwiZ2V0VGVuYW50c05lZWRpbmdSb3RhdGlvbiIsInRpZCIsInB1c2giLCJzY2hlZHVsZVJvdGF0aW9uIiwidGVuYW50c05lZWRpbmdSb3RhdGlvbiIsImxlbmd0aCIsImJhdGNoU2l6ZSIsImkiLCJiYXRjaCIsInNsaWNlIiwiUHJvbWlzZSIsImFsbFNldHRsZWQiLCJtYXAiLCJnZXRLZXlTdGF0cyIsInF1ZXJ5Iiwic2VsZWN0IiwiZGF0YSIsImtleXMiLCJzdGF0cyIsInRvdGFsS2V5cyIsImFjdGl2ZUtleXMiLCJmaWx0ZXIiLCJrIiwiZXhwaXJlZEtleXMiLCJwZW5kaW5nUm90YXRpb24iLCJhdmVyYWdlS2V5QWdlIiwid2FybmluZ0RhdGUiLCJ0b3RhbEFnZSIsInJlZHVjZSIsInN1bSIsImFnZSIsImdldFRpbWUiLCJnZXRLZXlIaXN0b3J5Iiwib3JkZXIiLCJhc2NlbmRpbmciLCJyb3ciLCJrbXNLZXlJZCIsImlzQWN0aXZlIiwiY3JlYXRlZEF0Iiwicm90YXRlZEF0IiwidW5kZWZpbmVkIiwiZGVsZXRlIiwiY2xlYXIiLCJzaW5nbGUiLCJsaW1pdCIsImx0ZSIsIlNldCIsImtleSIsInNldCIsIkJ1ZmZlciIsInRpbWVzdGFtcCIsImdldCIsIm9wZXJhdGlvbiIsInN1Y2Nlc3MiLCJmcm9tX3ZlcnNpb24iLCJ0b192ZXJzaW9uIiwiZXJyb3JfbWVzc2FnZSIsInBlcmZvcm1lZF9hdCIsImxvZ0Vycm9yIiwiZnJvbVZlcnNpb24iLCJ0b1ZlcnNpb24iLCJrZXlNYW5hZ2VySW5zdGFuY2UiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztDQVdDOzs7Ozs7Ozs7OztRQThFWUE7ZUFBQUE7O1FBa2xCQUM7ZUFBQUE7O1FBcEJHQztlQUFBQTs7UUFVQUM7ZUFBQUE7Ozt3QkFwcEJhOzJCQUMwQjt1QkFDcEI7QUEwRTVCLE1BQU1IO0lBT1gsWUFBWUksU0FBcUIsQ0FBRTthQUpsQkMsWUFBWSxTQUFTLFNBQVM7YUFDOUJDLG9CQUFvQjthQUNwQkMsNEJBQTRCO1FBRzNDLElBQUksQ0FBQ0gsU0FBUyxHQUFHQSxhQUFhSSxJQUFBQSx1QkFBWTtRQUMxQyxJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJQztJQUN0QjtJQUVBOzs7Ozs7OztHQVFDLEdBQ0QsTUFBTUMsaUJBQ0pDLFFBQWdCLEVBQ2hCQyxVQUErQixDQUFDLENBQUMsRUFDaEI7UUFDakIsSUFBSTtZQUNGLHlDQUF5QztZQUN6QyxJQUFJLENBQUNBLFFBQVFDLFlBQVksRUFBRTtnQkFDekIsTUFBTUMsU0FBUyxJQUFJLENBQUNDLFlBQVksQ0FBQ0o7Z0JBQ2pDLElBQUlHLFFBQVE7b0JBQ1YsT0FBT0E7Z0JBQ1Q7WUFDRjtZQUVBLCtCQUErQjtZQUMvQixNQUFNRSxhQUFhLE1BQU0sSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQ047WUFFbEQsSUFBSSxDQUFDSyxZQUFZO2dCQUNmLDRCQUE0QjtnQkFDNUIsT0FBTyxNQUFNLElBQUksQ0FBQ0UsU0FBUyxDQUFDUDtZQUM5QjtZQUVBLDZDQUE2QztZQUM3QyxJQUFJLElBQUksQ0FBQ1EsWUFBWSxDQUFDSCxXQUFXSSxTQUFTLEdBQUc7Z0JBQzNDQyxRQUFRQyxJQUFJLENBQUMsQ0FBQyxlQUFlLEVBQUVYLFNBQVMseUJBQXlCLENBQUM7Z0JBQ2xFLE9BQU8sTUFBTSxJQUFJLENBQUNZLFNBQVMsQ0FBQ1o7WUFDOUI7WUFFQSx5Q0FBeUM7WUFDekMsSUFBSSxJQUFJLENBQUNhLG1CQUFtQixDQUFDUixXQUFXSSxTQUFTLEdBQUc7Z0JBQ2xEQyxRQUFRSSxJQUFJLENBQUMsQ0FBQyxlQUFlLEVBQUVkLFNBQVMsMEJBQTBCLENBQUM7Z0JBQ25FLG9EQUFvRDtnQkFDcEQsSUFBSSxDQUFDWSxTQUFTLENBQUNaLFVBQVVlLEtBQUssQ0FBQyxDQUFDQztvQkFDOUJOLFFBQVFNLEtBQUssQ0FBQyxDQUFDLG1DQUFtQyxFQUFFaEIsU0FBUyxDQUFDLENBQUMsRUFBRWdCO2dCQUNuRTtZQUNGO1lBRUEsaUNBQWlDO1lBQ2pDLE1BQU1DLFlBQVksTUFBTSxJQUFJLENBQUN6QixTQUFTLENBQUMwQixjQUFjLENBQ25EYixXQUFXYyxnQkFBZ0IsRUFDM0JuQjtZQUdGLDBCQUEwQjtZQUMxQixJQUFJLENBQUNvQixRQUFRLENBQUNwQixVQUFVaUIsVUFBVUksU0FBUyxFQUFFaEIsV0FBV2lCLE9BQU87WUFFL0QsT0FBT0wsVUFBVUksU0FBUztRQUM1QixFQUFFLE9BQU9MLE9BQU87WUFDZCxNQUFNLElBQUlPLHlCQUFrQixDQUMxQixDQUFDLHdDQUF3QyxFQUFFdkIsVUFBVSxFQUNyRCxrQkFDQTtnQkFDRUE7Z0JBQ0F3QixlQUFlUixpQkFBaUJTLFFBQVFULE1BQU1VLE9BQU8sR0FBR0MsT0FBT1g7WUFDakU7UUFFSjtJQUNGO0lBRUE7Ozs7OztHQU1DLEdBQ0QsTUFBTVQsVUFBVVAsUUFBZ0IsRUFBbUI7UUFDakQsSUFBSTtZQUNGLDZCQUE2QjtZQUM3QixNQUFNNEIsVUFBVSxNQUFNLElBQUksQ0FBQ3BDLFNBQVMsQ0FBQ3FDLGVBQWUsQ0FBQzdCO1lBRXJELDhCQUE4QjtZQUM5QixNQUFNc0IsVUFBVSxNQUFNLElBQUksQ0FBQ1EsY0FBYyxDQUFDOUI7WUFFMUMsK0NBQStDO1lBQy9DLE1BQU1TLFlBQVksSUFBSXNCO1lBQ3RCdEIsVUFBVXVCLE9BQU8sQ0FBQ3ZCLFVBQVV3QixPQUFPLEtBQUssSUFBSSxDQUFDdkMsaUJBQWlCO1lBRTlELG9CQUFvQjtZQUNwQixNQUFNd0MsV0FBVyxNQUFNQyxJQUFBQSxvQkFBWTtZQUNuQyxNQUFNLEVBQUVuQixLQUFLLEVBQUUsR0FBRyxNQUFNa0IsU0FBU0UsSUFBSSxDQUFDLG1CQUFtQkMsTUFBTSxDQUFDO2dCQUM5REMsV0FBV3RDO2dCQUNYdUMsWUFBWVgsUUFBUVksS0FBSztnQkFDekJDLG9CQUFvQmIsUUFBUWMsVUFBVTtnQkFDdENwQixTQUFTQTtnQkFDVHFCLFdBQVc7Z0JBQ1hDLFlBQVksSUFBSWIsT0FBT2MsV0FBVztnQkFDbENDLFlBQVlyQyxVQUFVb0MsV0FBVztZQUNuQztZQUVBLElBQUk3QixPQUFPO2dCQUNULE1BQU0sSUFBSVMsTUFBTSxDQUFDLHdCQUF3QixFQUFFVCxNQUFNVSxPQUFPLEVBQUU7WUFDNUQ7WUFFQSxtQkFBbUI7WUFDbkIsTUFBTSxJQUFJLENBQUNxQixlQUFlLENBQUMsVUFBVS9DLFVBQVVzQixTQUFTO1lBRXhELGdCQUFnQjtZQUNoQixJQUFJLENBQUNGLFFBQVEsQ0FBQ3BCLFVBQVU0QixRQUFRUCxTQUFTLEVBQUVDO1lBRTNDLE9BQU9NLFFBQVFQLFNBQVM7UUFDMUIsRUFBRSxPQUFPTCxPQUFPO1lBQ2QsTUFBTSxJQUFJLENBQUMrQixlQUFlLENBQUMsVUFBVS9DLFVBQVUsR0FBRyxPQUFPZ0I7WUFFekQsTUFBTSxJQUFJTyx5QkFBa0IsQ0FDMUIsQ0FBQyxnQ0FBZ0MsRUFBRXZCLFVBQVUsRUFDN0MscUJBQ0E7Z0JBQ0VBO2dCQUNBd0IsZUFBZVIsaUJBQWlCUyxRQUFRVCxNQUFNVSxPQUFPLEdBQUdDLE9BQU9YO1lBQ2pFO1FBRUo7SUFDRjtJQUVBOzs7Ozs7R0FNQyxHQUNELE1BQU1KLFVBQVVaLFFBQWdCLEVBQW1CO1FBQ2pELElBQUk7WUFDRixNQUFNa0MsV0FBVyxNQUFNQyxJQUFBQSxvQkFBWTtZQUVuQyx5QkFBeUI7WUFDekIsTUFBTWEsYUFBYSxNQUFNLElBQUksQ0FBQzFDLG1CQUFtQixDQUFDTjtZQUNsRCxJQUFJLENBQUNnRCxZQUFZO2dCQUNmLE1BQU0sSUFBSXZCLE1BQU07WUFDbEI7WUFFQSxrREFBa0Q7WUFDbEQsTUFBTSxFQUFFVCxPQUFPaUMsV0FBVyxFQUFFLEdBQUcsTUFBTWYsU0FDbENFLElBQUksQ0FBQyxtQkFDTGMsTUFBTSxDQUFDO2dCQUNOUCxXQUFXO2dCQUNYUSxZQUFZLElBQUlwQixPQUFPYyxXQUFXO1lBQ3BDLEdBQ0NPLEVBQUUsQ0FBQyxNQUFNSixXQUFXSyxFQUFFO1lBRXpCLElBQUlKLGFBQWE7Z0JBQ2YsTUFBTSxJQUFJeEIsTUFBTSxDQUFDLDhCQUE4QixFQUFFd0IsWUFBWXZCLE9BQU8sRUFBRTtZQUN4RTtZQUVBLGlCQUFpQjtZQUNqQixNQUFNNEIsU0FBUyxNQUFNLElBQUksQ0FBQy9DLFNBQVMsQ0FBQ1A7WUFFcEMsZUFBZTtZQUNmLE1BQU0sSUFBSSxDQUFDdUQsY0FBYyxDQUFDdkQsVUFBVWdELFdBQVcxQixPQUFPLEVBQUUwQixXQUFXMUIsT0FBTyxHQUFHO1lBRTdFLCtCQUErQjtZQUMvQixJQUFJLENBQUNrQyxVQUFVLENBQUN4RDtZQUVoQixPQUFPc0Q7UUFDVCxFQUFFLE9BQU90QyxPQUFPO1lBQ2QsTUFBTSxJQUFJTyx5QkFBa0IsQ0FDMUIsQ0FBQyxnQ0FBZ0MsRUFBRXZCLFVBQVUsRUFDN0MscUJBQ0E7Z0JBQ0VBO2dCQUNBd0IsZUFBZVIsaUJBQWlCUyxRQUFRVCxNQUFNVSxPQUFPLEdBQUdDLE9BQU9YO1lBQ2pFO1FBRUo7SUFDRjtJQUVBOzs7OztHQUtDLEdBQ0QsTUFBTXlDLFdBQVd6RCxRQUFpQixFQUE4QjtRQUM5RCxNQUFNMEQsWUFBWTNCLEtBQUs0QixHQUFHO1FBQzFCLE1BQU1DLFNBQTRCO1lBQ2hDQyxTQUFTO1lBQ1RDLFFBQVE7WUFDUkMsV0FBVyxFQUFFO1lBQ2JDLFFBQVEsRUFBRTtZQUNWQyxVQUFVO1FBQ1o7UUFFQSxJQUFJO1lBQ0YsaUNBQWlDO1lBQ2pDLE1BQU1DLGtCQUFrQmxFLFdBQ3BCO2dCQUFDQTthQUFTLEdBQ1YsTUFBTSxJQUFJLENBQUNtRSx5QkFBeUI7WUFFeEMsS0FBSyxNQUFNQyxPQUFPRixnQkFBaUI7Z0JBQ2pDLElBQUk7b0JBQ0YsTUFBTSxJQUFJLENBQUN0RCxTQUFTLENBQUN3RDtvQkFDckJSLE9BQU9DLE9BQU87b0JBQ2RELE9BQU9HLFNBQVMsQ0FBQ00sSUFBSSxDQUFDRDtnQkFDeEIsRUFBRSxPQUFPcEQsT0FBTztvQkFDZDRDLE9BQU9FLE1BQU07b0JBQ2JGLE9BQU9JLE1BQU0sQ0FBQ0ssSUFBSSxDQUFDO3dCQUNqQnJFLFVBQVVvRTt3QkFDVnBELE9BQU9BLGlCQUFpQlMsUUFBUVQsTUFBTVUsT0FBTyxHQUFHQyxPQUFPWDtvQkFDekQ7Z0JBQ0Y7WUFDRjtZQUVBNEMsT0FBT0ssUUFBUSxHQUFHbEMsS0FBSzRCLEdBQUcsS0FBS0Q7WUFDL0IsT0FBT0U7UUFDVCxFQUFFLE9BQU81QyxPQUFPO1lBQ2Q0QyxPQUFPSyxRQUFRLEdBQUdsQyxLQUFLNEIsR0FBRyxLQUFLRDtZQUMvQixNQUFNLElBQUluQyx5QkFBa0IsQ0FDMUIsNkJBQ0EseUJBQ0E7Z0JBQ0VxQztnQkFDQXBDLGVBQWVSLGlCQUFpQlMsUUFBUVQsTUFBTVUsT0FBTyxHQUFHQyxPQUFPWDtZQUNqRTtRQUVKO0lBQ0Y7SUFFQTs7Ozs7R0FLQyxHQUNELE1BQU1zRCxtQkFBa0M7UUFDdEMsSUFBSTtZQUNGLE1BQU1DLHlCQUF5QixNQUFNLElBQUksQ0FBQ0oseUJBQXlCO1lBRW5FLElBQUlJLHVCQUF1QkMsTUFBTSxLQUFLLEdBQUc7Z0JBQ3ZDOUQsUUFBUUksSUFBSSxDQUFDO2dCQUNiO1lBQ0Y7WUFFQUosUUFBUUksSUFBSSxDQUFDLENBQUMsd0JBQXdCLEVBQUV5RCx1QkFBdUJDLE1BQU0sQ0FBQyxRQUFRLENBQUM7WUFFL0UsMERBQTBEO1lBQzFELE1BQU1DLFlBQVk7WUFDbEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILHVCQUF1QkMsTUFBTSxFQUFFRSxLQUFLRCxVQUFXO2dCQUNqRSxNQUFNRSxRQUFRSix1QkFBdUJLLEtBQUssQ0FBQ0YsR0FBR0EsSUFBSUQ7Z0JBQ2xELE1BQU1JLFFBQVFDLFVBQVUsQ0FDdEJILE1BQU1JLEdBQUcsQ0FBQyxDQUFDL0UsV0FBYSxJQUFJLENBQUNZLFNBQVMsQ0FBQ1o7WUFFM0M7WUFFQVUsUUFBUUksSUFBSSxDQUFDO1FBQ2YsRUFBRSxPQUFPRSxPQUFPO1lBQ2ROLFFBQVFNLEtBQUssQ0FBQyxvQ0FBb0NBO1lBQ2xELE1BQU1BO1FBQ1I7SUFDRjtJQUVBOzs7OztHQUtDLEdBQ0QsTUFBTWdFLFlBQVloRixRQUFpQixFQUFxQjtRQUN0RCxJQUFJO1lBQ0YsTUFBTWtDLFdBQVcsTUFBTUMsSUFBQUEsb0JBQVk7WUFDbkMsSUFBSThDLFFBQVEvQyxTQUFTRSxJQUFJLENBQUMsbUJBQW1COEMsTUFBTSxDQUFDO1lBRXBELElBQUlsRixVQUFVO2dCQUNaaUYsUUFBUUEsTUFBTTdCLEVBQUUsQ0FBQyxhQUFhcEQ7WUFDaEM7WUFFQSxNQUFNLEVBQUVtRixNQUFNQyxJQUFJLEVBQUVwRSxLQUFLLEVBQUUsR0FBRyxNQUFNaUU7WUFFcEMsSUFBSWpFLE9BQU87Z0JBQ1QsTUFBTSxJQUFJUyxNQUFNLENBQUMsMkJBQTJCLEVBQUVULE1BQU1VLE9BQU8sRUFBRTtZQUMvRDtZQUVBLE1BQU1pQyxNQUFNLElBQUk1QjtZQUNoQixNQUFNc0QsUUFBa0I7Z0JBQ3RCQyxXQUFXRixNQUFNWixVQUFVO2dCQUMzQmUsWUFBWUgsTUFBTUksT0FBTyxDQUFDQyxJQUFNQSxFQUFFOUMsU0FBUyxFQUFFNkIsVUFBVTtnQkFDdkRrQixhQUNFTixNQUFNSSxPQUFPLENBQUNDLElBQU0sSUFBSTFELEtBQUswRCxFQUFFM0MsVUFBVSxJQUFJYSxLQUFLYSxVQUFVO2dCQUM5RG1CLGlCQUFpQjtnQkFDakJDLGVBQWU7WUFDakI7WUFFQSw2QkFBNkI7WUFDN0IsTUFBTUMsY0FBYyxJQUFJOUQ7WUFDeEI4RCxZQUFZN0QsT0FBTyxDQUFDNkQsWUFBWTVELE9BQU8sS0FBSyxJQUFJLENBQUN0Qyx5QkFBeUI7WUFDMUUwRixNQUFNTSxlQUFlLEdBQ25CUCxNQUFNSSxPQUNKLENBQUNDLElBQ0NBLEVBQUU5QyxTQUFTLElBQ1gsSUFBSVosS0FBSzBELEVBQUUzQyxVQUFVLEtBQUsrQyxlQUMxQixJQUFJOUQsS0FBSzBELEVBQUUzQyxVQUFVLElBQUlhLEtBQzNCYSxVQUFVO1lBRWQsNEJBQTRCO1lBQzVCLElBQUlZLFFBQVFBLEtBQUtaLE1BQU0sR0FBRyxHQUFHO2dCQUMzQixNQUFNc0IsV0FBV1YsS0FBS1csTUFBTSxDQUFDLENBQUNDLEtBQUtQO29CQUNqQyxNQUFNUSxNQUFNdEMsSUFBSXVDLE9BQU8sS0FBSyxJQUFJbkUsS0FBSzBELEVBQUU3QyxVQUFVLEVBQUVzRCxPQUFPO29CQUMxRCxPQUFPRixNQUFNQyxNQUFPLENBQUEsT0FBTyxLQUFLLEtBQUssRUFBQyxHQUFJLGtCQUFrQjtnQkFDOUQsR0FBRztnQkFDSFosTUFBTU8sYUFBYSxHQUFHRSxXQUFXVixLQUFLWixNQUFNO1lBQzlDO1lBRUEsT0FBT2E7UUFDVCxFQUFFLE9BQU9yRSxPQUFPO1lBQ2QsTUFBTSxJQUFJTyx5QkFBa0IsQ0FDMUIsZ0NBQ0Esb0JBQ0E7Z0JBQ0V2QjtnQkFDQXdCLGVBQWVSLGlCQUFpQlMsUUFBUVQsTUFBTVUsT0FBTyxHQUFHQyxPQUFPWDtZQUNqRTtRQUVKO0lBQ0Y7SUFFQTs7Ozs7R0FLQyxHQUNELE1BQU1tRixjQUFjbkcsUUFBZ0IsRUFBeUI7UUFDM0QsSUFBSTtZQUNGLE1BQU1rQyxXQUFXLE1BQU1DLElBQUFBLG9CQUFZO1lBQ25DLE1BQU0sRUFBRWdELElBQUksRUFBRW5FLEtBQUssRUFBRSxHQUFHLE1BQU1rQixTQUMzQkUsSUFBSSxDQUFDLG1CQUNMOEMsTUFBTSxDQUFDLEtBQ1A5QixFQUFFLENBQUMsYUFBYXBELFVBQ2hCb0csS0FBSyxDQUFDLFdBQVc7Z0JBQUVDLFdBQVc7WUFBTTtZQUV2QyxJQUFJckYsT0FBTztnQkFDVCxNQUFNLElBQUlTLE1BQU0sQ0FBQyw2QkFBNkIsRUFBRVQsTUFBTVUsT0FBTyxFQUFFO1lBQ2pFO1lBRUEsT0FDRXlELE1BQU1KLElBQUksQ0FBQ3VCLE1BQVMsQ0FBQTtvQkFDbEJqRCxJQUFJaUQsSUFBSWpELEVBQUU7b0JBQ1ZyRCxVQUFVc0csSUFBSWhFLFNBQVM7b0JBQ3ZCaUUsVUFBVUQsSUFBSS9ELFVBQVU7b0JBQ3hCcEIsa0JBQWtCbUYsSUFBSTdELGtCQUFrQjtvQkFDeENuQixTQUFTZ0YsSUFBSWhGLE9BQU87b0JBQ3BCa0YsVUFBVUYsSUFBSTNELFNBQVM7b0JBQ3ZCOEQsV0FBVyxJQUFJMUUsS0FBS3VFLElBQUkxRCxVQUFVO29CQUNsQzhELFdBQVdKLElBQUluRCxVQUFVLEdBQUcsSUFBSXBCLEtBQUt1RSxJQUFJbkQsVUFBVSxJQUFJd0Q7b0JBQ3ZEbEcsV0FBVyxJQUFJc0IsS0FBS3VFLElBQUl4RCxVQUFVO2dCQUNwQyxDQUFBLE1BQU8sRUFBRTtRQUViLEVBQUUsT0FBTzlCLE9BQU87WUFDZCxNQUFNLElBQUlPLHlCQUFrQixDQUMxQixDQUFDLHFDQUFxQyxFQUFFdkIsVUFBVSxFQUNsRCxzQkFDQTtnQkFDRUE7Z0JBQ0F3QixlQUFlUixpQkFBaUJTLFFBQVFULE1BQU1VLE9BQU8sR0FBR0MsT0FBT1g7WUFDakU7UUFFSjtJQUNGO0lBRUE7Ozs7R0FJQyxHQUNEd0MsV0FBV3hELFFBQWlCLEVBQVE7UUFDbEMsSUFBSUEsVUFBVTtZQUNaLElBQUksQ0FBQ0gsUUFBUSxDQUFDK0csTUFBTSxDQUFDNUc7UUFDdkIsT0FBTztZQUNMLElBQUksQ0FBQ0gsUUFBUSxDQUFDZ0gsS0FBSztRQUNyQjtJQUNGO0lBRUE7O0dBRUMsR0FDRCxNQUFjdkcsb0JBQ1pOLFFBQWdCLEVBQ1k7UUFDNUIsTUFBTWtDLFdBQVcsTUFBTUMsSUFBQUEsb0JBQVk7UUFDbkMsTUFBTSxFQUFFZ0QsSUFBSSxFQUFFbkUsS0FBSyxFQUFFLEdBQUcsTUFBTWtCLFNBQzNCRSxJQUFJLENBQUMsbUJBQ0w4QyxNQUFNLENBQUMsS0FDUDlCLEVBQUUsQ0FBQyxhQUFhcEQsVUFDaEJvRCxFQUFFLENBQUMsYUFBYSxNQUNoQjBELE1BQU07UUFFVCxJQUFJOUYsU0FBUyxDQUFDbUUsTUFBTTtZQUNsQixPQUFPO1FBQ1Q7UUFFQSxPQUFPO1lBQ0w5QixJQUFJOEIsS0FBSzlCLEVBQUU7WUFDWHJELFVBQVVtRixLQUFLN0MsU0FBUztZQUN4QmlFLFVBQVVwQixLQUFLNUMsVUFBVTtZQUN6QnBCLGtCQUFrQmdFLEtBQUsxQyxrQkFBa0I7WUFDekNuQixTQUFTNkQsS0FBSzdELE9BQU87WUFDckJrRixVQUFVckIsS0FBS3hDLFNBQVM7WUFDeEI4RCxXQUFXLElBQUkxRSxLQUFLb0QsS0FBS3ZDLFVBQVU7WUFDbkM4RCxXQUFXdkIsS0FBS2hDLFVBQVUsR0FBRyxJQUFJcEIsS0FBS29ELEtBQUtoQyxVQUFVLElBQUl3RDtZQUN6RGxHLFdBQVcsSUFBSXNCLEtBQUtvRCxLQUFLckMsVUFBVTtRQUNyQztJQUNGO0lBRUE7O0dBRUMsR0FDRCxNQUFjaEIsZUFBZTlCLFFBQWdCLEVBQW1CO1FBQzlELE1BQU1rQyxXQUFXLE1BQU1DLElBQUFBLG9CQUFZO1FBQ25DLE1BQU0sRUFBRWdELElBQUksRUFBRW5FLEtBQUssRUFBRSxHQUFHLE1BQU1rQixTQUMzQkUsSUFBSSxDQUFDLG1CQUNMOEMsTUFBTSxDQUFDLFdBQ1A5QixFQUFFLENBQUMsYUFBYXBELFVBQ2hCb0csS0FBSyxDQUFDLFdBQVc7WUFBRUMsV0FBVztRQUFNLEdBQ3BDVSxLQUFLLENBQUMsR0FDTkQsTUFBTTtRQUVULElBQUk5RixTQUFTLENBQUNtRSxNQUFNO1lBQ2xCLE9BQU87UUFDVDtRQUVBLE9BQU9BLEtBQUs3RCxPQUFPLEdBQUc7SUFDeEI7SUFFQTs7R0FFQyxHQUNELE1BQWM2Qyw0QkFBK0M7UUFDM0QsTUFBTWpDLFdBQVcsTUFBTUMsSUFBQUEsb0JBQVk7UUFFbkMsOERBQThEO1FBQzlELE1BQU0wRCxjQUFjLElBQUk5RDtRQUN4QjhELFlBQVk3RCxPQUFPLENBQUM2RCxZQUFZNUQsT0FBTyxLQUFLLElBQUksQ0FBQ3RDLHlCQUF5QjtRQUUxRSxNQUFNLEVBQUV3RixJQUFJLEVBQUVuRSxLQUFLLEVBQUUsR0FBRyxNQUFNa0IsU0FDM0JFLElBQUksQ0FBQyxtQkFDTDhDLE1BQU0sQ0FBQyxhQUNQOUIsRUFBRSxDQUFDLGFBQWEsTUFDaEI0RCxHQUFHLENBQUMsY0FBY25CLFlBQVloRCxXQUFXO1FBRTVDLElBQUk3QixTQUFTLENBQUNtRSxNQUFNO1lBQ2xCLE9BQU8sRUFBRTtRQUNYO1FBRUEsMkJBQTJCO1FBQzNCLE9BQU87ZUFBSSxJQUFJOEIsSUFBSTlCLEtBQUtKLEdBQUcsQ0FBQyxDQUFDdUIsTUFBUUEsSUFBSWhFLFNBQVM7U0FBRztJQUN2RDtJQUVBOztHQUVDLEdBQ0QsQUFBUTlCLGFBQWFDLFNBQWUsRUFBVztRQUM3QyxPQUFPLElBQUlzQixTQUFTLElBQUlBLEtBQUt0QjtJQUMvQjtJQUVBOztHQUVDLEdBQ0QsQUFBUUksb0JBQW9CSixTQUFlLEVBQVc7UUFDcEQsTUFBTW9GLGNBQWMsSUFBSTlEO1FBQ3hCOEQsWUFBWTdELE9BQU8sQ0FBQzZELFlBQVk1RCxPQUFPLEtBQUssSUFBSSxDQUFDdEMseUJBQXlCO1FBQzFFLE9BQU8sSUFBSW9DLEtBQUt0QixjQUFjb0Y7SUFDaEM7SUFFQTs7R0FFQyxHQUNELEFBQVF6RSxTQUFTcEIsUUFBZ0IsRUFBRWtILEdBQVcsRUFBRTVGLE9BQWUsRUFBUTtRQUNyRSxJQUFJLENBQUN6QixRQUFRLENBQUNzSCxHQUFHLENBQUNuSCxVQUFVO1lBQzFCa0gsS0FBS0UsT0FBT2hGLElBQUksQ0FBQzhFO1lBQ2pCRyxXQUFXdEYsS0FBSzRCLEdBQUc7WUFDbkJyQztRQUNGO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELEFBQVFsQixhQUFhSixRQUFnQixFQUFpQjtRQUNwRCxNQUFNRyxTQUFTLElBQUksQ0FBQ04sUUFBUSxDQUFDeUgsR0FBRyxDQUFDdEg7UUFFakMsSUFBSSxDQUFDRyxRQUFRO1lBQ1gsT0FBTztRQUNUO1FBRUEsc0NBQXNDO1FBQ3RDLElBQUk0QixLQUFLNEIsR0FBRyxLQUFLeEQsT0FBT2tILFNBQVMsR0FBRyxJQUFJLENBQUM1SCxTQUFTLEVBQUU7WUFDbEQsSUFBSSxDQUFDSSxRQUFRLENBQUMrRyxNQUFNLENBQUM1RztZQUNyQixPQUFPO1FBQ1Q7UUFFQSxPQUFPb0gsT0FBT2hGLElBQUksQ0FBQ2pDLE9BQU8rRyxHQUFHO0lBQy9CO0lBRUE7O0dBRUMsR0FDRCxNQUFjbkUsZ0JBQ1p3RSxTQUFpQixFQUNqQnZILFFBQWdCLEVBQ2hCc0IsT0FBZSxFQUNma0csT0FBZ0IsRUFDaEJ4RyxLQUFlLEVBQ0E7UUFDZixJQUFJO1lBQ0YsTUFBTWtCLFdBQVcsTUFBTUMsSUFBQUEsb0JBQVk7WUFDbkMsTUFBTUQsU0FBU0UsSUFBSSxDQUFDLG9CQUFvQkMsTUFBTSxDQUFDO2dCQUM3Q0MsV0FBV3RDO2dCQUNYdUg7Z0JBQ0FFLGNBQWNuRztnQkFDZG9HLFlBQVlwRztnQkFDWmtHO2dCQUNBRyxlQUFlM0csaUJBQWlCUyxRQUFRVCxNQUFNVSxPQUFPLEdBQUdpRjtnQkFDeERpQixjQUFjLElBQUk3RixPQUFPYyxXQUFXO1lBQ3RDO1FBQ0YsRUFBRSxPQUFPZ0YsVUFBVTtZQUNqQm5ILFFBQVFNLEtBQUssQ0FBQyxnQ0FBZ0M2RztRQUM5Qyw2REFBNkQ7UUFDL0Q7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBY3RFLGVBQ1p2RCxRQUFnQixFQUNoQjhILFdBQW1CLEVBQ25CQyxTQUFpQixFQUNGO1FBQ2YsSUFBSTtZQUNGLE1BQU03RixXQUFXLE1BQU1DLElBQUFBLG9CQUFZO1lBQ25DLE1BQU1ELFNBQVNFLElBQUksQ0FBQyxvQkFBb0JDLE1BQU0sQ0FBQztnQkFDN0NDLFdBQVd0QztnQkFDWHVILFdBQVc7Z0JBQ1hFLGNBQWNLO2dCQUNkSixZQUFZSztnQkFDWlAsU0FBUztnQkFDVEksY0FBYyxJQUFJN0YsT0FBT2MsV0FBVztZQUN0QztRQUNGLEVBQUUsT0FBTzdCLE9BQU87WUFDZE4sUUFBUU0sS0FBSyxDQUFDLCtCQUErQkE7UUFDL0M7SUFDRjtBQUNGO0FBRUE7O0NBRUMsR0FDRCxJQUFJZ0gscUJBQXdDO0FBT3JDLFNBQVMxSTtJQUNkLElBQUksQ0FBQzBJLG9CQUFvQjtRQUN2QkEscUJBQXFCLElBQUk1STtJQUMzQjtJQUNBLE9BQU80STtBQUNUO0FBS08sU0FBU3pJO0lBQ2QsSUFBSXlJLG9CQUFvQjtRQUN0QkEsbUJBQW1CeEUsVUFBVTtRQUM3QndFLHFCQUFxQjtJQUN2QjtBQUNGO0FBS08sTUFBTTNJLGNBQWM7SUFDekJEO0lBQ0FHO0FBQ0YifQ==