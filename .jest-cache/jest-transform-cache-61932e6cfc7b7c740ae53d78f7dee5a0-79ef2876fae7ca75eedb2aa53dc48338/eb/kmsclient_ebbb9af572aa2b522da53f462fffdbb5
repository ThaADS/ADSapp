71eddc8eeed8ad6bd07695f29540f4c0
/**
 * AWS KMS Client Library
 *
 * Provides secure encryption key management using AWS Key Management Service (KMS).
 * Supports multi-tenant key isolation, automatic key rotation, and comprehensive error handling.
 *
 * Features:
 * - Data key generation with AWS KMS
 * - Secure key decryption with caching
 * - Multi-tenant key isolation
 * - Comprehensive error handling and retry logic
 * - Audit logging for all operations
 * - Key rotation support
 *
 * @module security/kms-client
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get KMSClient () {
        return KMSClient;
    },
    get __testing__ () {
        return __testing__;
    },
    get getKMSClient () {
        return getKMSClient;
    },
    get resetKMSClient () {
        return resetKMSClient;
    }
});
const _clientkms = require("@aws-sdk/client-kms");
const _credentialproviders = require("@aws-sdk/credential-providers");
const _types = require("../crypto/types");
class KMSClient {
    /**
   * Create a new KMS client
   *
   * @param config - KMS configuration
   * @throws {KeyManagementError} If configuration is invalid
   */ constructor(config){
        this.CACHE_TTL = 3600000; // 1 hour in milliseconds
        this.config = this.loadConfig(config);
        this.validateConfig();
        // Initialize AWS KMS client
        this.client = new _clientkms.KMSClient({
            region: this.config.region,
            credentials: this.config.accessKeyId && this.config.secretAccessKey ? {
                accessKeyId: this.config.accessKeyId,
                secretAccessKey: this.config.secretAccessKey
            } : (0, _credentialproviders.fromEnv)(),
            maxAttempts: this.config.maxRetries,
            requestHandler: {
                requestTimeout: this.config.timeout
            }
        });
        this.keyCache = new Map();
        this.stats = {
            totalOperations: 0,
            successful: 0,
            failed: 0,
            cacheHits: 0,
            cacheMisses: 0,
            averageResponseTime: 0
        };
    }
    /**
   * Load configuration from environment and override with provided config
   */ loadConfig(config) {
        return {
            region: config?.region || process.env.AWS_REGION || 'us-east-1',
            keyId: config?.keyId || process.env.AWS_KMS_KEY_ID || '',
            accessKeyId: config?.accessKeyId || process.env.AWS_ACCESS_KEY_ID,
            secretAccessKey: config?.secretAccessKey || process.env.AWS_SECRET_ACCESS_KEY,
            maxRetries: config?.maxRetries || 3,
            timeout: config?.timeout || 30000
        };
    }
    /**
   * Validate KMS configuration
   *
   * @throws {KeyManagementError} If configuration is invalid
   */ validateConfig() {
        if (!this.config.keyId) {
            throw new _types.KeyManagementError('AWS_KMS_KEY_ID is required', 'MISSING_KMS_KEY_ID', {
                hint: 'Set AWS_KMS_KEY_ID environment variable or provide keyId in config'
            });
        }
        if (!this.config.region) {
            throw new _types.KeyManagementError('AWS_REGION is required', 'MISSING_AWS_REGION', {
                hint: 'Set AWS_REGION environment variable or provide region in config'
            });
        }
        // Validate key ID format (should be UUID or ARN)
        const isValidKeyId = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i.test(this.config.keyId) || /^arn:aws:kms:[a-z0-9-]+:\d{12}:key\/[a-f0-9-]+$/i.test(this.config.keyId) || /^alias\/[a-zA-Z0-9/_-]+$/.test(this.config.keyId);
        if (!isValidKeyId) {
            throw new _types.KeyManagementError('Invalid KMS Key ID format', 'INVALID_KEY_ID_FORMAT', {
                keyId: this.config.keyId,
                hint: 'Key ID should be UUID, ARN, or alias format'
            });
        }
    }
    /**
   * Generate a new data key for tenant-specific encryption
   *
   * @param tenantId - Tenant identifier for key isolation
   * @param keySpec - Key specification (default: AES_256)
   * @returns Data key result with ciphertext and plaintext
   * @throws {KeyManagementError} If key generation fails
   */ async generateDataKey(tenantId, keySpec = 'AES_256') {
        const startTime = Date.now();
        this.stats.totalOperations++;
        try {
            // Create encryption context for tenant isolation
            const encryptionContext = {
                TenantId: tenantId,
                Purpose: 'DataEncryption',
                Timestamp: new Date().toISOString()
            };
            const input = {
                KeyId: this.config.keyId,
                KeySpec: keySpec,
                EncryptionContext: encryptionContext
            };
            const command = new _clientkms.GenerateDataKeyCommand(input);
            const response = await this.client.send(command);
            if (!response.CiphertextBlob || !response.Plaintext) {
                throw new _types.KeyManagementError('KMS returned incomplete data key', 'INCOMPLETE_DATA_KEY', {
                    response
                });
            }
            const result = {
                ciphertext: Buffer.from(response.CiphertextBlob).toString('base64'),
                plaintext: Buffer.from(response.Plaintext),
                keyId: response.KeyId || this.config.keyId
            };
            // Cache the plaintext key
            this.cacheKey(tenantId, result.plaintext);
            this.stats.successful++;
            this.updateAverageResponseTime(Date.now() - startTime);
            // Audit log
            this.logOperation('generateDataKey', tenantId, true);
            return result;
        } catch (error) {
            this.stats.failed++;
            this.logOperation('generateDataKey', tenantId, false, error);
            if (error instanceof _clientkms.KMSServiceException) {
                throw this.handleKMSError(error, 'generateDataKey');
            }
            throw new _types.KeyManagementError('Failed to generate data key', 'GENERATE_KEY_FAILED', {
                tenantId,
                originalError: error instanceof Error ? error.message : String(error)
            });
        }
    }
    /**
   * Decrypt a ciphertext data key
   *
   * @param ciphertext - Base64 encoded encrypted data key
   * @param tenantId - Tenant identifier for context validation
   * @returns Decrypted plaintext key
   * @throws {KeyManagementError} If decryption fails
   */ async decryptDataKey(ciphertext, tenantId) {
        const startTime = Date.now();
        this.stats.totalOperations++;
        try {
            // Check cache first
            const cached = this.getCachedKey(tenantId);
            if (cached) {
                this.stats.cacheHits++;
                return {
                    plaintext: cached,
                    keyId: this.config.keyId
                };
            }
            this.stats.cacheMisses++;
            // Create encryption context for tenant validation
            const encryptionContext = {
                TenantId: tenantId,
                Purpose: 'DataEncryption'
            };
            const input = {
                CiphertextBlob: Buffer.from(ciphertext, 'base64'),
                EncryptionContext: encryptionContext
            };
            const command = new _clientkms.DecryptCommand(input);
            const response = await this.client.send(command);
            if (!response.Plaintext) {
                throw new _types.KeyManagementError('KMS returned no plaintext', 'NO_PLAINTEXT', {
                    response
                });
            }
            const plaintext = Buffer.from(response.Plaintext);
            // Cache the decrypted key
            this.cacheKey(tenantId, plaintext);
            this.stats.successful++;
            this.updateAverageResponseTime(Date.now() - startTime);
            // Audit log
            this.logOperation('decryptDataKey', tenantId, true);
            return {
                plaintext,
                keyId: response.KeyId || this.config.keyId
            };
        } catch (error) {
            this.stats.failed++;
            this.logOperation('decryptDataKey', tenantId, false, error);
            if (error instanceof _clientkms.KMSServiceException) {
                throw this.handleKMSError(error, 'decryptDataKey');
            }
            throw new _types.KeyManagementError('Failed to decrypt data key', 'DECRYPT_KEY_FAILED', {
                tenantId,
                originalError: error instanceof Error ? error.message : String(error)
            });
        }
    }
    /**
   * Encrypt data directly with KMS (for small payloads)
   *
   * @param plaintext - Data to encrypt
   * @param tenantId - Tenant identifier
   * @returns Encrypted ciphertext as base64
   * @throws {KeyManagementError} If encryption fails
   */ async encrypt(plaintext, tenantId) {
        const startTime = Date.now();
        this.stats.totalOperations++;
        try {
            const encryptionContext = {
                TenantId: tenantId,
                Purpose: 'DirectEncryption'
            };
            const input = {
                KeyId: this.config.keyId,
                Plaintext: Buffer.from(plaintext),
                EncryptionContext: encryptionContext
            };
            const command = new _clientkms.EncryptCommand(input);
            const response = await this.client.send(command);
            if (!response.CiphertextBlob) {
                throw new _types.KeyManagementError('KMS returned no ciphertext', 'NO_CIPHERTEXT', {
                    response
                });
            }
            this.stats.successful++;
            this.updateAverageResponseTime(Date.now() - startTime);
            this.logOperation('encrypt', tenantId, true);
            return Buffer.from(response.CiphertextBlob).toString('base64');
        } catch (error) {
            this.stats.failed++;
            this.logOperation('encrypt', tenantId, false, error);
            if (error instanceof _clientkms.KMSServiceException) {
                throw this.handleKMSError(error, 'encrypt');
            }
            throw new _types.KeyManagementError('Failed to encrypt with KMS', 'ENCRYPT_FAILED', {
                tenantId,
                originalError: error instanceof Error ? error.message : String(error)
            });
        }
    }
    /**
   * Get KMS key metadata
   *
   * @returns Key metadata information
   * @throws {KeyManagementError} If operation fails
   */ async getKeyMetadata() {
        try {
            const command = new _clientkms.DescribeKeyCommand({
                KeyId: this.config.keyId
            });
            const response = await this.client.send(command);
            if (!response.KeyMetadata) {
                throw new _types.KeyManagementError('No key metadata returned', 'NO_KEY_METADATA');
            }
            return {
                keyId: response.KeyMetadata.KeyId || this.config.keyId,
                arn: response.KeyMetadata.Arn || '',
                state: response.KeyMetadata.KeyState || 'Unknown',
                createdAt: response.KeyMetadata.CreationDate || new Date(),
                description: response.KeyMetadata.Description,
                rotationEnabled: response.KeyMetadata.KeyRotationEnabled || false
            };
        } catch (error) {
            if (error instanceof _clientkms.KMSServiceException) {
                throw this.handleKMSError(error, 'getKeyMetadata');
            }
            throw new _types.KeyManagementError('Failed to get key metadata', 'GET_METADATA_FAILED', {
                originalError: error instanceof Error ? error.message : String(error)
            });
        }
    }
    /**
   * Clear cached keys for a tenant
   *
   * @param tenantId - Tenant identifier (optional, clears all if not provided)
   */ clearCache(tenantId) {
        if (tenantId) {
            this.keyCache.delete(tenantId);
        } else {
            this.keyCache.clear();
        }
    }
    /**
   * Get KMS client statistics
   *
   * @returns Current statistics
   */ getStats() {
        return {
            ...this.stats
        };
    }
    /**
   * Reset statistics
   */ resetStats() {
        this.stats = {
            totalOperations: 0,
            successful: 0,
            failed: 0,
            cacheHits: 0,
            cacheMisses: 0,
            averageResponseTime: 0
        };
    }
    /**
   * Test KMS connectivity and permissions
   *
   * @returns True if connection successful
   */ async testConnection() {
        try {
            await this.getKeyMetadata();
            return true;
        } catch (error) {
            console.error('KMS connection test failed:', error);
            return false;
        }
    }
    /**
   * Cache a decrypted key
   */ cacheKey(tenantId, key) {
        this.keyCache.set(tenantId, {
            key: Buffer.from(key),
            timestamp: Date.now()
        });
    }
    /**
   * Get cached key if valid
   */ getCachedKey(tenantId) {
        const cached = this.keyCache.get(tenantId);
        if (!cached) {
            return null;
        }
        // Check if cache entry is still valid
        if (Date.now() - cached.timestamp > this.CACHE_TTL) {
            this.keyCache.delete(tenantId);
            return null;
        }
        return Buffer.from(cached.key); // Return a copy
    }
    /**
   * Update average response time
   */ updateAverageResponseTime(responseTime) {
        const total = this.stats.averageResponseTime * (this.stats.successful - 1) + responseTime;
        this.stats.averageResponseTime = total / this.stats.successful;
    }
    /**
   * Handle KMS-specific errors
   */ handleKMSError(error, operation) {
        const errorMap = {
            NotFoundException: {
                code: 'KEY_NOT_FOUND',
                message: 'KMS key not found'
            },
            DisabledException: {
                code: 'KEY_DISABLED',
                message: 'KMS key is disabled'
            },
            InvalidCiphertextException: {
                code: 'INVALID_CIPHERTEXT',
                message: 'Invalid ciphertext or encryption context'
            },
            AccessDeniedException: {
                code: 'ACCESS_DENIED',
                message: 'Access denied to KMS key'
            },
            InvalidGrantTokenException: {
                code: 'INVALID_GRANT_TOKEN',
                message: 'Invalid grant token'
            },
            KMSInternalException: {
                code: 'KMS_INTERNAL_ERROR',
                message: 'AWS KMS internal error'
            },
            KMSInvalidStateException: {
                code: 'INVALID_KEY_STATE',
                message: 'KMS key is in invalid state'
            }
        };
        const mapped = errorMap[error.name] || {
            code: 'KMS_ERROR',
            message: 'AWS KMS operation failed'
        };
        return new _types.KeyManagementError(`${mapped.message}: ${error.message}`, mapped.code, {
            operation,
            awsError: error.name,
            requestId: error.$metadata?.requestId
        });
    }
    /**
   * Log KMS operation for audit trail
   */ logOperation(operation, tenantId, success, error) {
        const logEntry = {
            timestamp: new Date().toISOString(),
            operation,
            tenantId,
            success,
            error: error instanceof Error ? error.message : undefined
        };
        // In production, send to proper logging service
        if (process.env.NODE_ENV === 'development') {
            console.log('[KMS Audit]', JSON.stringify(logEntry));
        }
    // TODO: Integrate with centralized logging service
    // await logService.log('kms_operation', logEntry);
    }
    /**
   * Destroy the client and clean up resources
   */ destroy() {
        this.clearCache();
        this.client.destroy();
    }
}
/**
 * Singleton KMS client instance
 */ let kmsClientInstance = null;
function getKMSClient(config) {
    if (!kmsClientInstance) {
        kmsClientInstance = new KMSClient(config);
    }
    return kmsClientInstance;
}
function resetKMSClient() {
    if (kmsClientInstance) {
        kmsClientInstance.destroy();
        kmsClientInstance = null;
    }
}
const __testing__ = {
    KMSClient,
    resetKMSClient
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxBaSBQcm9qZWN0ZW5cXEFEU2FwcFxcc3JjXFxsaWJcXHNlY3VyaXR5XFxrbXMtY2xpZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQVdTIEtNUyBDbGllbnQgTGlicmFyeVxuICpcbiAqIFByb3ZpZGVzIHNlY3VyZSBlbmNyeXB0aW9uIGtleSBtYW5hZ2VtZW50IHVzaW5nIEFXUyBLZXkgTWFuYWdlbWVudCBTZXJ2aWNlIChLTVMpLlxuICogU3VwcG9ydHMgbXVsdGktdGVuYW50IGtleSBpc29sYXRpb24sIGF1dG9tYXRpYyBrZXkgcm90YXRpb24sIGFuZCBjb21wcmVoZW5zaXZlIGVycm9yIGhhbmRsaW5nLlxuICpcbiAqIEZlYXR1cmVzOlxuICogLSBEYXRhIGtleSBnZW5lcmF0aW9uIHdpdGggQVdTIEtNU1xuICogLSBTZWN1cmUga2V5IGRlY3J5cHRpb24gd2l0aCBjYWNoaW5nXG4gKiAtIE11bHRpLXRlbmFudCBrZXkgaXNvbGF0aW9uXG4gKiAtIENvbXByZWhlbnNpdmUgZXJyb3IgaGFuZGxpbmcgYW5kIHJldHJ5IGxvZ2ljXG4gKiAtIEF1ZGl0IGxvZ2dpbmcgZm9yIGFsbCBvcGVyYXRpb25zXG4gKiAtIEtleSByb3RhdGlvbiBzdXBwb3J0XG4gKlxuICogQG1vZHVsZSBzZWN1cml0eS9rbXMtY2xpZW50XG4gKi9cblxuaW1wb3J0IHtcbiAgS01TQ2xpZW50IGFzIEFXU0tNU0NsaWVudCxcbiAgR2VuZXJhdGVEYXRhS2V5Q29tbWFuZCxcbiAgRGVjcnlwdENvbW1hbmQsXG4gIEVuY3J5cHRDb21tYW5kLFxuICBEZXNjcmliZUtleUNvbW1hbmQsXG4gIFNjaGVkdWxlS2V5RGVsZXRpb25Db21tYW5kLFxuICBDcmVhdGVBbGlhc0NvbW1hbmQsXG4gIFVwZGF0ZUFsaWFzQ29tbWFuZCxcbiAgS01TU2VydmljZUV4Y2VwdGlvbixcbiAgR2VuZXJhdGVEYXRhS2V5Q29tbWFuZElucHV0LFxuICBEZWNyeXB0Q29tbWFuZElucHV0LFxuICBFbmNyeXB0Q29tbWFuZElucHV0LFxufSBmcm9tICdAYXdzLXNkay9jbGllbnQta21zJztcbmltcG9ydCB7IGZyb21FbnYgfSBmcm9tICdAYXdzLXNkay9jcmVkZW50aWFsLXByb3ZpZGVycyc7XG5pbXBvcnQgeyBLZXlNYW5hZ2VtZW50RXJyb3IgfSBmcm9tICdAL2xpYi9jcnlwdG8vdHlwZXMnO1xuXG4vKipcbiAqIEtNUyBDb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS01TQ29uZmlnIHtcbiAgLyoqIEFXUyBSZWdpb24gKi9cbiAgcmVnaW9uOiBzdHJpbmc7XG4gIC8qKiBLTVMgS2V5IElEIG9yIEFSTiAqL1xuICBrZXlJZDogc3RyaW5nO1xuICAvKiogQWNjZXNzIEtleSBJRCAob3B0aW9uYWwsIHVzZXMgZW52aXJvbm1lbnQgaWYgbm90IHByb3ZpZGVkKSAqL1xuICBhY2Nlc3NLZXlJZD86IHN0cmluZztcbiAgLyoqIFNlY3JldCBBY2Nlc3MgS2V5IChvcHRpb25hbCwgdXNlcyBlbnZpcm9ubWVudCBpZiBub3QgcHJvdmlkZWQpICovXG4gIHNlY3JldEFjY2Vzc0tleT86IHN0cmluZztcbiAgLyoqIE1heGltdW0gcmV0cnkgYXR0ZW1wdHMgKi9cbiAgbWF4UmV0cmllcz86IG51bWJlcjtcbiAgLyoqIFJlcXVlc3QgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgKi9cbiAgdGltZW91dD86IG51bWJlcjtcbn1cblxuLyoqXG4gKiBEYXRhIGtleSBnZW5lcmF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIERhdGFLZXlSZXN1bHQge1xuICAvKiogRW5jcnlwdGVkIGRhdGEga2V5IChmb3Igc3RvcmFnZSkgKi9cbiAgY2lwaGVydGV4dDogc3RyaW5nO1xuICAvKiogUGxhaW50ZXh0IGRhdGEga2V5IChmb3IgaW1tZWRpYXRlIHVzZSkgKi9cbiAgcGxhaW50ZXh0OiBCdWZmZXI7XG4gIC8qKiBLZXkgSUQgdXNlZCBmb3IgZ2VuZXJhdGlvbiAqL1xuICBrZXlJZDogc3RyaW5nO1xufVxuXG4vKipcbiAqIEtleSBtZXRhZGF0YSBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEtleU1ldGFkYXRhIHtcbiAgLyoqIEtleSBJRCAqL1xuICBrZXlJZDogc3RyaW5nO1xuICAvKiogS2V5IEFSTiAqL1xuICBhcm46IHN0cmluZztcbiAgLyoqIEtleSBzdGF0ZSAoRW5hYmxlZCwgRGlzYWJsZWQsIGV0Yy4pICovXG4gIHN0YXRlOiBzdHJpbmc7XG4gIC8qKiBDcmVhdGlvbiBkYXRlICovXG4gIGNyZWF0ZWRBdDogRGF0ZTtcbiAgLyoqIEtleSBkZXNjcmlwdGlvbiAqL1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgLyoqIFdoZXRoZXIga2V5IHJvdGF0aW9uIGlzIGVuYWJsZWQgKi9cbiAgcm90YXRpb25FbmFibGVkOiBib29sZWFuO1xufVxuXG4vKipcbiAqIERlY3J5cHRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGVjcnlwdGlvblJlc3VsdCB7XG4gIC8qKiBEZWNyeXB0ZWQgcGxhaW50ZXh0IGtleSAqL1xuICBwbGFpbnRleHQ6IEJ1ZmZlcjtcbiAgLyoqIEtleSBJRCB1c2VkIGZvciBkZWNyeXB0aW9uICovXG4gIGtleUlkOiBzdHJpbmc7XG59XG5cbi8qKlxuICogS01TIG9wZXJhdGlvbiBzdGF0aXN0aWNzIGZvciBtb25pdG9yaW5nXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS01TU3RhdHMge1xuICAvKiogVG90YWwgb3BlcmF0aW9ucyBwZXJmb3JtZWQgKi9cbiAgdG90YWxPcGVyYXRpb25zOiBudW1iZXI7XG4gIC8qKiBTdWNjZXNzZnVsIG9wZXJhdGlvbnMgKi9cbiAgc3VjY2Vzc2Z1bDogbnVtYmVyO1xuICAvKiogRmFpbGVkIG9wZXJhdGlvbnMgKi9cbiAgZmFpbGVkOiBudW1iZXI7XG4gIC8qKiBDYWNoZSBoaXRzICovXG4gIGNhY2hlSGl0czogbnVtYmVyO1xuICAvKiogQ2FjaGUgbWlzc2VzICovXG4gIGNhY2hlTWlzc2VzOiBudW1iZXI7XG4gIC8qKiBBdmVyYWdlIHJlc3BvbnNlIHRpbWUgaW4gbXMgKi9cbiAgYXZlcmFnZVJlc3BvbnNlVGltZTogbnVtYmVyO1xufVxuXG4vKipcbiAqIEFXUyBLTVMgQ2xpZW50IGZvciBlbmNyeXB0aW9uIGtleSBtYW5hZ2VtZW50XG4gKi9cbmV4cG9ydCBjbGFzcyBLTVNDbGllbnQge1xuICBwcml2YXRlIGNsaWVudDogQVdTS01TQ2xpZW50O1xuICBwcml2YXRlIGNvbmZpZzogUmVxdWlyZWQ8S01TQ29uZmlnPjtcbiAgcHJpdmF0ZSBrZXlDYWNoZTogTWFwPHN0cmluZywgeyBrZXk6IEJ1ZmZlcjsgdGltZXN0YW1wOiBudW1iZXIgfT47XG4gIHByaXZhdGUgcmVhZG9ubHkgQ0FDSEVfVFRMID0gMzYwMDAwMDsgLy8gMSBob3VyIGluIG1pbGxpc2Vjb25kc1xuICBwcml2YXRlIHN0YXRzOiBLTVNTdGF0cztcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEtNUyBjbGllbnRcbiAgICpcbiAgICogQHBhcmFtIGNvbmZpZyAtIEtNUyBjb25maWd1cmF0aW9uXG4gICAqIEB0aHJvd3Mge0tleU1hbmFnZW1lbnRFcnJvcn0gSWYgY29uZmlndXJhdGlvbiBpcyBpbnZhbGlkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWc/OiBQYXJ0aWFsPEtNU0NvbmZpZz4pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMubG9hZENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMudmFsaWRhdGVDb25maWcoKTtcblxuICAgIC8vIEluaXRpYWxpemUgQVdTIEtNUyBjbGllbnRcbiAgICB0aGlzLmNsaWVudCA9IG5ldyBBV1NLTVNDbGllbnQoe1xuICAgICAgcmVnaW9uOiB0aGlzLmNvbmZpZy5yZWdpb24sXG4gICAgICBjcmVkZW50aWFsczogdGhpcy5jb25maWcuYWNjZXNzS2V5SWQgJiYgdGhpcy5jb25maWcuc2VjcmV0QWNjZXNzS2V5XG4gICAgICAgID8ge1xuICAgICAgICAgICAgYWNjZXNzS2V5SWQ6IHRoaXMuY29uZmlnLmFjY2Vzc0tleUlkLFxuICAgICAgICAgICAgc2VjcmV0QWNjZXNzS2V5OiB0aGlzLmNvbmZpZy5zZWNyZXRBY2Nlc3NLZXksXG4gICAgICAgICAgfVxuICAgICAgICA6IGZyb21FbnYoKSxcbiAgICAgIG1heEF0dGVtcHRzOiB0aGlzLmNvbmZpZy5tYXhSZXRyaWVzLFxuICAgICAgcmVxdWVzdEhhbmRsZXI6IHtcbiAgICAgICAgcmVxdWVzdFRpbWVvdXQ6IHRoaXMuY29uZmlnLnRpbWVvdXQsXG4gICAgICB9IGFzIGFueSxcbiAgICB9KTtcblxuICAgIHRoaXMua2V5Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5zdGF0cyA9IHtcbiAgICAgIHRvdGFsT3BlcmF0aW9uczogMCxcbiAgICAgIHN1Y2Nlc3NmdWw6IDAsXG4gICAgICBmYWlsZWQ6IDAsXG4gICAgICBjYWNoZUhpdHM6IDAsXG4gICAgICBjYWNoZU1pc3NlczogMCxcbiAgICAgIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IDAsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGNvbmZpZ3VyYXRpb24gZnJvbSBlbnZpcm9ubWVudCBhbmQgb3ZlcnJpZGUgd2l0aCBwcm92aWRlZCBjb25maWdcbiAgICovXG4gIHByaXZhdGUgbG9hZENvbmZpZyhjb25maWc/OiBQYXJ0aWFsPEtNU0NvbmZpZz4pOiBSZXF1aXJlZDxLTVNDb25maWc+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnaW9uOiBjb25maWc/LnJlZ2lvbiB8fCBwcm9jZXNzLmVudi5BV1NfUkVHSU9OIHx8ICd1cy1lYXN0LTEnLFxuICAgICAga2V5SWQ6IGNvbmZpZz8ua2V5SWQgfHwgcHJvY2Vzcy5lbnYuQVdTX0tNU19LRVlfSUQgfHwgJycsXG4gICAgICBhY2Nlc3NLZXlJZDogY29uZmlnPy5hY2Nlc3NLZXlJZCB8fCBwcm9jZXNzLmVudi5BV1NfQUNDRVNTX0tFWV9JRCxcbiAgICAgIHNlY3JldEFjY2Vzc0tleTogY29uZmlnPy5zZWNyZXRBY2Nlc3NLZXkgfHwgcHJvY2Vzcy5lbnYuQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZLFxuICAgICAgbWF4UmV0cmllczogY29uZmlnPy5tYXhSZXRyaWVzIHx8IDMsXG4gICAgICB0aW1lb3V0OiBjb25maWc/LnRpbWVvdXQgfHwgMzAwMDAsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBLTVMgY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAdGhyb3dzIHtLZXlNYW5hZ2VtZW50RXJyb3J9IElmIGNvbmZpZ3VyYXRpb24gaXMgaW52YWxpZFxuICAgKi9cbiAgcHJpdmF0ZSB2YWxpZGF0ZUNvbmZpZygpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmtleUlkKSB7XG4gICAgICB0aHJvdyBuZXcgS2V5TWFuYWdlbWVudEVycm9yKFxuICAgICAgICAnQVdTX0tNU19LRVlfSUQgaXMgcmVxdWlyZWQnLFxuICAgICAgICAnTUlTU0lOR19LTVNfS0VZX0lEJyxcbiAgICAgICAge1xuICAgICAgICAgIGhpbnQ6ICdTZXQgQVdTX0tNU19LRVlfSUQgZW52aXJvbm1lbnQgdmFyaWFibGUgb3IgcHJvdmlkZSBrZXlJZCBpbiBjb25maWcnLFxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb25maWcucmVnaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgS2V5TWFuYWdlbWVudEVycm9yKFxuICAgICAgICAnQVdTX1JFR0lPTiBpcyByZXF1aXJlZCcsXG4gICAgICAgICdNSVNTSU5HX0FXU19SRUdJT04nLFxuICAgICAgICB7XG4gICAgICAgICAgaGludDogJ1NldCBBV1NfUkVHSU9OIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIHByb3ZpZGUgcmVnaW9uIGluIGNvbmZpZycsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUga2V5IElEIGZvcm1hdCAoc2hvdWxkIGJlIFVVSUQgb3IgQVJOKVxuICAgIGNvbnN0IGlzVmFsaWRLZXlJZCA9XG4gICAgICAvXlthLWYwLTldezh9LVthLWYwLTldezR9LVthLWYwLTldezR9LVthLWYwLTldezR9LVthLWYwLTldezEyfSQvaS50ZXN0KHRoaXMuY29uZmlnLmtleUlkKSB8fFxuICAgICAgL15hcm46YXdzOmttczpbYS16MC05LV0rOlxcZHsxMn06a2V5XFwvW2EtZjAtOS1dKyQvaS50ZXN0KHRoaXMuY29uZmlnLmtleUlkKSB8fFxuICAgICAgL15hbGlhc1xcL1thLXpBLVowLTkvXy1dKyQvLnRlc3QodGhpcy5jb25maWcua2V5SWQpO1xuXG4gICAgaWYgKCFpc1ZhbGlkS2V5SWQpIHtcbiAgICAgIHRocm93IG5ldyBLZXlNYW5hZ2VtZW50RXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEtNUyBLZXkgSUQgZm9ybWF0JyxcbiAgICAgICAgJ0lOVkFMSURfS0VZX0lEX0ZPUk1BVCcsXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlJZDogdGhpcy5jb25maWcua2V5SWQsXG4gICAgICAgICAgaGludDogJ0tleSBJRCBzaG91bGQgYmUgVVVJRCwgQVJOLCBvciBhbGlhcyBmb3JtYXQnLFxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyBkYXRhIGtleSBmb3IgdGVuYW50LXNwZWNpZmljIGVuY3J5cHRpb25cbiAgICpcbiAgICogQHBhcmFtIHRlbmFudElkIC0gVGVuYW50IGlkZW50aWZpZXIgZm9yIGtleSBpc29sYXRpb25cbiAgICogQHBhcmFtIGtleVNwZWMgLSBLZXkgc3BlY2lmaWNhdGlvbiAoZGVmYXVsdDogQUVTXzI1NilcbiAgICogQHJldHVybnMgRGF0YSBrZXkgcmVzdWx0IHdpdGggY2lwaGVydGV4dCBhbmQgcGxhaW50ZXh0XG4gICAqIEB0aHJvd3Mge0tleU1hbmFnZW1lbnRFcnJvcn0gSWYga2V5IGdlbmVyYXRpb24gZmFpbHNcbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlRGF0YUtleShcbiAgICB0ZW5hbnRJZDogc3RyaW5nLFxuICAgIGtleVNwZWM6ICdBRVNfMjU2JyB8ICdBRVNfMTI4JyA9ICdBRVNfMjU2J1xuICApOiBQcm9taXNlPERhdGFLZXlSZXN1bHQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuc3RhdHMudG90YWxPcGVyYXRpb25zKys7XG5cbiAgICB0cnkge1xuICAgICAgLy8gQ3JlYXRlIGVuY3J5cHRpb24gY29udGV4dCBmb3IgdGVuYW50IGlzb2xhdGlvblxuICAgICAgY29uc3QgZW5jcnlwdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIFRlbmFudElkOiB0ZW5hbnRJZCxcbiAgICAgICAgUHVycG9zZTogJ0RhdGFFbmNyeXB0aW9uJyxcbiAgICAgICAgVGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbnB1dDogR2VuZXJhdGVEYXRhS2V5Q29tbWFuZElucHV0ID0ge1xuICAgICAgICBLZXlJZDogdGhpcy5jb25maWcua2V5SWQsXG4gICAgICAgIEtleVNwZWM6IGtleVNwZWMsXG4gICAgICAgIEVuY3J5cHRpb25Db250ZXh0OiBlbmNyeXB0aW9uQ29udGV4dCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNvbW1hbmQgPSBuZXcgR2VuZXJhdGVEYXRhS2V5Q29tbWFuZChpbnB1dCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnNlbmQoY29tbWFuZCk7XG5cbiAgICAgIGlmICghcmVzcG9uc2UuQ2lwaGVydGV4dEJsb2IgfHwgIXJlc3BvbnNlLlBsYWludGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgS2V5TWFuYWdlbWVudEVycm9yKFxuICAgICAgICAgICdLTVMgcmV0dXJuZWQgaW5jb21wbGV0ZSBkYXRhIGtleScsXG4gICAgICAgICAgJ0lOQ09NUExFVEVfREFUQV9LRVknLFxuICAgICAgICAgIHsgcmVzcG9uc2UgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQ6IERhdGFLZXlSZXN1bHQgPSB7XG4gICAgICAgIGNpcGhlcnRleHQ6IEJ1ZmZlci5mcm9tKHJlc3BvbnNlLkNpcGhlcnRleHRCbG9iKS50b1N0cmluZygnYmFzZTY0JyksXG4gICAgICAgIHBsYWludGV4dDogQnVmZmVyLmZyb20ocmVzcG9uc2UuUGxhaW50ZXh0KSxcbiAgICAgICAga2V5SWQ6IHJlc3BvbnNlLktleUlkIHx8IHRoaXMuY29uZmlnLmtleUlkLFxuICAgICAgfTtcblxuICAgICAgLy8gQ2FjaGUgdGhlIHBsYWludGV4dCBrZXlcbiAgICAgIHRoaXMuY2FjaGVLZXkodGVuYW50SWQsIHJlc3VsdC5wbGFpbnRleHQpO1xuXG4gICAgICB0aGlzLnN0YXRzLnN1Y2Nlc3NmdWwrKztcbiAgICAgIHRoaXMudXBkYXRlQXZlcmFnZVJlc3BvbnNlVGltZShEYXRlLm5vdygpIC0gc3RhcnRUaW1lKTtcblxuICAgICAgLy8gQXVkaXQgbG9nXG4gICAgICB0aGlzLmxvZ09wZXJhdGlvbignZ2VuZXJhdGVEYXRhS2V5JywgdGVuYW50SWQsIHRydWUpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLnN0YXRzLmZhaWxlZCsrO1xuICAgICAgdGhpcy5sb2dPcGVyYXRpb24oJ2dlbmVyYXRlRGF0YUtleScsIHRlbmFudElkLCBmYWxzZSwgZXJyb3IpO1xuXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBLTVNTZXJ2aWNlRXhjZXB0aW9uKSB7XG4gICAgICAgIHRocm93IHRoaXMuaGFuZGxlS01TRXJyb3IoZXJyb3IsICdnZW5lcmF0ZURhdGFLZXknKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEtleU1hbmFnZW1lbnRFcnJvcihcbiAgICAgICAgJ0ZhaWxlZCB0byBnZW5lcmF0ZSBkYXRhIGtleScsXG4gICAgICAgICdHRU5FUkFURV9LRVlfRkFJTEVEJyxcbiAgICAgICAge1xuICAgICAgICAgIHRlbmFudElkLFxuICAgICAgICAgIG9yaWdpbmFsRXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVjcnlwdCBhIGNpcGhlcnRleHQgZGF0YSBrZXlcbiAgICpcbiAgICogQHBhcmFtIGNpcGhlcnRleHQgLSBCYXNlNjQgZW5jb2RlZCBlbmNyeXB0ZWQgZGF0YSBrZXlcbiAgICogQHBhcmFtIHRlbmFudElkIC0gVGVuYW50IGlkZW50aWZpZXIgZm9yIGNvbnRleHQgdmFsaWRhdGlvblxuICAgKiBAcmV0dXJucyBEZWNyeXB0ZWQgcGxhaW50ZXh0IGtleVxuICAgKiBAdGhyb3dzIHtLZXlNYW5hZ2VtZW50RXJyb3J9IElmIGRlY3J5cHRpb24gZmFpbHNcbiAgICovXG4gIGFzeW5jIGRlY3J5cHREYXRhS2V5KFxuICAgIGNpcGhlcnRleHQ6IHN0cmluZyxcbiAgICB0ZW5hbnRJZDogc3RyaW5nXG4gICk6IFByb21pc2U8RGVjcnlwdGlvblJlc3VsdD4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5zdGF0cy50b3RhbE9wZXJhdGlvbnMrKztcblxuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBjYWNoZSBmaXJzdFxuICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5nZXRDYWNoZWRLZXkodGVuYW50SWQpO1xuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICB0aGlzLnN0YXRzLmNhY2hlSGl0cysrO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBsYWludGV4dDogY2FjaGVkLFxuICAgICAgICAgIGtleUlkOiB0aGlzLmNvbmZpZy5rZXlJZCxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0cy5jYWNoZU1pc3NlcysrO1xuXG4gICAgICAvLyBDcmVhdGUgZW5jcnlwdGlvbiBjb250ZXh0IGZvciB0ZW5hbnQgdmFsaWRhdGlvblxuICAgICAgY29uc3QgZW5jcnlwdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIFRlbmFudElkOiB0ZW5hbnRJZCxcbiAgICAgICAgUHVycG9zZTogJ0RhdGFFbmNyeXB0aW9uJyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGlucHV0OiBEZWNyeXB0Q29tbWFuZElucHV0ID0ge1xuICAgICAgICBDaXBoZXJ0ZXh0QmxvYjogQnVmZmVyLmZyb20oY2lwaGVydGV4dCwgJ2Jhc2U2NCcpLFxuICAgICAgICBFbmNyeXB0aW9uQ29udGV4dDogZW5jcnlwdGlvbkNvbnRleHQsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjb21tYW5kID0gbmV3IERlY3J5cHRDb21tYW5kKGlucHV0KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQuc2VuZChjb21tYW5kKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5QbGFpbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEtleU1hbmFnZW1lbnRFcnJvcihcbiAgICAgICAgICAnS01TIHJldHVybmVkIG5vIHBsYWludGV4dCcsXG4gICAgICAgICAgJ05PX1BMQUlOVEVYVCcsXG4gICAgICAgICAgeyByZXNwb25zZSB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBsYWludGV4dCA9IEJ1ZmZlci5mcm9tKHJlc3BvbnNlLlBsYWludGV4dCk7XG5cbiAgICAgIC8vIENhY2hlIHRoZSBkZWNyeXB0ZWQga2V5XG4gICAgICB0aGlzLmNhY2hlS2V5KHRlbmFudElkLCBwbGFpbnRleHQpO1xuXG4gICAgICB0aGlzLnN0YXRzLnN1Y2Nlc3NmdWwrKztcbiAgICAgIHRoaXMudXBkYXRlQXZlcmFnZVJlc3BvbnNlVGltZShEYXRlLm5vdygpIC0gc3RhcnRUaW1lKTtcblxuICAgICAgLy8gQXVkaXQgbG9nXG4gICAgICB0aGlzLmxvZ09wZXJhdGlvbignZGVjcnlwdERhdGFLZXknLCB0ZW5hbnRJZCwgdHJ1ZSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBsYWludGV4dCxcbiAgICAgICAga2V5SWQ6IHJlc3BvbnNlLktleUlkIHx8IHRoaXMuY29uZmlnLmtleUlkLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5zdGF0cy5mYWlsZWQrKztcbiAgICAgIHRoaXMubG9nT3BlcmF0aW9uKCdkZWNyeXB0RGF0YUtleScsIHRlbmFudElkLCBmYWxzZSwgZXJyb3IpO1xuXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBLTVNTZXJ2aWNlRXhjZXB0aW9uKSB7XG4gICAgICAgIHRocm93IHRoaXMuaGFuZGxlS01TRXJyb3IoZXJyb3IsICdkZWNyeXB0RGF0YUtleScpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgS2V5TWFuYWdlbWVudEVycm9yKFxuICAgICAgICAnRmFpbGVkIHRvIGRlY3J5cHQgZGF0YSBrZXknLFxuICAgICAgICAnREVDUllQVF9LRVlfRkFJTEVEJyxcbiAgICAgICAge1xuICAgICAgICAgIHRlbmFudElkLFxuICAgICAgICAgIG9yaWdpbmFsRXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5jcnlwdCBkYXRhIGRpcmVjdGx5IHdpdGggS01TIChmb3Igc21hbGwgcGF5bG9hZHMpXG4gICAqXG4gICAqIEBwYXJhbSBwbGFpbnRleHQgLSBEYXRhIHRvIGVuY3J5cHRcbiAgICogQHBhcmFtIHRlbmFudElkIC0gVGVuYW50IGlkZW50aWZpZXJcbiAgICogQHJldHVybnMgRW5jcnlwdGVkIGNpcGhlcnRleHQgYXMgYmFzZTY0XG4gICAqIEB0aHJvd3Mge0tleU1hbmFnZW1lbnRFcnJvcn0gSWYgZW5jcnlwdGlvbiBmYWlsc1xuICAgKi9cbiAgYXN5bmMgZW5jcnlwdChwbGFpbnRleHQ6IHN0cmluZywgdGVuYW50SWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLnN0YXRzLnRvdGFsT3BlcmF0aW9ucysrO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVuY3J5cHRpb25Db250ZXh0ID0ge1xuICAgICAgICBUZW5hbnRJZDogdGVuYW50SWQsXG4gICAgICAgIFB1cnBvc2U6ICdEaXJlY3RFbmNyeXB0aW9uJyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGlucHV0OiBFbmNyeXB0Q29tbWFuZElucHV0ID0ge1xuICAgICAgICBLZXlJZDogdGhpcy5jb25maWcua2V5SWQsXG4gICAgICAgIFBsYWludGV4dDogQnVmZmVyLmZyb20ocGxhaW50ZXh0KSxcbiAgICAgICAgRW5jcnlwdGlvbkNvbnRleHQ6IGVuY3J5cHRpb25Db250ZXh0LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgY29tbWFuZCA9IG5ldyBFbmNyeXB0Q29tbWFuZChpbnB1dCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnNlbmQoY29tbWFuZCk7XG5cbiAgICAgIGlmICghcmVzcG9uc2UuQ2lwaGVydGV4dEJsb2IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEtleU1hbmFnZW1lbnRFcnJvcihcbiAgICAgICAgICAnS01TIHJldHVybmVkIG5vIGNpcGhlcnRleHQnLFxuICAgICAgICAgICdOT19DSVBIRVJURVhUJyxcbiAgICAgICAgICB7IHJlc3BvbnNlIH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0cy5zdWNjZXNzZnVsKys7XG4gICAgICB0aGlzLnVwZGF0ZUF2ZXJhZ2VSZXNwb25zZVRpbWUoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSk7XG5cbiAgICAgIHRoaXMubG9nT3BlcmF0aW9uKCdlbmNyeXB0JywgdGVuYW50SWQsIHRydWUpO1xuXG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20ocmVzcG9uc2UuQ2lwaGVydGV4dEJsb2IpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5zdGF0cy5mYWlsZWQrKztcbiAgICAgIHRoaXMubG9nT3BlcmF0aW9uKCdlbmNyeXB0JywgdGVuYW50SWQsIGZhbHNlLCBlcnJvcik7XG5cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEtNU1NlcnZpY2VFeGNlcHRpb24pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVLTVNFcnJvcihlcnJvciwgJ2VuY3J5cHQnKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEtleU1hbmFnZW1lbnRFcnJvcihcbiAgICAgICAgJ0ZhaWxlZCB0byBlbmNyeXB0IHdpdGggS01TJyxcbiAgICAgICAgJ0VOQ1JZUFRfRkFJTEVEJyxcbiAgICAgICAge1xuICAgICAgICAgIHRlbmFudElkLFxuICAgICAgICAgIG9yaWdpbmFsRXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IEtNUyBrZXkgbWV0YWRhdGFcbiAgICpcbiAgICogQHJldHVybnMgS2V5IG1ldGFkYXRhIGluZm9ybWF0aW9uXG4gICAqIEB0aHJvd3Mge0tleU1hbmFnZW1lbnRFcnJvcn0gSWYgb3BlcmF0aW9uIGZhaWxzXG4gICAqL1xuICBhc3luYyBnZXRLZXlNZXRhZGF0YSgpOiBQcm9taXNlPEtleU1ldGFkYXRhPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbW1hbmQgPSBuZXcgRGVzY3JpYmVLZXlDb21tYW5kKHsgS2V5SWQ6IHRoaXMuY29uZmlnLmtleUlkIH0pO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5zZW5kKGNvbW1hbmQpO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLktleU1ldGFkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBLZXlNYW5hZ2VtZW50RXJyb3IoXG4gICAgICAgICAgJ05vIGtleSBtZXRhZGF0YSByZXR1cm5lZCcsXG4gICAgICAgICAgJ05PX0tFWV9NRVRBREFUQSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5SWQ6IHJlc3BvbnNlLktleU1ldGFkYXRhLktleUlkIHx8IHRoaXMuY29uZmlnLmtleUlkLFxuICAgICAgICBhcm46IHJlc3BvbnNlLktleU1ldGFkYXRhLkFybiB8fCAnJyxcbiAgICAgICAgc3RhdGU6IHJlc3BvbnNlLktleU1ldGFkYXRhLktleVN0YXRlIHx8ICdVbmtub3duJyxcbiAgICAgICAgY3JlYXRlZEF0OiByZXNwb25zZS5LZXlNZXRhZGF0YS5DcmVhdGlvbkRhdGUgfHwgbmV3IERhdGUoKSxcbiAgICAgICAgZGVzY3JpcHRpb246IHJlc3BvbnNlLktleU1ldGFkYXRhLkRlc2NyaXB0aW9uLFxuICAgICAgICByb3RhdGlvbkVuYWJsZWQ6IHJlc3BvbnNlLktleU1ldGFkYXRhLktleVJvdGF0aW9uRW5hYmxlZCB8fCBmYWxzZSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEtNU1NlcnZpY2VFeGNlcHRpb24pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVLTVNFcnJvcihlcnJvciwgJ2dldEtleU1ldGFkYXRhJyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBLZXlNYW5hZ2VtZW50RXJyb3IoXG4gICAgICAgICdGYWlsZWQgdG8gZ2V0IGtleSBtZXRhZGF0YScsXG4gICAgICAgICdHRVRfTUVUQURBVEFfRkFJTEVEJyxcbiAgICAgICAge1xuICAgICAgICAgIG9yaWdpbmFsRXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgY2FjaGVkIGtleXMgZm9yIGEgdGVuYW50XG4gICAqXG4gICAqIEBwYXJhbSB0ZW5hbnRJZCAtIFRlbmFudCBpZGVudGlmaWVyIChvcHRpb25hbCwgY2xlYXJzIGFsbCBpZiBub3QgcHJvdmlkZWQpXG4gICAqL1xuICBjbGVhckNhY2hlKHRlbmFudElkPzogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRlbmFudElkKSB7XG4gICAgICB0aGlzLmtleUNhY2hlLmRlbGV0ZSh0ZW5hbnRJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMua2V5Q2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IEtNUyBjbGllbnQgc3RhdGlzdGljc1xuICAgKlxuICAgKiBAcmV0dXJucyBDdXJyZW50IHN0YXRpc3RpY3NcbiAgICovXG4gIGdldFN0YXRzKCk6IEtNU1N0YXRzIHtcbiAgICByZXR1cm4geyAuLi50aGlzLnN0YXRzIH07XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgc3RhdGlzdGljc1xuICAgKi9cbiAgcmVzZXRTdGF0cygpOiB2b2lkIHtcbiAgICB0aGlzLnN0YXRzID0ge1xuICAgICAgdG90YWxPcGVyYXRpb25zOiAwLFxuICAgICAgc3VjY2Vzc2Z1bDogMCxcbiAgICAgIGZhaWxlZDogMCxcbiAgICAgIGNhY2hlSGl0czogMCxcbiAgICAgIGNhY2hlTWlzc2VzOiAwLFxuICAgICAgYXZlcmFnZVJlc3BvbnNlVGltZTogMCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgS01TIGNvbm5lY3Rpdml0eSBhbmQgcGVybWlzc2lvbnNcbiAgICpcbiAgICogQHJldHVybnMgVHJ1ZSBpZiBjb25uZWN0aW9uIHN1Y2Nlc3NmdWxcbiAgICovXG4gIGFzeW5jIHRlc3RDb25uZWN0aW9uKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmdldEtleU1ldGFkYXRhKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignS01TIGNvbm5lY3Rpb24gdGVzdCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWNoZSBhIGRlY3J5cHRlZCBrZXlcbiAgICovXG4gIHByaXZhdGUgY2FjaGVLZXkodGVuYW50SWQ6IHN0cmluZywga2V5OiBCdWZmZXIpOiB2b2lkIHtcbiAgICB0aGlzLmtleUNhY2hlLnNldCh0ZW5hbnRJZCwge1xuICAgICAga2V5OiBCdWZmZXIuZnJvbShrZXkpLCAvLyBDbG9uZSB0aGUgYnVmZmVyXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNhY2hlZCBrZXkgaWYgdmFsaWRcbiAgICovXG4gIHByaXZhdGUgZ2V0Q2FjaGVkS2V5KHRlbmFudElkOiBzdHJpbmcpOiBCdWZmZXIgfCBudWxsIHtcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLmtleUNhY2hlLmdldCh0ZW5hbnRJZCk7XG5cbiAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgY2FjaGUgZW50cnkgaXMgc3RpbGwgdmFsaWRcbiAgICBpZiAoRGF0ZS5ub3coKSAtIGNhY2hlZC50aW1lc3RhbXAgPiB0aGlzLkNBQ0hFX1RUTCkge1xuICAgICAgdGhpcy5rZXlDYWNoZS5kZWxldGUodGVuYW50SWQpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNhY2hlZC5rZXkpOyAvLyBSZXR1cm4gYSBjb3B5XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGF2ZXJhZ2UgcmVzcG9uc2UgdGltZVxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVBdmVyYWdlUmVzcG9uc2VUaW1lKHJlc3BvbnNlVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLnN0YXRzLmF2ZXJhZ2VSZXNwb25zZVRpbWUgKiAodGhpcy5zdGF0cy5zdWNjZXNzZnVsIC0gMSkgKyByZXNwb25zZVRpbWU7XG4gICAgdGhpcy5zdGF0cy5hdmVyYWdlUmVzcG9uc2VUaW1lID0gdG90YWwgLyB0aGlzLnN0YXRzLnN1Y2Nlc3NmdWw7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIEtNUy1zcGVjaWZpYyBlcnJvcnNcbiAgICovXG4gIHByaXZhdGUgaGFuZGxlS01TRXJyb3IoZXJyb3I6IEtNU1NlcnZpY2VFeGNlcHRpb24sIG9wZXJhdGlvbjogc3RyaW5nKTogS2V5TWFuYWdlbWVudEVycm9yIHtcbiAgICBjb25zdCBlcnJvck1hcDogUmVjb3JkPHN0cmluZywgeyBjb2RlOiBzdHJpbmc7IG1lc3NhZ2U6IHN0cmluZyB9PiA9IHtcbiAgICAgIE5vdEZvdW5kRXhjZXB0aW9uOiB7XG4gICAgICAgIGNvZGU6ICdLRVlfTk9UX0ZPVU5EJyxcbiAgICAgICAgbWVzc2FnZTogJ0tNUyBrZXkgbm90IGZvdW5kJyxcbiAgICAgIH0sXG4gICAgICBEaXNhYmxlZEV4Y2VwdGlvbjoge1xuICAgICAgICBjb2RlOiAnS0VZX0RJU0FCTEVEJyxcbiAgICAgICAgbWVzc2FnZTogJ0tNUyBrZXkgaXMgZGlzYWJsZWQnLFxuICAgICAgfSxcbiAgICAgIEludmFsaWRDaXBoZXJ0ZXh0RXhjZXB0aW9uOiB7XG4gICAgICAgIGNvZGU6ICdJTlZBTElEX0NJUEhFUlRFWFQnLFxuICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBjaXBoZXJ0ZXh0IG9yIGVuY3J5cHRpb24gY29udGV4dCcsXG4gICAgICB9LFxuICAgICAgQWNjZXNzRGVuaWVkRXhjZXB0aW9uOiB7XG4gICAgICAgIGNvZGU6ICdBQ0NFU1NfREVOSUVEJyxcbiAgICAgICAgbWVzc2FnZTogJ0FjY2VzcyBkZW5pZWQgdG8gS01TIGtleScsXG4gICAgICB9LFxuICAgICAgSW52YWxpZEdyYW50VG9rZW5FeGNlcHRpb246IHtcbiAgICAgICAgY29kZTogJ0lOVkFMSURfR1JBTlRfVE9LRU4nLFxuICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBncmFudCB0b2tlbicsXG4gICAgICB9LFxuICAgICAgS01TSW50ZXJuYWxFeGNlcHRpb246IHtcbiAgICAgICAgY29kZTogJ0tNU19JTlRFUk5BTF9FUlJPUicsXG4gICAgICAgIG1lc3NhZ2U6ICdBV1MgS01TIGludGVybmFsIGVycm9yJyxcbiAgICAgIH0sXG4gICAgICBLTVNJbnZhbGlkU3RhdGVFeGNlcHRpb246IHtcbiAgICAgICAgY29kZTogJ0lOVkFMSURfS0VZX1NUQVRFJyxcbiAgICAgICAgbWVzc2FnZTogJ0tNUyBrZXkgaXMgaW4gaW52YWxpZCBzdGF0ZScsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBjb25zdCBtYXBwZWQgPSBlcnJvck1hcFtlcnJvci5uYW1lXSB8fCB7XG4gICAgICBjb2RlOiAnS01TX0VSUk9SJyxcbiAgICAgIG1lc3NhZ2U6ICdBV1MgS01TIG9wZXJhdGlvbiBmYWlsZWQnLFxuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IEtleU1hbmFnZW1lbnRFcnJvcihcbiAgICAgIGAke21hcHBlZC5tZXNzYWdlfTogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICBtYXBwZWQuY29kZSxcbiAgICAgIHtcbiAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICBhd3NFcnJvcjogZXJyb3IubmFtZSxcbiAgICAgICAgcmVxdWVzdElkOiBlcnJvci4kbWV0YWRhdGE/LnJlcXVlc3RJZCxcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZyBLTVMgb3BlcmF0aW9uIGZvciBhdWRpdCB0cmFpbFxuICAgKi9cbiAgcHJpdmF0ZSBsb2dPcGVyYXRpb24oXG4gICAgb3BlcmF0aW9uOiBzdHJpbmcsXG4gICAgdGVuYW50SWQ6IHN0cmluZyxcbiAgICBzdWNjZXNzOiBib29sZWFuLFxuICAgIGVycm9yPzogdW5rbm93blxuICApOiB2b2lkIHtcbiAgICBjb25zdCBsb2dFbnRyeSA9IHtcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgb3BlcmF0aW9uLFxuICAgICAgdGVuYW50SWQsXG4gICAgICBzdWNjZXNzLFxuICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogdW5kZWZpbmVkLFxuICAgIH07XG5cbiAgICAvLyBJbiBwcm9kdWN0aW9uLCBzZW5kIHRvIHByb3BlciBsb2dnaW5nIHNlcnZpY2VcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbS01TIEF1ZGl0XScsIEpTT04uc3RyaW5naWZ5KGxvZ0VudHJ5KSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogSW50ZWdyYXRlIHdpdGggY2VudHJhbGl6ZWQgbG9nZ2luZyBzZXJ2aWNlXG4gICAgLy8gYXdhaXQgbG9nU2VydmljZS5sb2coJ2ttc19vcGVyYXRpb24nLCBsb2dFbnRyeSk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgY2xpZW50IGFuZCBjbGVhbiB1cCByZXNvdXJjZXNcbiAgICovXG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgdGhpcy5jbGllbnQuZGVzdHJveSgpO1xuICB9XG59XG5cbi8qKlxuICogU2luZ2xldG9uIEtNUyBjbGllbnQgaW5zdGFuY2VcbiAqL1xubGV0IGttc0NsaWVudEluc3RhbmNlOiBLTVNDbGllbnQgfCBudWxsID0gbnVsbDtcblxuLyoqXG4gKiBHZXQgb3IgY3JlYXRlIEtNUyBjbGllbnQgc2luZ2xldG9uXG4gKlxuICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb25cbiAqIEByZXR1cm5zIEtNUyBjbGllbnQgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEtNU0NsaWVudChjb25maWc/OiBQYXJ0aWFsPEtNU0NvbmZpZz4pOiBLTVNDbGllbnQge1xuICBpZiAoIWttc0NsaWVudEluc3RhbmNlKSB7XG4gICAga21zQ2xpZW50SW5zdGFuY2UgPSBuZXcgS01TQ2xpZW50KGNvbmZpZyk7XG4gIH1cbiAgcmV0dXJuIGttc0NsaWVudEluc3RhbmNlO1xufVxuXG4vKipcbiAqIFJlc2V0IEtNUyBjbGllbnQgc2luZ2xldG9uICh1c2VmdWwgZm9yIHRlc3RpbmcpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNldEtNU0NsaWVudCgpOiB2b2lkIHtcbiAgaWYgKGttc0NsaWVudEluc3RhbmNlKSB7XG4gICAga21zQ2xpZW50SW5zdGFuY2UuZGVzdHJveSgpO1xuICAgIGttc0NsaWVudEluc3RhbmNlID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9ydCBmb3IgdGVzdGluZ1xuICovXG5leHBvcnQgY29uc3QgX190ZXN0aW5nX18gPSB7XG4gIEtNU0NsaWVudCxcbiAgcmVzZXRLTVNDbGllbnQsXG59O1xuIl0sIm5hbWVzIjpbIktNU0NsaWVudCIsIl9fdGVzdGluZ19fIiwiZ2V0S01TQ2xpZW50IiwicmVzZXRLTVNDbGllbnQiLCJjb25maWciLCJDQUNIRV9UVEwiLCJsb2FkQ29uZmlnIiwidmFsaWRhdGVDb25maWciLCJjbGllbnQiLCJBV1NLTVNDbGllbnQiLCJyZWdpb24iLCJjcmVkZW50aWFscyIsImFjY2Vzc0tleUlkIiwic2VjcmV0QWNjZXNzS2V5IiwiZnJvbUVudiIsIm1heEF0dGVtcHRzIiwibWF4UmV0cmllcyIsInJlcXVlc3RIYW5kbGVyIiwicmVxdWVzdFRpbWVvdXQiLCJ0aW1lb3V0Iiwia2V5Q2FjaGUiLCJNYXAiLCJzdGF0cyIsInRvdGFsT3BlcmF0aW9ucyIsInN1Y2Nlc3NmdWwiLCJmYWlsZWQiLCJjYWNoZUhpdHMiLCJjYWNoZU1pc3NlcyIsImF2ZXJhZ2VSZXNwb25zZVRpbWUiLCJwcm9jZXNzIiwiZW52IiwiQVdTX1JFR0lPTiIsImtleUlkIiwiQVdTX0tNU19LRVlfSUQiLCJBV1NfQUNDRVNTX0tFWV9JRCIsIkFXU19TRUNSRVRfQUNDRVNTX0tFWSIsIktleU1hbmFnZW1lbnRFcnJvciIsImhpbnQiLCJpc1ZhbGlkS2V5SWQiLCJ0ZXN0IiwiZ2VuZXJhdGVEYXRhS2V5IiwidGVuYW50SWQiLCJrZXlTcGVjIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsImVuY3J5cHRpb25Db250ZXh0IiwiVGVuYW50SWQiLCJQdXJwb3NlIiwiVGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJpbnB1dCIsIktleUlkIiwiS2V5U3BlYyIsIkVuY3J5cHRpb25Db250ZXh0IiwiY29tbWFuZCIsIkdlbmVyYXRlRGF0YUtleUNvbW1hbmQiLCJyZXNwb25zZSIsInNlbmQiLCJDaXBoZXJ0ZXh0QmxvYiIsIlBsYWludGV4dCIsInJlc3VsdCIsImNpcGhlcnRleHQiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJwbGFpbnRleHQiLCJjYWNoZUtleSIsInVwZGF0ZUF2ZXJhZ2VSZXNwb25zZVRpbWUiLCJsb2dPcGVyYXRpb24iLCJlcnJvciIsIktNU1NlcnZpY2VFeGNlcHRpb24iLCJoYW5kbGVLTVNFcnJvciIsIm9yaWdpbmFsRXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJTdHJpbmciLCJkZWNyeXB0RGF0YUtleSIsImNhY2hlZCIsImdldENhY2hlZEtleSIsIkRlY3J5cHRDb21tYW5kIiwiZW5jcnlwdCIsIkVuY3J5cHRDb21tYW5kIiwiZ2V0S2V5TWV0YWRhdGEiLCJEZXNjcmliZUtleUNvbW1hbmQiLCJLZXlNZXRhZGF0YSIsImFybiIsIkFybiIsInN0YXRlIiwiS2V5U3RhdGUiLCJjcmVhdGVkQXQiLCJDcmVhdGlvbkRhdGUiLCJkZXNjcmlwdGlvbiIsIkRlc2NyaXB0aW9uIiwicm90YXRpb25FbmFibGVkIiwiS2V5Um90YXRpb25FbmFibGVkIiwiY2xlYXJDYWNoZSIsImRlbGV0ZSIsImNsZWFyIiwiZ2V0U3RhdHMiLCJyZXNldFN0YXRzIiwidGVzdENvbm5lY3Rpb24iLCJjb25zb2xlIiwia2V5Iiwic2V0IiwidGltZXN0YW1wIiwiZ2V0IiwicmVzcG9uc2VUaW1lIiwidG90YWwiLCJvcGVyYXRpb24iLCJlcnJvck1hcCIsIk5vdEZvdW5kRXhjZXB0aW9uIiwiY29kZSIsIkRpc2FibGVkRXhjZXB0aW9uIiwiSW52YWxpZENpcGhlcnRleHRFeGNlcHRpb24iLCJBY2Nlc3NEZW5pZWRFeGNlcHRpb24iLCJJbnZhbGlkR3JhbnRUb2tlbkV4Y2VwdGlvbiIsIktNU0ludGVybmFsRXhjZXB0aW9uIiwiS01TSW52YWxpZFN0YXRlRXhjZXB0aW9uIiwibWFwcGVkIiwibmFtZSIsImF3c0Vycm9yIiwicmVxdWVzdElkIiwiJG1ldGFkYXRhIiwic3VjY2VzcyIsImxvZ0VudHJ5IiwidW5kZWZpbmVkIiwiTk9ERV9FTlYiLCJsb2ciLCJKU09OIiwic3RyaW5naWZ5IiwiZGVzdHJveSIsImttc0NsaWVudEluc3RhbmNlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUM7Ozs7Ozs7Ozs7O1FBa0dZQTtlQUFBQTs7UUFzakJBQztlQUFBQTs7UUFwQkdDO2VBQUFBOztRQVVBQztlQUFBQTs7OzJCQS9uQlQ7cUNBQ2lCO3VCQUNXO0FBaUY1QixNQUFNSDtJQU9YOzs7OztHQUtDLEdBQ0QsWUFBWUksTUFBMkIsQ0FBRTthQVR4QkMsWUFBWSxTQUFTLHlCQUF5QjtRQVU3RCxJQUFJLENBQUNELE1BQU0sR0FBRyxJQUFJLENBQUNFLFVBQVUsQ0FBQ0Y7UUFDOUIsSUFBSSxDQUFDRyxjQUFjO1FBRW5CLDRCQUE0QjtRQUM1QixJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJQyxvQkFBWSxDQUFDO1lBQzdCQyxRQUFRLElBQUksQ0FBQ04sTUFBTSxDQUFDTSxNQUFNO1lBQzFCQyxhQUFhLElBQUksQ0FBQ1AsTUFBTSxDQUFDUSxXQUFXLElBQUksSUFBSSxDQUFDUixNQUFNLENBQUNTLGVBQWUsR0FDL0Q7Z0JB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