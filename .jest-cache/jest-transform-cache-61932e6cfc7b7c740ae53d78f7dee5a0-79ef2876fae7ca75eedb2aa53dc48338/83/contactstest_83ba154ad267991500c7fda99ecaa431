26aa367a95475a4bf24e1b2c708cc97c
/**
 * Contacts API Integration Tests
 *
 * Tests for /api/contacts endpoints including CRUD operations,
 * search/filtering, and multi-tenant isolation.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _apitesthelpers = require("../../utils/api-test-helpers");
const _testhelpers = require("../../utils/test-helpers");
_globals.jest.mock('@/lib/supabase/server');
// Helper wrapper for backward compatibility with test signatures
function createAuthenticatedRequest(method, url, userId, organizationId, body) {
    const fullUrl = url.startsWith('http') ? url : `http://localhost:3000${url}`;
    return (0, _apitesthelpers.createAuthenticatedRequest)({
        method,
        url: fullUrl,
        body,
        user: {
            id: userId
        },
        organizationId
    });
}
(0, _globals.describe)('GET /api/contacts', ()=>{
    let mockSupabase;
    let mockUser;
    let mockContacts;
    (0, _globals.beforeEach)(()=>{
        mockSupabase = (0, _testhelpers.createMockSupabaseClient)();
        mockUser = (0, _testhelpers.createMockUser)();
        mockContacts = (0, _testhelpers.generateMockContacts)(15, {
            organization_id: mockUser.organization_id
        });
        _globals.jest.clearAllMocks();
    });
    (0, _globals.it)('should list contacts with pagination', async ()=>{
        mockSupabase.from = _globals.jest.fn().mockReturnValue({
            select: _globals.jest.fn().mockReturnThis(),
            eq: _globals.jest.fn().mockReturnThis(),
            order: _globals.jest.fn().mockReturnThis(),
            range: _globals.jest.fn().mockResolvedValue({
                data: mockContacts.slice(0, 10),
                error: null,
                count: 15
            })
        });
        const url = (0, _apitesthelpers.createPaginatedUrl)('/api/contacts', {
            page: 1,
            limit: 10
        });
        const request = createAuthenticatedRequest('GET', url, mockUser.id, mockUser.organization_id);
        const response = await simulateGetContacts(request, mockSupabase, mockUser);
        const { status, data } = await (0, _apitesthelpers.parseResponse)(response);
        (0, _globals.expect)(status).toBe(200);
        (0, _apitesthelpers.expectPaginatedResponse)(data);
        (0, _globals.expect)(data.contacts).toHaveLength(10);
        (0, _globals.expect)(data.pagination.total).toBe(15);
        (0, _globals.expect)(data.pagination.hasMore).toBe(true);
    });
    (0, _globals.it)('should filter contacts by search term', async ()=>{
        const searchResults = mockContacts.filter((c)=>c.name.includes('John'));
        mockSupabase.from = _globals.jest.fn().mockReturnValue({
            select: _globals.jest.fn().mockReturnThis(),
            eq: _globals.jest.fn().mockReturnThis(),
            or: _globals.jest.fn().mockReturnThis(),
            order: _globals.jest.fn().mockReturnThis(),
            range: _globals.jest.fn().mockResolvedValue({
                data: searchResults,
                error: null,
                count: searchResults.length
            })
        });
        const url = '/api/contacts?search=John';
        const request = createAuthenticatedRequest('GET', url, mockUser.id, mockUser.organization_id);
        const response = await simulateGetContacts(request, mockSupabase, mockUser);
        const { status, data } = await (0, _apitesthelpers.parseResponse)(response);
        (0, _globals.expect)(status).toBe(200);
        (0, _globals.expect)(data.filters.search).toBe('John');
    });
    (0, _globals.it)('should enforce tenant isolation - cannot see other org contacts', async ()=>{
        const otherOrgContact = (0, _testhelpers.createMockContact)({
            organization_id: 'different-org-id'
        });
        mockSupabase.from = _globals.jest.fn().mockReturnValue({
            select: _globals.jest.fn().mockReturnThis(),
            eq: _globals.jest.fn().mockImplementation((field, value)=>{
                // Verify that organization_id filter is applied
                (0, _globals.expect)(field).toBe('organization_id');
                (0, _globals.expect)(value).toBe(mockUser.organization_id);
                return {
                    order: _globals.jest.fn().mockReturnThis(),
                    range: _globals.jest.fn().mockResolvedValue({
                        data: mockContacts,
                        error: null,
                        count: mockContacts.length
                    })
                };
            })
        });
        const request = createAuthenticatedRequest('GET', '/api/contacts', mockUser.id, mockUser.organization_id);
        const response = await simulateGetContacts(request, mockSupabase, mockUser);
        const { status, data } = await (0, _apitesthelpers.parseResponse)(response);
        (0, _globals.expect)(status).toBe(200);
        // Verify no contacts from other organizations
        data.contacts.forEach((contact)=>{
            (0, _globals.expect)(contact.organization_id).toBe(mockUser.organization_id);
        });
    });
    (0, _globals.it)('should filter by tags', async ()=>{
        const vipContacts = mockContacts.filter((c)=>c.tags?.includes('vip'));
        mockSupabase.from = _globals.jest.fn().mockReturnValue({
            select: _globals.jest.fn().mockReturnThis(),
            eq: _globals.jest.fn().mockReturnThis(),
            overlaps: _globals.jest.fn().mockReturnThis(),
            order: _globals.jest.fn().mockReturnThis(),
            range: _globals.jest.fn().mockResolvedValue({
                data: vipContacts,
                error: null,
                count: vipContacts.length
            })
        });
        const url = '/api/contacts?tags=vip';
        const request = createAuthenticatedRequest('GET', url, mockUser.id, mockUser.organization_id);
        const response = await simulateGetContacts(request, mockSupabase, mockUser);
        const { status, data } = await (0, _apitesthelpers.parseResponse)(response);
        (0, _globals.expect)(status).toBe(200);
        (0, _globals.expect)(data.filters.tags).toContain('vip');
    });
});
(0, _globals.describe)('POST /api/contacts', ()=>{
    let mockSupabase;
    let mockUser;
    (0, _globals.beforeEach)(()=>{
        mockSupabase = (0, _testhelpers.createMockSupabaseClient)();
        mockUser = (0, _testhelpers.createMockUser)();
        _globals.jest.clearAllMocks();
    });
    (0, _globals.it)('should create new contact with valid data', async ()=>{
        const newContactData = {
            phone_number: '+15551234567',
            name: 'New Contact',
            email: 'newcontact@example.com',
            tags: [
                'customer'
            ]
        };
        let callCount = 0;
        mockSupabase.from = _globals.jest.fn().mockReturnValue({
            select: _globals.jest.fn().mockReturnThis(),
            eq: _globals.jest.fn().mockReturnThis(),
            single: _globals.jest.fn().mockImplementation(()=>{
                callCount++;
                // First call: check for duplicate (returns null - no duplicate)
                if (callCount === 1) {
                    return Promise.resolve({
                        data: null,
                        error: null
                    });
                }
                // Second call: return created contact
                return Promise.resolve({
                    data: {
                        ...newContactData,
                        id: 'new-contact-id',
                        organization_id: mockUser.organization_id
                    },
                    error: null
                });
            }),
            insert: _globals.jest.fn().mockReturnThis()
        });
        const request = createAuthenticatedRequest('POST', '/api/contacts', mockUser.id, mockUser.organization_id, newContactData);
        const response = await simulateCreateContact(request, mockSupabase, mockUser);
        const { status, data } = await (0, _apitesthelpers.parseResponse)(response);
        (0, _globals.expect)(status).toBe(201);
        (0, _globals.expect)(data.phone_number).toBe(newContactData.phone_number);
        (0, _globals.expect)(data.organization_id).toBe(mockUser.organization_id);
    });
    (0, _globals.it)('should reject duplicate phone number in same organization', async ()=>{
        const existingContact = (0, _testhelpers.createMockContact)({
            organization_id: mockUser.organization_id
        });
        mockSupabase.from = _globals.jest.fn().mockReturnValue({
            select: _globals.jest.fn().mockReturnThis(),
            eq: _globals.jest.fn().mockReturnThis(),
            single: _globals.jest.fn().mockResolvedValue({
                data: existingContact,
                error: null
            })
        });
        const request = createAuthenticatedRequest('POST', '/api/contacts', mockUser.id, mockUser.organization_id, {
            phone_number: existingContact.phone_number,
            name: 'Duplicate'
        });
        const response = await simulateCreateContact(request, mockSupabase, mockUser);
        const { status, data } = await (0, _apitesthelpers.parseResponse)(response);
        (0, _globals.expect)(status).toBe(409);
        (0, _apitesthelpers.expectErrorResponse)(data, 409, 'already exists');
    });
    (0, _globals.it)('should validate phone number format', async ()=>{
        const request = createAuthenticatedRequest('POST', '/api/contacts', mockUser.id, mockUser.organization_id, {
            phone_number: 'invalid',
            name: 'Test'
        });
        const response = await simulateCreateContact(request, mockSupabase, mockUser);
        const { status, data } = await (0, _apitesthelpers.parseResponse)(response);
        (0, _globals.expect)(status).toBe(400);
        (0, _apitesthelpers.expectErrorResponse)(data, 400, 'Invalid phone number format');
    });
    (0, _globals.it)('should require phone number field', async ()=>{
        const request = createAuthenticatedRequest('POST', '/api/contacts', mockUser.id, mockUser.organization_id, {
            name: 'Test Contact'
        });
        const response = await simulateCreateContact(request, mockSupabase, mockUser);
        const { status, data } = await (0, _apitesthelpers.parseResponse)(response);
        (0, _globals.expect)(status).toBe(400);
        (0, _apitesthelpers.expectErrorResponse)(data, 400, 'Phone number is required');
    });
});
(0, _globals.describe)('PUT /api/contacts/[id]', ()=>{
    let mockSupabase;
    let mockUser;
    let mockContact;
    (0, _globals.beforeEach)(()=>{
        mockSupabase = (0, _testhelpers.createMockSupabaseClient)();
        mockUser = (0, _testhelpers.createMockUser)();
        mockContact = (0, _testhelpers.createMockContact)({
            organization_id: mockUser.organization_id
        });
        _globals.jest.clearAllMocks();
    });
    (0, _globals.it)('should update contact with valid data', async ()=>{
        const updateData = {
            name: 'Updated Name',
            tags: [
                'vip'
            ]
        };
        let callCount = 0;
        mockSupabase.from = _globals.jest.fn().mockReturnValue({
            select: _globals.jest.fn().mockReturnThis(),
            eq: _globals.jest.fn().mockReturnThis(),
            single: _globals.jest.fn().mockImplementation(()=>{
                callCount++;
                // First call: fetch contact (returns existing contact)
                if (callCount === 1) {
                    return Promise.resolve({
                        data: mockContact,
                        error: null
                    });
                }
                // Second call: return updated contact
                return Promise.resolve({
                    data: {
                        ...mockContact,
                        ...updateData
                    },
                    error: null
                });
            }),
            update: _globals.jest.fn().mockReturnThis()
        });
        const request = createAuthenticatedRequest('PUT', `/api/contacts/${mockContact.id}`, mockUser.id, mockUser.organization_id, updateData);
        const response = await simulateUpdateContact(request, mockSupabase, mockUser, mockContact.id);
        const { status, data } = await (0, _apitesthelpers.parseResponse)(response);
        (0, _globals.expect)(status).toBe(200);
        (0, _globals.expect)(data.name).toBe(updateData.name);
    });
    (0, _globals.it)('should prevent updating contact from different organization', async ()=>{
        const otherOrgContact = (0, _testhelpers.createMockContact)({
            organization_id: 'different-org-id'
        });
        mockSupabase.from = _globals.jest.fn().mockReturnValue({
            select: _globals.jest.fn().mockReturnThis(),
            eq: _globals.jest.fn().mockReturnThis(),
            single: _globals.jest.fn().mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            })
        });
        const request = createAuthenticatedRequest('PUT', `/api/contacts/${otherOrgContact.id}`, mockUser.id, mockUser.organization_id, {
            name: 'Hacked'
        });
        const response = await simulateUpdateContact(request, mockSupabase, mockUser, otherOrgContact.id);
        const { status, data } = await (0, _apitesthelpers.parseResponse)(response);
        (0, _globals.expect)(status).toBe(404);
        (0, _apitesthelpers.expectErrorResponse)(data, 404, 'not found');
    });
});
(0, _globals.describe)('DELETE /api/contacts/[id]', ()=>{
    let mockSupabase;
    let mockUser;
    let mockContact;
    (0, _globals.beforeEach)(()=>{
        mockSupabase = (0, _testhelpers.createMockSupabaseClient)();
        mockUser = (0, _testhelpers.createMockUser)();
        mockContact = (0, _testhelpers.createMockContact)({
            organization_id: mockUser.organization_id
        });
        _globals.jest.clearAllMocks();
    });
    (0, _globals.it)('should soft delete contact', async ()=>{
        mockSupabase.from = _globals.jest.fn().mockReturnValue({
            select: _globals.jest.fn().mockReturnThis(),
            eq: _globals.jest.fn().mockReturnThis(),
            single: _globals.jest.fn().mockResolvedValue({
                data: mockContact,
                error: null
            }),
            update: _globals.jest.fn().mockReturnThis()
        });
        const request = createAuthenticatedRequest('DELETE', `/api/contacts/${mockContact.id}`, mockUser.id, mockUser.organization_id);
        const response = await simulateDeleteContact(request, mockSupabase, mockUser, mockContact.id);
        const { status, data } = await (0, _apitesthelpers.parseResponse)(response);
        (0, _globals.expect)(status).toBe(200);
        (0, _globals.expect)(data.message).toContain('deleted');
    });
    (0, _globals.it)('should prevent deleting contact from different organization', async ()=>{
        const otherOrgContact = (0, _testhelpers.createMockContact)({
            organization_id: 'different-org-id'
        });
        mockSupabase.from = _globals.jest.fn().mockReturnValue({
            select: _globals.jest.fn().mockReturnThis(),
            eq: _globals.jest.fn().mockReturnThis(),
            single: _globals.jest.fn().mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            })
        });
        const request = createAuthenticatedRequest('DELETE', `/api/contacts/${otherOrgContact.id}`, mockUser.id, mockUser.organization_id);
        const response = await simulateDeleteContact(request, mockSupabase, mockUser, otherOrgContact.id);
        const { status, data } = await (0, _apitesthelpers.parseResponse)(response);
        (0, _globals.expect)(status).toBe(404);
        (0, _apitesthelpers.expectErrorResponse)(data, 404, 'not found');
    });
});
// =============================================================================
// Helper Functions to Simulate API Route Handlers
// =============================================================================
async function simulateGetContacts(request, supabase, user) {
    try {
        const { searchParams } = new URL(request.url);
        const search = searchParams.get('search');
        const tags = searchParams.get('tags')?.split(',');
        const page = parseInt(searchParams.get('page') || '1');
        const limit = parseInt(searchParams.get('limit') || '20');
        const offset = (page - 1) * limit;
        let query = supabase.from('contacts').select('*', {
            count: 'exact'
        }).eq('organization_id', user.organization_id);
        if (search) {
            query = query.or(`name.ilike.%${search}%,phone_number.ilike.%${search}%`);
        }
        if (tags && tags.length > 0) {
            query = query.overlaps('tags', tags);
        }
        const { data: contacts, error, count } = await query.order('created_at', {
            ascending: false
        }).range(offset, offset + limit - 1);
        if (error) throw error;
        return new Response(JSON.stringify({
            contacts,
            pagination: {
                page,
                limit,
                total: count || 0,
                hasMore: offset + limit < (count || 0)
            },
            filters: {
                search,
                tags
            }
        }), {
            status: 200,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    } catch (error) {
        return new Response(JSON.stringify({
            error: error.message
        }), {
            status: 500,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    }
}
async function simulateCreateContact(request, supabase, user) {
    try {
        const body = await request.json();
        const { phone_number, name, email, tags } = body;
        if (!phone_number) {
            return new Response(JSON.stringify({
                error: 'Phone number is required'
            }), {
                status: 400,
                headers: {
                    'Content-Type': 'application/json'
                }
            });
        }
        const phoneRegex = /^\+?[1-9]\d{1,14}$/;
        if (!phoneRegex.test(phone_number.replace(/[\s-()]/g, ''))) {
            return new Response(JSON.stringify({
                error: 'Invalid phone number format'
            }), {
                status: 400,
                headers: {
                    'Content-Type': 'application/json'
                }
            });
        }
        // Check for duplicates
        const { data: existingContact } = await supabase.from('contacts').select('id').eq('organization_id', user.organization_id).eq('phone_number', phone_number).single();
        if (existingContact) {
            return new Response(JSON.stringify({
                error: 'Contact with this phone number already exists'
            }), {
                status: 409,
                headers: {
                    'Content-Type': 'application/json'
                }
            });
        }
        // Create contact
        const { data: contact, error } = await supabase.from('contacts').insert({
            organization_id: user.organization_id,
            phone_number,
            name,
            email,
            tags
        }).select().single();
        if (error) throw error;
        return new Response(JSON.stringify(contact), {
            status: 201,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    } catch (error) {
        return new Response(JSON.stringify({
            error: error.message
        }), {
            status: 500,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    }
}
async function simulateUpdateContact(request, supabase, user, contactId) {
    try {
        const body = await request.json();
        // Check contact exists and belongs to organization
        const { data: contact, error: fetchError } = await supabase.from('contacts').select('*').eq('id', contactId).eq('organization_id', user.organization_id).single();
        if (fetchError || !contact) {
            return new Response(JSON.stringify({
                error: 'Contact not found'
            }), {
                status: 404,
                headers: {
                    'Content-Type': 'application/json'
                }
            });
        }
        // Update contact
        const { data: updated, error } = await supabase.from('contacts').update(body).eq('id', contactId).eq('organization_id', user.organization_id).select().single();
        if (error) throw error;
        return new Response(JSON.stringify(updated), {
            status: 200,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    } catch (error) {
        return new Response(JSON.stringify({
            error: error.message
        }), {
            status: 500,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    }
}
async function simulateDeleteContact(request, supabase, user, contactId) {
    try {
        // Check contact exists and belongs to organization
        const { data: contact, error: fetchError } = await supabase.from('contacts').select('*').eq('id', contactId).eq('organization_id', user.organization_id).single();
        if (fetchError || !contact) {
            return new Response(JSON.stringify({
                error: 'Contact not found'
            }), {
                status: 404,
                headers: {
                    'Content-Type': 'application/json'
                }
            });
        }
        // Soft delete
        const { error } = await supabase.from('contacts').update({
            deleted_at: new Date().toISOString()
        }).eq('id', contactId).eq('organization_id', user.organization_id);
        if (error) throw error;
        return new Response(JSON.stringify({
            message: 'Contact deleted successfully'
        }), {
            status: 200,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    } catch (error) {
        return new Response(JSON.stringify({
            error: error.message
        }), {
            status: 500,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxBaSBQcm9qZWN0ZW5cXEFEU2FwcFxcdGVzdHNcXGludGVncmF0aW9uXFxhcGlcXGNvbnRhY3RzLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb250YWN0cyBBUEkgSW50ZWdyYXRpb24gVGVzdHNcbiAqXG4gKiBUZXN0cyBmb3IgL2FwaS9jb250YWN0cyBlbmRwb2ludHMgaW5jbHVkaW5nIENSVUQgb3BlcmF0aW9ucyxcbiAqIHNlYXJjaC9maWx0ZXJpbmcsIGFuZCBtdWx0aS10ZW5hbnQgaXNvbGF0aW9uLlxuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoLCBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscydcbmltcG9ydCB7IE5leHRSZXF1ZXN0IH0gZnJvbSAnbmV4dC9zZXJ2ZXInXG5pbXBvcnQge1xuICBjcmVhdGVBdXRoZW50aWNhdGVkUmVxdWVzdCBhcyBjcmVhdGVBdXRoUmVxLFxuICBwYXJzZVJlc3BvbnNlLFxuICBleHBlY3RFcnJvclJlc3BvbnNlLFxuICBjcmVhdGVQYWdpbmF0ZWRVcmwsXG4gIGV4cGVjdFBhZ2luYXRlZFJlc3BvbnNlLFxufSBmcm9tICcuLi8uLi91dGlscy9hcGktdGVzdC1oZWxwZXJzJ1xuaW1wb3J0IHtcbiAgY3JlYXRlTW9ja1VzZXIsXG4gIGNyZWF0ZU1vY2tDb250YWN0LFxuICBjcmVhdGVNb2NrU3VwYWJhc2VDbGllbnQsXG4gIGdlbmVyYXRlTW9ja0NvbnRhY3RzLFxufSBmcm9tICcuLi8uLi91dGlscy90ZXN0LWhlbHBlcnMnXG5cbmplc3QubW9jaygnQC9saWIvc3VwYWJhc2Uvc2VydmVyJylcblxuLy8gSGVscGVyIHdyYXBwZXIgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCB0ZXN0IHNpZ25hdHVyZXNcbmZ1bmN0aW9uIGNyZWF0ZUF1dGhlbnRpY2F0ZWRSZXF1ZXN0KG1ldGhvZDogc3RyaW5nLCB1cmw6IHN0cmluZywgdXNlcklkOiBzdHJpbmcsIG9yZ2FuaXphdGlvbklkOiBzdHJpbmcsIGJvZHk/OiBhbnkpIHtcbiAgY29uc3QgZnVsbFVybCA9IHVybC5zdGFydHNXaXRoKCdodHRwJykgPyB1cmwgOiBgaHR0cDovL2xvY2FsaG9zdDozMDAwJHt1cmx9YFxuICByZXR1cm4gY3JlYXRlQXV0aFJlcSh7XG4gICAgbWV0aG9kLFxuICAgIHVybDogZnVsbFVybCxcbiAgICBib2R5LFxuICAgIHVzZXI6IHsgaWQ6IHVzZXJJZCB9LFxuICAgIG9yZ2FuaXphdGlvbklkLFxuICB9KVxufVxuXG5kZXNjcmliZSgnR0VUIC9hcGkvY29udGFjdHMnLCAoKSA9PiB7XG4gIGxldCBtb2NrU3VwYWJhc2U6IGFueVxuICBsZXQgbW9ja1VzZXI6IGFueVxuICBsZXQgbW9ja0NvbnRhY3RzOiBhbnlbXVxuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tTdXBhYmFzZSA9IGNyZWF0ZU1vY2tTdXBhYmFzZUNsaWVudCgpXG4gICAgbW9ja1VzZXIgPSBjcmVhdGVNb2NrVXNlcigpXG4gICAgbW9ja0NvbnRhY3RzID0gZ2VuZXJhdGVNb2NrQ29udGFjdHMoMTUsIHsgb3JnYW5pemF0aW9uX2lkOiBtb2NrVXNlci5vcmdhbml6YXRpb25faWQgfSlcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKVxuICB9KVxuXG4gIGl0KCdzaG91bGQgbGlzdCBjb250YWN0cyB3aXRoIHBhZ2luYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgbW9ja1N1cGFiYXNlLmZyb20gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICBvcmRlcjogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICByYW5nZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja0NvbnRhY3RzLnNsaWNlKDAsIDEwKSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGNvdW50OiAxNSxcbiAgICAgIH0pLFxuICAgIH0pXG5cbiAgICBjb25zdCB1cmwgPSBjcmVhdGVQYWdpbmF0ZWRVcmwoJy9hcGkvY29udGFjdHMnLCB7IHBhZ2U6IDEsIGxpbWl0OiAxMCB9KVxuICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVBdXRoZW50aWNhdGVkUmVxdWVzdCgnR0VUJywgdXJsLCBtb2NrVXNlci5pZCwgbW9ja1VzZXIub3JnYW5pemF0aW9uX2lkKVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzaW11bGF0ZUdldENvbnRhY3RzKHJlcXVlc3QsIG1vY2tTdXBhYmFzZSwgbW9ja1VzZXIpXG4gICAgY29uc3QgeyBzdGF0dXMsIGRhdGEgfSA9IGF3YWl0IHBhcnNlUmVzcG9uc2UocmVzcG9uc2UpXG5cbiAgICBleHBlY3Qoc3RhdHVzKS50b0JlKDIwMClcbiAgICBleHBlY3RQYWdpbmF0ZWRSZXNwb25zZShkYXRhKVxuICAgIGV4cGVjdChkYXRhLmNvbnRhY3RzKS50b0hhdmVMZW5ndGgoMTApXG4gICAgZXhwZWN0KGRhdGEucGFnaW5hdGlvbi50b3RhbCkudG9CZSgxNSlcbiAgICBleHBlY3QoZGF0YS5wYWdpbmF0aW9uLmhhc01vcmUpLnRvQmUodHJ1ZSlcbiAgfSlcblxuICBpdCgnc2hvdWxkIGZpbHRlciBjb250YWN0cyBieSBzZWFyY2ggdGVybScsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBzZWFyY2hSZXN1bHRzID0gbW9ja0NvbnRhY3RzLmZpbHRlcihjID0+IGMubmFtZS5pbmNsdWRlcygnSm9obicpKVxuXG4gICAgbW9ja1N1cGFiYXNlLmZyb20gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICBvcjogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICBvcmRlcjogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICByYW5nZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogc2VhcmNoUmVzdWx0cyxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGNvdW50OiBzZWFyY2hSZXN1bHRzLmxlbmd0aCxcbiAgICAgIH0pLFxuICAgIH0pXG5cbiAgICBjb25zdCB1cmwgPSAnL2FwaS9jb250YWN0cz9zZWFyY2g9Sm9obidcbiAgICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlQXV0aGVudGljYXRlZFJlcXVlc3QoJ0dFVCcsIHVybCwgbW9ja1VzZXIuaWQsIG1vY2tVc2VyLm9yZ2FuaXphdGlvbl9pZClcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2ltdWxhdGVHZXRDb250YWN0cyhyZXF1ZXN0LCBtb2NrU3VwYWJhc2UsIG1vY2tVc2VyKVxuICAgIGNvbnN0IHsgc3RhdHVzLCBkYXRhIH0gPSBhd2FpdCBwYXJzZVJlc3BvbnNlKHJlc3BvbnNlKVxuXG4gICAgZXhwZWN0KHN0YXR1cykudG9CZSgyMDApXG4gICAgZXhwZWN0KGRhdGEuZmlsdGVycy5zZWFyY2gpLnRvQmUoJ0pvaG4nKVxuICB9KVxuXG4gIGl0KCdzaG91bGQgZW5mb3JjZSB0ZW5hbnQgaXNvbGF0aW9uIC0gY2Fubm90IHNlZSBvdGhlciBvcmcgY29udGFjdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qgb3RoZXJPcmdDb250YWN0ID0gY3JlYXRlTW9ja0NvbnRhY3QoeyBvcmdhbml6YXRpb25faWQ6ICdkaWZmZXJlbnQtb3JnLWlkJyB9KVxuXG4gICAgbW9ja1N1cGFiYXNlLmZyb20gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICBlcTogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoZmllbGQ6IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgICAvLyBWZXJpZnkgdGhhdCBvcmdhbml6YXRpb25faWQgZmlsdGVyIGlzIGFwcGxpZWRcbiAgICAgICAgZXhwZWN0KGZpZWxkKS50b0JlKCdvcmdhbml6YXRpb25faWQnKVxuICAgICAgICBleHBlY3QodmFsdWUpLnRvQmUobW9ja1VzZXIub3JnYW5pemF0aW9uX2lkKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9yZGVyOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgICAgICByYW5nZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgIGRhdGE6IG1vY2tDb250YWN0cywgLy8gT25seSBvcmcncyBjb250YWN0c1xuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICBjb3VudDogbW9ja0NvbnRhY3RzLmxlbmd0aCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgfSlcblxuICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVBdXRoZW50aWNhdGVkUmVxdWVzdCgnR0VUJywgJy9hcGkvY29udGFjdHMnLCBtb2NrVXNlci5pZCwgbW9ja1VzZXIub3JnYW5pemF0aW9uX2lkKVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzaW11bGF0ZUdldENvbnRhY3RzKHJlcXVlc3QsIG1vY2tTdXBhYmFzZSwgbW9ja1VzZXIpXG4gICAgY29uc3QgeyBzdGF0dXMsIGRhdGEgfSA9IGF3YWl0IHBhcnNlUmVzcG9uc2UocmVzcG9uc2UpXG5cbiAgICBleHBlY3Qoc3RhdHVzKS50b0JlKDIwMClcbiAgICAvLyBWZXJpZnkgbm8gY29udGFjdHMgZnJvbSBvdGhlciBvcmdhbml6YXRpb25zXG4gICAgZGF0YS5jb250YWN0cy5mb3JFYWNoKChjb250YWN0OiBhbnkpID0+IHtcbiAgICAgIGV4cGVjdChjb250YWN0Lm9yZ2FuaXphdGlvbl9pZCkudG9CZShtb2NrVXNlci5vcmdhbml6YXRpb25faWQpXG4gICAgfSlcbiAgfSlcblxuICBpdCgnc2hvdWxkIGZpbHRlciBieSB0YWdzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHZpcENvbnRhY3RzID0gbW9ja0NvbnRhY3RzLmZpbHRlcihjID0+IGMudGFncz8uaW5jbHVkZXMoJ3ZpcCcpKVxuXG4gICAgbW9ja1N1cGFiYXNlLmZyb20gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICBvdmVybGFwczogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICBvcmRlcjogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICByYW5nZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogdmlwQ29udGFjdHMsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICBjb3VudDogdmlwQ29udGFjdHMubGVuZ3RoLFxuICAgICAgfSksXG4gICAgfSlcblxuICAgIGNvbnN0IHVybCA9ICcvYXBpL2NvbnRhY3RzP3RhZ3M9dmlwJ1xuICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVBdXRoZW50aWNhdGVkUmVxdWVzdCgnR0VUJywgdXJsLCBtb2NrVXNlci5pZCwgbW9ja1VzZXIub3JnYW5pemF0aW9uX2lkKVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzaW11bGF0ZUdldENvbnRhY3RzKHJlcXVlc3QsIG1vY2tTdXBhYmFzZSwgbW9ja1VzZXIpXG4gICAgY29uc3QgeyBzdGF0dXMsIGRhdGEgfSA9IGF3YWl0IHBhcnNlUmVzcG9uc2UocmVzcG9uc2UpXG5cbiAgICBleHBlY3Qoc3RhdHVzKS50b0JlKDIwMClcbiAgICBleHBlY3QoZGF0YS5maWx0ZXJzLnRhZ3MpLnRvQ29udGFpbigndmlwJylcbiAgfSlcbn0pXG5cbmRlc2NyaWJlKCdQT1NUIC9hcGkvY29udGFjdHMnLCAoKSA9PiB7XG4gIGxldCBtb2NrU3VwYWJhc2U6IGFueVxuICBsZXQgbW9ja1VzZXI6IGFueVxuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tTdXBhYmFzZSA9IGNyZWF0ZU1vY2tTdXBhYmFzZUNsaWVudCgpXG4gICAgbW9ja1VzZXIgPSBjcmVhdGVNb2NrVXNlcigpXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKClcbiAgfSlcblxuICBpdCgnc2hvdWxkIGNyZWF0ZSBuZXcgY29udGFjdCB3aXRoIHZhbGlkIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbmV3Q29udGFjdERhdGEgPSB7XG4gICAgICBwaG9uZV9udW1iZXI6ICcrMTU1NTEyMzQ1NjcnLFxuICAgICAgbmFtZTogJ05ldyBDb250YWN0JyxcbiAgICAgIGVtYWlsOiAnbmV3Y29udGFjdEBleGFtcGxlLmNvbScsXG4gICAgICB0YWdzOiBbJ2N1c3RvbWVyJ10sXG4gICAgfVxuXG4gICAgbGV0IGNhbGxDb3VudCA9IDBcbiAgICBtb2NrU3VwYWJhc2UuZnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNhbGxDb3VudCsrXG4gICAgICAgIC8vIEZpcnN0IGNhbGw6IGNoZWNrIGZvciBkdXBsaWNhdGUgKHJldHVybnMgbnVsbCAtIG5vIGR1cGxpY2F0ZSlcbiAgICAgICAgaWYgKGNhbGxDb3VudCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9KVxuICAgICAgICB9XG4gICAgICAgIC8vIFNlY29uZCBjYWxsOiByZXR1cm4gY3JlYXRlZCBjb250YWN0XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIGRhdGE6IHsgLi4ubmV3Q29udGFjdERhdGEsIGlkOiAnbmV3LWNvbnRhY3QtaWQnLCBvcmdhbml6YXRpb25faWQ6IG1vY2tVc2VyLm9yZ2FuaXphdGlvbl9pZCB9LFxuICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICB9KVxuICAgICAgfSksXG4gICAgICBpbnNlcnQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgIH0pXG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlQXV0aGVudGljYXRlZFJlcXVlc3QoJ1BPU1QnLCAnL2FwaS9jb250YWN0cycsIG1vY2tVc2VyLmlkLCBtb2NrVXNlci5vcmdhbml6YXRpb25faWQsIG5ld0NvbnRhY3REYXRhKVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzaW11bGF0ZUNyZWF0ZUNvbnRhY3QocmVxdWVzdCwgbW9ja1N1cGFiYXNlLCBtb2NrVXNlcilcbiAgICBjb25zdCB7IHN0YXR1cywgZGF0YSB9ID0gYXdhaXQgcGFyc2VSZXNwb25zZShyZXNwb25zZSlcblxuICAgIGV4cGVjdChzdGF0dXMpLnRvQmUoMjAxKVxuICAgIGV4cGVjdChkYXRhLnBob25lX251bWJlcikudG9CZShuZXdDb250YWN0RGF0YS5waG9uZV9udW1iZXIpXG4gICAgZXhwZWN0KGRhdGEub3JnYW5pemF0aW9uX2lkKS50b0JlKG1vY2tVc2VyLm9yZ2FuaXphdGlvbl9pZClcbiAgfSlcblxuICBpdCgnc2hvdWxkIHJlamVjdCBkdXBsaWNhdGUgcGhvbmUgbnVtYmVyIGluIHNhbWUgb3JnYW5pemF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGV4aXN0aW5nQ29udGFjdCA9IGNyZWF0ZU1vY2tDb250YWN0KHsgb3JnYW5pemF0aW9uX2lkOiBtb2NrVXNlci5vcmdhbml6YXRpb25faWQgfSlcblxuICAgIG1vY2tTdXBhYmFzZS5mcm9tID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBleGlzdGluZ0NvbnRhY3QsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSksXG4gICAgfSlcblxuICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVBdXRoZW50aWNhdGVkUmVxdWVzdChcbiAgICAgICdQT1NUJyxcbiAgICAgICcvYXBpL2NvbnRhY3RzJyxcbiAgICAgIG1vY2tVc2VyLmlkLFxuICAgICAgbW9ja1VzZXIub3JnYW5pemF0aW9uX2lkLFxuICAgICAgeyBwaG9uZV9udW1iZXI6IGV4aXN0aW5nQ29udGFjdC5waG9uZV9udW1iZXIsIG5hbWU6ICdEdXBsaWNhdGUnIH1cbiAgICApXG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNpbXVsYXRlQ3JlYXRlQ29udGFjdChyZXF1ZXN0LCBtb2NrU3VwYWJhc2UsIG1vY2tVc2VyKVxuICAgIGNvbnN0IHsgc3RhdHVzLCBkYXRhIH0gPSBhd2FpdCBwYXJzZVJlc3BvbnNlKHJlc3BvbnNlKVxuXG4gICAgZXhwZWN0KHN0YXR1cykudG9CZSg0MDkpXG4gICAgZXhwZWN0RXJyb3JSZXNwb25zZShkYXRhLCA0MDksICdhbHJlYWR5IGV4aXN0cycpXG4gIH0pXG5cbiAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBwaG9uZSBudW1iZXIgZm9ybWF0JywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVBdXRoZW50aWNhdGVkUmVxdWVzdChcbiAgICAgICdQT1NUJyxcbiAgICAgICcvYXBpL2NvbnRhY3RzJyxcbiAgICAgIG1vY2tVc2VyLmlkLFxuICAgICAgbW9ja1VzZXIub3JnYW5pemF0aW9uX2lkLFxuICAgICAgeyBwaG9uZV9udW1iZXI6ICdpbnZhbGlkJywgbmFtZTogJ1Rlc3QnIH1cbiAgICApXG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNpbXVsYXRlQ3JlYXRlQ29udGFjdChyZXF1ZXN0LCBtb2NrU3VwYWJhc2UsIG1vY2tVc2VyKVxuICAgIGNvbnN0IHsgc3RhdHVzLCBkYXRhIH0gPSBhd2FpdCBwYXJzZVJlc3BvbnNlKHJlc3BvbnNlKVxuXG4gICAgZXhwZWN0KHN0YXR1cykudG9CZSg0MDApXG4gICAgZXhwZWN0RXJyb3JSZXNwb25zZShkYXRhLCA0MDAsICdJbnZhbGlkIHBob25lIG51bWJlciBmb3JtYXQnKVxuICB9KVxuXG4gIGl0KCdzaG91bGQgcmVxdWlyZSBwaG9uZSBudW1iZXIgZmllbGQnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGNyZWF0ZUF1dGhlbnRpY2F0ZWRSZXF1ZXN0KFxuICAgICAgJ1BPU1QnLFxuICAgICAgJy9hcGkvY29udGFjdHMnLFxuICAgICAgbW9ja1VzZXIuaWQsXG4gICAgICBtb2NrVXNlci5vcmdhbml6YXRpb25faWQsXG4gICAgICB7IG5hbWU6ICdUZXN0IENvbnRhY3QnIH1cbiAgICApXG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNpbXVsYXRlQ3JlYXRlQ29udGFjdChyZXF1ZXN0LCBtb2NrU3VwYWJhc2UsIG1vY2tVc2VyKVxuICAgIGNvbnN0IHsgc3RhdHVzLCBkYXRhIH0gPSBhd2FpdCBwYXJzZVJlc3BvbnNlKHJlc3BvbnNlKVxuXG4gICAgZXhwZWN0KHN0YXR1cykudG9CZSg0MDApXG4gICAgZXhwZWN0RXJyb3JSZXNwb25zZShkYXRhLCA0MDAsICdQaG9uZSBudW1iZXIgaXMgcmVxdWlyZWQnKVxuICB9KVxufSlcblxuZGVzY3JpYmUoJ1BVVCAvYXBpL2NvbnRhY3RzL1tpZF0nLCAoKSA9PiB7XG4gIGxldCBtb2NrU3VwYWJhc2U6IGFueVxuICBsZXQgbW9ja1VzZXI6IGFueVxuICBsZXQgbW9ja0NvbnRhY3Q6IGFueVxuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tTdXBhYmFzZSA9IGNyZWF0ZU1vY2tTdXBhYmFzZUNsaWVudCgpXG4gICAgbW9ja1VzZXIgPSBjcmVhdGVNb2NrVXNlcigpXG4gICAgbW9ja0NvbnRhY3QgPSBjcmVhdGVNb2NrQ29udGFjdCh7IG9yZ2FuaXphdGlvbl9pZDogbW9ja1VzZXIub3JnYW5pemF0aW9uX2lkIH0pXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKClcbiAgfSlcblxuICBpdCgnc2hvdWxkIHVwZGF0ZSBjb250YWN0IHdpdGggdmFsaWQgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB1cGRhdGVEYXRhID0geyBuYW1lOiAnVXBkYXRlZCBOYW1lJywgdGFnczogWyd2aXAnXSB9XG5cbiAgICBsZXQgY2FsbENvdW50ID0gMFxuICAgIG1vY2tTdXBhYmFzZS5mcm9tID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgY2FsbENvdW50KytcbiAgICAgICAgLy8gRmlyc3QgY2FsbDogZmV0Y2ggY29udGFjdCAocmV0dXJucyBleGlzdGluZyBjb250YWN0KVxuICAgICAgICBpZiAoY2FsbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRhdGE6IG1vY2tDb250YWN0LCBlcnJvcjogbnVsbCB9KVxuICAgICAgICB9XG4gICAgICAgIC8vIFNlY29uZCBjYWxsOiByZXR1cm4gdXBkYXRlZCBjb250YWN0XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIGRhdGE6IHsgLi4ubW9ja0NvbnRhY3QsIC4uLnVwZGF0ZURhdGEgfSxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgfSlcbiAgICAgIH0pLFxuICAgICAgdXBkYXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICB9KVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNyZWF0ZUF1dGhlbnRpY2F0ZWRSZXF1ZXN0KFxuICAgICAgJ1BVVCcsXG4gICAgICBgL2FwaS9jb250YWN0cy8ke21vY2tDb250YWN0LmlkfWAsXG4gICAgICBtb2NrVXNlci5pZCxcbiAgICAgIG1vY2tVc2VyLm9yZ2FuaXphdGlvbl9pZCxcbiAgICAgIHVwZGF0ZURhdGFcbiAgICApXG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNpbXVsYXRlVXBkYXRlQ29udGFjdChyZXF1ZXN0LCBtb2NrU3VwYWJhc2UsIG1vY2tVc2VyLCBtb2NrQ29udGFjdC5pZClcbiAgICBjb25zdCB7IHN0YXR1cywgZGF0YSB9ID0gYXdhaXQgcGFyc2VSZXNwb25zZShyZXNwb25zZSlcblxuICAgIGV4cGVjdChzdGF0dXMpLnRvQmUoMjAwKVxuICAgIGV4cGVjdChkYXRhLm5hbWUpLnRvQmUodXBkYXRlRGF0YS5uYW1lKVxuICB9KVxuXG4gIGl0KCdzaG91bGQgcHJldmVudCB1cGRhdGluZyBjb250YWN0IGZyb20gZGlmZmVyZW50IG9yZ2FuaXphdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBvdGhlck9yZ0NvbnRhY3QgPSBjcmVhdGVNb2NrQ29udGFjdCh7IG9yZ2FuaXphdGlvbl9pZDogJ2RpZmZlcmVudC1vcmctaWQnIH0pXG5cbiAgICBtb2NrU3VwYWJhc2UuZnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGF0YTogbnVsbCwgZXJyb3I6IHsgY29kZTogJ1BHUlNUMTE2JyB9IH0pLFxuICAgIH0pXG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlQXV0aGVudGljYXRlZFJlcXVlc3QoXG4gICAgICAnUFVUJyxcbiAgICAgIGAvYXBpL2NvbnRhY3RzLyR7b3RoZXJPcmdDb250YWN0LmlkfWAsXG4gICAgICBtb2NrVXNlci5pZCxcbiAgICAgIG1vY2tVc2VyLm9yZ2FuaXphdGlvbl9pZCxcbiAgICAgIHsgbmFtZTogJ0hhY2tlZCcgfVxuICAgIClcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2ltdWxhdGVVcGRhdGVDb250YWN0KHJlcXVlc3QsIG1vY2tTdXBhYmFzZSwgbW9ja1VzZXIsIG90aGVyT3JnQ29udGFjdC5pZClcbiAgICBjb25zdCB7IHN0YXR1cywgZGF0YSB9ID0gYXdhaXQgcGFyc2VSZXNwb25zZShyZXNwb25zZSlcblxuICAgIGV4cGVjdChzdGF0dXMpLnRvQmUoNDA0KVxuICAgIGV4cGVjdEVycm9yUmVzcG9uc2UoZGF0YSwgNDA0LCAnbm90IGZvdW5kJylcbiAgfSlcbn0pXG5cbmRlc2NyaWJlKCdERUxFVEUgL2FwaS9jb250YWN0cy9baWRdJywgKCkgPT4ge1xuICBsZXQgbW9ja1N1cGFiYXNlOiBhbnlcbiAgbGV0IG1vY2tVc2VyOiBhbnlcbiAgbGV0IG1vY2tDb250YWN0OiBhbnlcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBtb2NrU3VwYWJhc2UgPSBjcmVhdGVNb2NrU3VwYWJhc2VDbGllbnQoKVxuICAgIG1vY2tVc2VyID0gY3JlYXRlTW9ja1VzZXIoKVxuICAgIG1vY2tDb250YWN0ID0gY3JlYXRlTW9ja0NvbnRhY3QoeyBvcmdhbml6YXRpb25faWQ6IG1vY2tVc2VyLm9yZ2FuaXphdGlvbl9pZCB9KVxuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpXG4gIH0pXG5cbiAgaXQoJ3Nob3VsZCBzb2Z0IGRlbGV0ZSBjb250YWN0JywgYXN5bmMgKCkgPT4ge1xuICAgIG1vY2tTdXBhYmFzZS5mcm9tID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBkYXRhOiBtb2NrQ29udGFjdCwgZXJyb3I6IG51bGwgfSksXG4gICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgIH0pXG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlQXV0aGVudGljYXRlZFJlcXVlc3QoXG4gICAgICAnREVMRVRFJyxcbiAgICAgIGAvYXBpL2NvbnRhY3RzLyR7bW9ja0NvbnRhY3QuaWR9YCxcbiAgICAgIG1vY2tVc2VyLmlkLFxuICAgICAgbW9ja1VzZXIub3JnYW5pemF0aW9uX2lkXG4gICAgKVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzaW11bGF0ZURlbGV0ZUNvbnRhY3QocmVxdWVzdCwgbW9ja1N1cGFiYXNlLCBtb2NrVXNlciwgbW9ja0NvbnRhY3QuaWQpXG4gICAgY29uc3QgeyBzdGF0dXMsIGRhdGEgfSA9IGF3YWl0IHBhcnNlUmVzcG9uc2UocmVzcG9uc2UpXG5cbiAgICBleHBlY3Qoc3RhdHVzKS50b0JlKDIwMClcbiAgICBleHBlY3QoZGF0YS5tZXNzYWdlKS50b0NvbnRhaW4oJ2RlbGV0ZWQnKVxuICB9KVxuXG4gIGl0KCdzaG91bGQgcHJldmVudCBkZWxldGluZyBjb250YWN0IGZyb20gZGlmZmVyZW50IG9yZ2FuaXphdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBvdGhlck9yZ0NvbnRhY3QgPSBjcmVhdGVNb2NrQ29udGFjdCh7IG9yZ2FuaXphdGlvbl9pZDogJ2RpZmZlcmVudC1vcmctaWQnIH0pXG5cbiAgICBtb2NrU3VwYWJhc2UuZnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGF0YTogbnVsbCwgZXJyb3I6IHsgY29kZTogJ1BHUlNUMTE2JyB9IH0pLFxuICAgIH0pXG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlQXV0aGVudGljYXRlZFJlcXVlc3QoXG4gICAgICAnREVMRVRFJyxcbiAgICAgIGAvYXBpL2NvbnRhY3RzLyR7b3RoZXJPcmdDb250YWN0LmlkfWAsXG4gICAgICBtb2NrVXNlci5pZCxcbiAgICAgIG1vY2tVc2VyLm9yZ2FuaXphdGlvbl9pZFxuICAgIClcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2ltdWxhdGVEZWxldGVDb250YWN0KHJlcXVlc3QsIG1vY2tTdXBhYmFzZSwgbW9ja1VzZXIsIG90aGVyT3JnQ29udGFjdC5pZClcbiAgICBjb25zdCB7IHN0YXR1cywgZGF0YSB9ID0gYXdhaXQgcGFyc2VSZXNwb25zZShyZXNwb25zZSlcblxuICAgIGV4cGVjdChzdGF0dXMpLnRvQmUoNDA0KVxuICAgIGV4cGVjdEVycm9yUmVzcG9uc2UoZGF0YSwgNDA0LCAnbm90IGZvdW5kJylcbiAgfSlcbn0pXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBIZWxwZXIgRnVuY3Rpb25zIHRvIFNpbXVsYXRlIEFQSSBSb3V0ZSBIYW5kbGVyc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuYXN5bmMgZnVuY3Rpb24gc2ltdWxhdGVHZXRDb250YWN0cyhyZXF1ZXN0OiBOZXh0UmVxdWVzdCwgc3VwYWJhc2U6IGFueSwgdXNlcjogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IHNlYXJjaFBhcmFtcyB9ID0gbmV3IFVSTChyZXF1ZXN0LnVybClcbiAgICBjb25zdCBzZWFyY2ggPSBzZWFyY2hQYXJhbXMuZ2V0KCdzZWFyY2gnKVxuICAgIGNvbnN0IHRhZ3MgPSBzZWFyY2hQYXJhbXMuZ2V0KCd0YWdzJyk/LnNwbGl0KCcsJylcbiAgICBjb25zdCBwYWdlID0gcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldCgncGFnZScpIHx8ICcxJylcbiAgICBjb25zdCBsaW1pdCA9IHBhcnNlSW50KHNlYXJjaFBhcmFtcy5nZXQoJ2xpbWl0JykgfHwgJzIwJylcbiAgICBjb25zdCBvZmZzZXQgPSAocGFnZSAtIDEpICogbGltaXRcblxuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlLmZyb20oJ2NvbnRhY3RzJykuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JyB9KS5lcSgnb3JnYW5pemF0aW9uX2lkJywgdXNlci5vcmdhbml6YXRpb25faWQpXG5cbiAgICBpZiAoc2VhcmNoKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5Lm9yKGBuYW1lLmlsaWtlLiUke3NlYXJjaH0lLHBob25lX251bWJlci5pbGlrZS4lJHtzZWFyY2h9JWApXG4gICAgfVxuXG4gICAgaWYgKHRhZ3MgJiYgdGFncy5sZW5ndGggPiAwKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5Lm92ZXJsYXBzKCd0YWdzJywgdGFncylcbiAgICB9XG5cbiAgICBjb25zdCB7IGRhdGE6IGNvbnRhY3RzLCBlcnJvciwgY291bnQgfSA9IGF3YWl0IHF1ZXJ5Lm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pLnJhbmdlKG9mZnNldCwgb2Zmc2V0ICsgbGltaXQgLSAxKVxuXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgY29udGFjdHMsXG4gICAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgICBwYWdlLFxuICAgICAgICAgIGxpbWl0LFxuICAgICAgICAgIHRvdGFsOiBjb3VudCB8fCAwLFxuICAgICAgICAgIGhhc01vcmU6IG9mZnNldCArIGxpbWl0IDwgKGNvdW50IHx8IDApLFxuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXJzOiB7IHNlYXJjaCwgdGFncyB9LFxuICAgICAgfSksXG4gICAgICB7IHN0YXR1czogMjAwLCBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSB9XG4gICAgKVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeSh7IGVycm9yOiBlcnJvci5tZXNzYWdlIH0pLCB7XG4gICAgICBzdGF0dXM6IDUwMCxcbiAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgIH0pXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gc2ltdWxhdGVDcmVhdGVDb250YWN0KHJlcXVlc3Q6IE5leHRSZXF1ZXN0LCBzdXBhYmFzZTogYW55LCB1c2VyOiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKVxuICAgIGNvbnN0IHsgcGhvbmVfbnVtYmVyLCBuYW1lLCBlbWFpbCwgdGFncyB9ID0gYm9keVxuXG4gICAgaWYgKCFwaG9uZV9udW1iZXIpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoeyBlcnJvcjogJ1Bob25lIG51bWJlciBpcyByZXF1aXJlZCcgfSksIHtcbiAgICAgICAgc3RhdHVzOiA0MDAsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCBwaG9uZVJlZ2V4ID0gL15cXCs/WzEtOV1cXGR7MSwxNH0kL1xuICAgIGlmICghcGhvbmVSZWdleC50ZXN0KHBob25lX251bWJlci5yZXBsYWNlKC9bXFxzLSgpXS9nLCAnJykpKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHsgZXJyb3I6ICdJbnZhbGlkIHBob25lIG51bWJlciBmb3JtYXQnIH0pLCB7XG4gICAgICAgIHN0YXR1czogNDAwLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZXNcbiAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nQ29udGFjdCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjb250YWN0cycpXG4gICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAuZXEoJ29yZ2FuaXphdGlvbl9pZCcsIHVzZXIub3JnYW5pemF0aW9uX2lkKVxuICAgICAgLmVxKCdwaG9uZV9udW1iZXInLCBwaG9uZV9udW1iZXIpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGlmIChleGlzdGluZ0NvbnRhY3QpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoeyBlcnJvcjogJ0NvbnRhY3Qgd2l0aCB0aGlzIHBob25lIG51bWJlciBhbHJlYWR5IGV4aXN0cycgfSksIHtcbiAgICAgICAgc3RhdHVzOiA0MDksXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgY29udGFjdFxuICAgIGNvbnN0IHsgZGF0YTogY29udGFjdCwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY29udGFjdHMnKVxuICAgICAgLmluc2VydCh7XG4gICAgICAgIG9yZ2FuaXphdGlvbl9pZDogdXNlci5vcmdhbml6YXRpb25faWQsXG4gICAgICAgIHBob25lX251bWJlcixcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZW1haWwsXG4gICAgICAgIHRhZ3MsXG4gICAgICB9KVxuICAgICAgLnNlbGVjdCgpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoY29udGFjdCksIHtcbiAgICAgIHN0YXR1czogMjAxLFxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoeyBlcnJvcjogZXJyb3IubWVzc2FnZSB9KSwge1xuICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICB9KVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNpbXVsYXRlVXBkYXRlQ29udGFjdChyZXF1ZXN0OiBOZXh0UmVxdWVzdCwgc3VwYWJhc2U6IGFueSwgdXNlcjogYW55LCBjb250YWN0SWQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlcXVlc3QuanNvbigpXG5cbiAgICAvLyBDaGVjayBjb250YWN0IGV4aXN0cyBhbmQgYmVsb25ncyB0byBvcmdhbml6YXRpb25cbiAgICBjb25zdCB7IGRhdGE6IGNvbnRhY3QsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NvbnRhY3RzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdpZCcsIGNvbnRhY3RJZClcbiAgICAgIC5lcSgnb3JnYW5pemF0aW9uX2lkJywgdXNlci5vcmdhbml6YXRpb25faWQpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGlmIChmZXRjaEVycm9yIHx8ICFjb250YWN0KSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHsgZXJyb3I6ICdDb250YWN0IG5vdCBmb3VuZCcgfSksIHtcbiAgICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgY29udGFjdFxuICAgIGNvbnN0IHsgZGF0YTogdXBkYXRlZCwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY29udGFjdHMnKVxuICAgICAgLnVwZGF0ZShib2R5KVxuICAgICAgLmVxKCdpZCcsIGNvbnRhY3RJZClcbiAgICAgIC5lcSgnb3JnYW5pemF0aW9uX2lkJywgdXNlci5vcmdhbml6YXRpb25faWQpXG4gICAgICAuc2VsZWN0KClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeSh1cGRhdGVkKSwge1xuICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICB9KVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeSh7IGVycm9yOiBlcnJvci5tZXNzYWdlIH0pLCB7XG4gICAgICBzdGF0dXM6IDUwMCxcbiAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgIH0pXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gc2ltdWxhdGVEZWxldGVDb250YWN0KHJlcXVlc3Q6IE5leHRSZXF1ZXN0LCBzdXBhYmFzZTogYW55LCB1c2VyOiBhbnksIGNvbnRhY3RJZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgdHJ5IHtcbiAgICAvLyBDaGVjayBjb250YWN0IGV4aXN0cyBhbmQgYmVsb25ncyB0byBvcmdhbml6YXRpb25cbiAgICBjb25zdCB7IGRhdGE6IGNvbnRhY3QsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NvbnRhY3RzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdpZCcsIGNvbnRhY3RJZClcbiAgICAgIC5lcSgnb3JnYW5pemF0aW9uX2lkJywgdXNlci5vcmdhbml6YXRpb25faWQpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGlmIChmZXRjaEVycm9yIHx8ICFjb250YWN0KSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHsgZXJyb3I6ICdDb250YWN0IG5vdCBmb3VuZCcgfSksIHtcbiAgICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBTb2Z0IGRlbGV0ZVxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY29udGFjdHMnKVxuICAgICAgLnVwZGF0ZSh7IGRlbGV0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9KVxuICAgICAgLmVxKCdpZCcsIGNvbnRhY3RJZClcbiAgICAgIC5lcSgnb3JnYW5pemF0aW9uX2lkJywgdXNlci5vcmdhbml6YXRpb25faWQpXG5cbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHsgbWVzc2FnZTogJ0NvbnRhY3QgZGVsZXRlZCBzdWNjZXNzZnVsbHknIH0pLCB7XG4gICAgICBzdGF0dXM6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHsgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSksIHtcbiAgICAgIHN0YXR1czogNTAwLFxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgfSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiY3JlYXRlQXV0aGVudGljYXRlZFJlcXVlc3QiLCJtZXRob2QiLCJ1cmwiLCJ1c2VySWQiLCJvcmdhbml6YXRpb25JZCIsImJvZHkiLCJmdWxsVXJsIiwic3RhcnRzV2l0aCIsImNyZWF0ZUF1dGhSZXEiLCJ1c2VyIiwiaWQiLCJkZXNjcmliZSIsIm1vY2tTdXBhYmFzZSIsIm1vY2tVc2VyIiwibW9ja0NvbnRhY3RzIiwiYmVmb3JlRWFjaCIsImNyZWF0ZU1vY2tTdXBhYmFzZUNsaWVudCIsImNyZWF0ZU1vY2tVc2VyIiwiZ2VuZXJhdGVNb2NrQ29udGFjdHMiLCJvcmdhbml6YXRpb25faWQiLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJmcm9tIiwiZm4iLCJtb2NrUmV0dXJuVmFsdWUiLCJzZWxlY3QiLCJtb2NrUmV0dXJuVGhpcyIsImVxIiwib3JkZXIiLCJyYW5nZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiZGF0YSIsInNsaWNlIiwiZXJyb3IiLCJjb3VudCIsImNyZWF0ZVBhZ2luYXRlZFVybCIsInBhZ2UiLCJsaW1pdCIsInJlcXVlc3QiLCJyZXNwb25zZSIsInNpbXVsYXRlR2V0Q29udGFjdHMiLCJzdGF0dXMiLCJwYXJzZVJlc3BvbnNlIiwiZXhwZWN0IiwidG9CZSIsImV4cGVjdFBhZ2luYXRlZFJlc3BvbnNlIiwiY29udGFjdHMiLCJ0b0hhdmVMZW5ndGgiLCJwYWdpbmF0aW9uIiwidG90YWwiLCJoYXNNb3JlIiwic2VhcmNoUmVzdWx0cyIsImZpbHRlciIsImMiLCJuYW1lIiwiaW5jbHVkZXMiLCJvciIsImxlbmd0aCIsImZpbHRlcnMiLCJzZWFyY2giLCJvdGhlck9yZ0NvbnRhY3QiLCJjcmVhdGVNb2NrQ29udGFjdCIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImZpZWxkIiwidmFsdWUiLCJmb3JFYWNoIiwiY29udGFjdCIsInZpcENvbnRhY3RzIiwidGFncyIsIm92ZXJsYXBzIiwidG9Db250YWluIiwibmV3Q29udGFjdERhdGEiLCJwaG9uZV9udW1iZXIiLCJlbWFpbCIsImNhbGxDb3VudCIsInNpbmdsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiaW5zZXJ0Iiwic2ltdWxhdGVDcmVhdGVDb250YWN0IiwiZXhpc3RpbmdDb250YWN0IiwiZXhwZWN0RXJyb3JSZXNwb25zZSIsIm1vY2tDb250YWN0IiwidXBkYXRlRGF0YSIsInVwZGF0ZSIsInNpbXVsYXRlVXBkYXRlQ29udGFjdCIsImNvZGUiLCJzaW11bGF0ZURlbGV0ZUNvbnRhY3QiLCJtZXNzYWdlIiwic3VwYWJhc2UiLCJzZWFyY2hQYXJhbXMiLCJVUkwiLCJnZXQiLCJzcGxpdCIsInBhcnNlSW50Iiwib2Zmc2V0IiwicXVlcnkiLCJhc2NlbmRpbmciLCJSZXNwb25zZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJoZWFkZXJzIiwianNvbiIsInBob25lUmVnZXgiLCJ0ZXN0IiwicmVwbGFjZSIsImNvbnRhY3RJZCIsImZldGNoRXJyb3IiLCJ1cGRhdGVkIiwiZGVsZXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7Ozs7eUJBRXNEO2dDQVFoRDs2QkFNQTtBQUVQQSxhQUFJLENBQUNDLElBQUksQ0FBQztBQUVWLGlFQUFpRTtBQUNqRSxTQUFTQywyQkFBMkJDLE1BQWMsRUFBRUMsR0FBVyxFQUFFQyxNQUFjLEVBQUVDLGNBQXNCLEVBQUVDLElBQVU7SUFD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