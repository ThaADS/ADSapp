{"version":3,"sources":["C:\\Ai Projecten\\ADSapp\\tests\\integration\\mfa-flow.test.ts"],"sourcesContent":["/**\n * MFA Integration Flow Tests\n *\n * End-to-end integration tests for complete MFA flows:\n * - Full enrollment process\n * - Login verification with TOTP\n * - Backup code usage\n * - MFA disablement\n * - Error scenarios\n */\n\nimport { describe, it, expect, beforeAll, afterAll, beforeEach } from '@jest/globals';\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;\n\n// Test configuration\nconst TEST_CONFIG = {\n  testUser: {\n    email: 'mfa-test@example.com',\n    password: 'TestPassword123!',\n    fullName: 'MFA Test User',\n  },\n  testOrganization: {\n    name: 'MFA Test Org',\n    subdomain: 'mfa-test',\n  },\n};\n\ndescribe('MFA Integration Flow', () => {\n  let supabase: ReturnType<typeof createClient>;\n  let testUserId: string;\n  let testOrgId: string;\n  let enrollmentData: any;\n\n  beforeAll(async () => {\n    // Initialize Supabase client with service role key\n    supabase = createClient(supabaseUrl, supabaseServiceKey);\n\n    // Create test organization\n    const { data: org, error: orgError } = await supabase\n      .from('organizations')\n      .insert(TEST_CONFIG.testOrganization)\n      .select()\n      .single();\n\n    if (orgError) throw orgError;\n    testOrgId = org.id;\n\n    // Create test user\n    const { data: authData, error: authError } = await supabase.auth.admin.createUser({\n      email: TEST_CONFIG.testUser.email,\n      password: TEST_CONFIG.testUser.password,\n      email_confirm: true,\n    });\n\n    if (authError) throw authError;\n    testUserId = authData.user.id;\n\n    // Create profile for test user\n    await supabase.from('profiles').insert({\n      id: testUserId,\n      organization_id: testOrgId,\n      email: TEST_CONFIG.testUser.email,\n      full_name: TEST_CONFIG.testUser.fullName,\n      role: 'member',\n    });\n  });\n\n  afterAll(async () => {\n    // Cleanup: Delete test data\n    if (testUserId) {\n      await supabase.auth.admin.deleteUser(testUserId);\n      await supabase.from('profiles').delete().eq('id', testUserId);\n    }\n    if (testOrgId) {\n      await supabase.from('organizations').delete().eq('id', testOrgId);\n    }\n  });\n\n  beforeEach(async () => {\n    // Reset MFA status before each test\n    await supabase\n      .from('profiles')\n      .update({\n        mfa_enabled: false,\n        mfa_secret: null,\n        mfa_backup_codes: null,\n        mfa_enrolled_at: null,\n      })\n      .eq('id', testUserId);\n  });\n\n  describe('MFA Enrollment Flow', () => {\n    it('should complete full enrollment process', async () => {\n      // Step 1: Get MFA status (should be disabled)\n      const statusResponse = await fetch('/api/auth/mfa/status', {\n        headers: {\n          'x-user-id': testUserId,\n        },\n      });\n      const statusData = await statusResponse.json();\n\n      expect(statusData.success).toBe(true);\n      expect(statusData.data.enabled).toBe(false);\n\n      // Step 2: Start enrollment\n      const enrollResponse = await fetch('/api/auth/mfa/enroll', {\n        method: 'POST',\n        headers: {\n          'x-user-id': testUserId,\n        },\n      });\n      const enrollData = await enrollResponse.json();\n\n      expect(enrollResponse.status).toBe(200);\n      expect(enrollData.success).toBe(true);\n      expect(enrollData.data).toHaveProperty('qrCode');\n      expect(enrollData.data).toHaveProperty('backupCodes');\n      expect(enrollData.data.backupCodes).toHaveLength(10);\n\n      enrollmentData = enrollData.data;\n\n      // Step 3: Verify database has pending enrollment\n      const { data: profile } = await supabase\n        .from('profiles')\n        .select('mfa_secret, mfa_enabled, mfa_enrolled_at')\n        .eq('id', testUserId)\n        .single();\n\n      expect(profile?.mfa_secret).not.toBeNull();\n      expect(profile?.mfa_enabled).toBe(false); // Not enabled yet\n      expect(profile?.mfa_enrolled_at).toBeNull(); // Not enrolled yet\n\n      // Step 4: Complete verification (in real scenario, would use TOTP from authenticator)\n      // For testing, we'll directly update the database to simulate successful verification\n      const { authenticator } = await import('otplib');\n      const validToken = authenticator.generate(profile!.mfa_secret!);\n\n      const verifyResponse = await fetch('/api/auth/mfa/verify', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'x-user-id': testUserId,\n        },\n        body: JSON.stringify({ token: validToken }),\n      });\n      const verifyData = await verifyResponse.json();\n\n      expect(verifyResponse.status).toBe(200);\n      expect(verifyData.success).toBe(true);\n\n      // Step 5: Verify MFA is now enabled\n      const { data: enabledProfile } = await supabase\n        .from('profiles')\n        .select('mfa_enabled, mfa_enrolled_at')\n        .eq('id', testUserId)\n        .single();\n\n      expect(enabledProfile?.mfa_enabled).toBe(true);\n      expect(enabledProfile?.mfa_enrolled_at).not.toBeNull();\n    });\n\n    it('should prevent re-enrollment when MFA is already enabled', async () => {\n      // Enable MFA first\n      await supabase\n        .from('profiles')\n        .update({\n          mfa_enabled: true,\n          mfa_secret: 'TESTSECRET',\n          mfa_enrolled_at: new Date().toISOString(),\n        })\n        .eq('id', testUserId);\n\n      // Try to enroll again\n      const enrollResponse = await fetch('/api/auth/mfa/enroll', {\n        method: 'POST',\n        headers: {\n          'x-user-id': testUserId,\n        },\n      });\n\n      expect(enrollResponse.status).toBe(400);\n      const data = await enrollResponse.json();\n      expect(data.error).toContain('already enabled');\n    });\n  });\n\n  describe('MFA Login Verification Flow', () => {\n    beforeEach(async () => {\n      // Setup: Enable MFA for test user\n      const { authenticator } = await import('otplib');\n      const secret = authenticator.generateSecret();\n\n      await supabase\n        .from('profiles')\n        .update({\n          mfa_enabled: true,\n          mfa_secret: secret,\n          mfa_enrolled_at: new Date().toISOString(),\n          mfa_backup_codes: ['HASH1', 'HASH2'], // Hashed backup codes\n        })\n        .eq('id', testUserId);\n    });\n\n    it('should verify valid TOTP token during login', async () => {\n      // Get user's MFA secret\n      const { data: profile } = await supabase\n        .from('profiles')\n        .select('mfa_secret')\n        .eq('id', testUserId)\n        .single();\n\n      // Generate valid TOTP token\n      const { authenticator } = await import('otplib');\n      const validToken = authenticator.generate(profile!.mfa_secret!);\n\n      // Verify token\n      const response = await fetch('/api/auth/mfa/login-verify', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          userId: testUserId,\n          token: validToken,\n        }),\n      });\n\n      expect(response.status).toBe(200);\n      const data = await response.json();\n      expect(data.success).toBe(true);\n    });\n\n    it('should reject invalid TOTP token', async () => {\n      const response = await fetch('/api/auth/mfa/login-verify', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          userId: testUserId,\n          token: '000000', // Invalid token\n        }),\n      });\n\n      expect(response.status).toBe(401);\n      const data = await response.json();\n      expect(data.error).toBeDefined();\n    });\n\n    it('should accept valid backup code', async () => {\n      // In real scenario, backup code would be hashed\n      // For testing, we'll use the MFA service directly\n      const { verifyMFAToken } = await import('@/lib/auth/mfa');\n\n      // Note: This is a simplified test. Full implementation would hash and verify properly.\n      const result = await verifyMFAToken(testUserId, 'ABCD-1234');\n\n      // Result depends on whether the backup code hash matches\n      expect(result).toHaveProperty('valid');\n    });\n  });\n\n  describe('MFA Disablement Flow', () => {\n    beforeEach(async () => {\n      // Setup: Enable MFA\n      await supabase\n        .from('profiles')\n        .update({\n          mfa_enabled: true,\n          mfa_secret: 'TESTSECRET',\n          mfa_enrolled_at: new Date().toISOString(),\n        })\n        .eq('id', testUserId);\n    });\n\n    it('should disable MFA with valid password', async () => {\n      const response = await fetch('/api/auth/mfa/disable', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'x-user-id': testUserId,\n        },\n        body: JSON.stringify({\n          password: TEST_CONFIG.testUser.password,\n        }),\n      });\n\n      expect(response.status).toBe(200);\n      const data = await response.json();\n      expect(data.success).toBe(true);\n\n      // Verify MFA is disabled\n      const { data: profile } = await supabase\n        .from('profiles')\n        .select('mfa_enabled, mfa_secret, mfa_backup_codes, mfa_enrolled_at')\n        .eq('id', testUserId)\n        .single();\n\n      expect(profile?.mfa_enabled).toBe(false);\n      expect(profile?.mfa_secret).toBeNull();\n      expect(profile?.mfa_backup_codes).toBeNull();\n      expect(profile?.mfa_enrolled_at).toBeNull();\n    });\n\n    it('should reject disablement with invalid password', async () => {\n      const response = await fetch('/api/auth/mfa/disable', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'x-user-id': testUserId,\n        },\n        body: JSON.stringify({\n          password: 'WrongPassword123!',\n        }),\n      });\n\n      expect(response.status).toBe(401);\n      const data = await response.json();\n      expect(data.error).toContain('password');\n\n      // Verify MFA is still enabled\n      const { data: profile } = await supabase\n        .from('profiles')\n        .select('mfa_enabled')\n        .eq('id', testUserId)\n        .single();\n\n      expect(profile?.mfa_enabled).toBe(true);\n    });\n  });\n\n  describe('Backup Code Regeneration Flow', () => {\n    beforeEach(async () => {\n      // Setup: Enable MFA\n      await supabase\n        .from('profiles')\n        .update({\n          mfa_enabled: true,\n          mfa_secret: 'TESTSECRET',\n          mfa_enrolled_at: new Date().toISOString(),\n          mfa_backup_codes: ['OLDHASH1', 'OLDHASH2'],\n        })\n        .eq('id', testUserId);\n    });\n\n    it('should regenerate backup codes with valid password', async () => {\n      const response = await fetch('/api/auth/mfa/regenerate-codes', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'x-user-id': testUserId,\n        },\n        body: JSON.stringify({\n          password: TEST_CONFIG.testUser.password,\n        }),\n      });\n\n      expect(response.status).toBe(200);\n      const data = await response.json();\n      expect(data.success).toBe(true);\n      expect(data.data.backupCodes).toHaveLength(10);\n      expect(data.data.backupCodes[0]).toMatch(/^[A-Z0-9]{4}-[A-Z0-9]{4}$/);\n\n      // Verify new backup codes are stored (hashed)\n      const { data: profile } = await supabase\n        .from('profiles')\n        .select('mfa_backup_codes')\n        .eq('id', testUserId)\n        .single();\n\n      expect(profile?.mfa_backup_codes).toHaveLength(10);\n      expect(profile?.mfa_backup_codes).not.toContain('OLDHASH1'); // Old codes replaced\n    });\n\n    it('should reject regeneration with invalid password', async () => {\n      const response = await fetch('/api/auth/mfa/regenerate-codes', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'x-user-id': testUserId,\n        },\n        body: JSON.stringify({\n          password: 'WrongPassword123!',\n        }),\n      });\n\n      expect(response.status).toBe(401);\n      const data = await response.json();\n      expect(data.error).toContain('password');\n    });\n  });\n});\n"],"names":["supabaseUrl","process","env","NEXT_PUBLIC_SUPABASE_URL","supabaseServiceKey","SUPABASE_SERVICE_ROLE_KEY","TEST_CONFIG","testUser","email","password","fullName","testOrganization","name","subdomain","describe","supabase","testUserId","testOrgId","enrollmentData","beforeAll","createClient","data","org","error","orgError","from","insert","select","single","id","authData","authError","auth","admin","createUser","email_confirm","user","organization_id","full_name","role","afterAll","deleteUser","delete","eq","beforeEach","update","mfa_enabled","mfa_secret","mfa_backup_codes","mfa_enrolled_at","it","statusResponse","fetch","headers","statusData","json","expect","success","toBe","enabled","enrollResponse","method","enrollData","status","toHaveProperty","backupCodes","toHaveLength","profile","not","toBeNull","authenticator","validToken","generate","verifyResponse","body","JSON","stringify","token","verifyData","enabledProfile","Date","toISOString","toContain","secret","generateSecret","response","userId","toBeDefined","verifyMFAToken","result","toMatch"],"mappings":"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"}