e1545398991a13f999ca5aa143815da2
/**
 * Key Manager Unit Tests
 *
 * Tests key rotation (90-day expiration), key versioning,
 * backward compatibility, and multi-tenant key isolation.
 */ "use strict";
// Mock dependencies
jest.mock('@/lib/supabase/server');
jest.mock('@/lib/security/kms-client');
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _keymanager = require("../../../../src/lib/security/key-manager");
const _crypto = /*#__PURE__*/ _interop_require_wildcard(require("crypto"));
const _server = require("../../../../src/lib/supabase/server");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('KeyManager - Key Rotation & Versioning', ()=>{
    let keyManager;
    let mockKMSClient;
    let mockSupabaseClient;
    beforeEach(()=>{
        // Reset key manager singleton
        (0, _keymanager.resetKeyManager)();
        // Create mock KMS client
        mockKMSClient = {
            generateDataKey: jest.fn(),
            decryptDataKey: jest.fn(),
            encryptDataKey: jest.fn(),
            rotateKey: jest.fn(),
            listKeys: jest.fn(),
            describeKey: jest.fn(),
            scheduleKeyDeletion: jest.fn(),
            cancelKeyDeletion: jest.fn(),
            getKeyRotationStatus: jest.fn(),
            enableKeyRotation: jest.fn(),
            disableKeyRotation: jest.fn(),
            createAlias: jest.fn(),
            updateAlias: jest.fn(),
            deleteAlias: jest.fn(),
            listAliases: jest.fn()
        };
        // Create mock Supabase client
        mockSupabaseClient = {
            from: jest.fn().mockReturnThis(),
            select: jest.fn().mockReturnThis(),
            insert: jest.fn().mockReturnThis(),
            update: jest.fn().mockReturnThis(),
            delete: jest.fn().mockReturnThis(),
            eq: jest.fn().mockReturnThis(),
            lte: jest.fn().mockReturnThis(),
            order: jest.fn().mockReturnThis(),
            limit: jest.fn().mockReturnThis(),
            single: jest.fn()
        };
        // Mock createClient to return our mock
        createClient = jest.fn().mockResolvedValue(mockSupabaseClient);
        // Create key manager with mocked KMS client
        keyManager = new _keymanager.KeyManager(mockKMSClient);
    });
    afterEach(()=>{
        jest.clearAllMocks();
        (0, _keymanager.resetKeyManager)();
    });
    describe('Key Rotation (90-day Expiration)', ()=>{
        it('should rotate key after 90-day expiration', async ()=>{
            // Arrange
            const tenantId = 'tenant-abc123';
            const currentVersion = 1;
            const now = new Date();
            const expiredDate = new Date(now.getTime() - 91 * 24 * 60 * 60 * 1000); // 91 days ago
            const expiredKey = {
                id: 'key-old-123',
                tenant_id: tenantId,
                kms_key_id: 'arn:aws:kms:old',
                encrypted_data_key: 'encrypted-old-key-base64',
                version: currentVersion,
                is_active: true,
                created_at: expiredDate.toISOString(),
                expires_at: expiredDate.toISOString(),
                rotated_at: null
            };
            const newKeyPlaintext = _crypto.randomBytes(32);
            const newKeyEncrypted = 'encrypted-new-key-base64';
            // Mock database responses
            mockSupabaseClient.single.mockResolvedValueOnce({
                data: expiredKey,
                error: null
            }) // Get active key
            .mockResolvedValueOnce({
                data: null,
                error: null
            }); // Get next version
            mockSupabaseClient.update.mockResolvedValue({
                data: null,
                error: null
            });
            mockSupabaseClient.insert.mockResolvedValue({
                data: null,
                error: null
            });
            // Mock KMS responses
            mockKMSClient.generateDataKey.mockResolvedValue({
                keyId: 'arn:aws:kms:new',
                plaintext: newKeyPlaintext,
                ciphertext: newKeyEncrypted
            });
            // Act
            const newKey = await keyManager.rotateKey(tenantId);
            // Assert
            expect(newKey).toBeDefined();
            expect(newKey).toBeInstanceOf(Buffer);
            expect(mockSupabaseClient.update).toHaveBeenCalled();
            expect(mockKMSClient.generateDataKey).toHaveBeenCalledWith(tenantId);
        });
        it('should detect keys approaching expiration', async ()=>{
            // Arrange
            const tenantId = 'tenant-warning';
            const now = new Date();
            const nearExpirationDate = new Date(now.getTime() + 5 * 24 * 60 * 60 * 1000); // 5 days from now
            const key = {
                id: 'key-warning-123',
                tenant_id: tenantId,
                kms_key_id: 'arn:aws:kms:key',
                encrypted_data_key: 'encrypted-key-base64',
                version: 1,
                is_active: true,
                created_at: now.toISOString(),
                expires_at: nearExpirationDate.toISOString(),
                rotated_at: null
            };
            const keyPlaintext = _crypto.randomBytes(32);
            mockSupabaseClient.single.mockResolvedValue({
                data: key,
                error: null
            });
            mockKMSClient.decryptDataKey.mockResolvedValue({
                keyId: key.kms_key_id,
                plaintext: keyPlaintext
            });
            // Spy on console to verify warning
            const consoleInfoSpy = jest.spyOn(console, 'info').mockImplementation();
            // Act
            await keyManager.getEncryptionKey(tenantId);
            // Assert
            expect(consoleInfoSpy).toHaveBeenCalledWith(expect.stringContaining('approaching expiration'));
            consoleInfoSpy.mockRestore();
        });
        it('should schedule automatic rotation for expired keys', async ()=>{
            // Arrange
            const now = new Date();
            const expiredDate = new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000); // 1 day ago
            const warningDate = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000); // 7 days from now
            const keysNeedingRotation = [
                {
                    tenant_id: 'tenant-1'
                },
                {
                    tenant_id: 'tenant-2'
                },
                {
                    tenant_id: 'tenant-3'
                }
            ];
            // Mock database to return keys needing rotation
            mockSupabaseClient.single.mockResolvedValue({
                data: null,
                error: null
            });
            mockSupabaseClient.select.mockImplementation(()=>{
                return Promise.resolve({
                    data: keysNeedingRotation,
                    error: null
                });
            });
            // Mock KMS for key generation
            const newKeyPlaintext = _crypto.randomBytes(32);
            mockKMSClient.generateDataKey.mockResolvedValue({
                keyId: 'arn:aws:kms:new',
                plaintext: newKeyPlaintext,
                ciphertext: 'encrypted-new-key'
            });
            mockSupabaseClient.insert.mockResolvedValue({
                data: null,
                error: null
            });
            mockSupabaseClient.update.mockResolvedValue({
                data: null,
                error: null
            });
            // Spy on console
            const consoleInfoSpy = jest.spyOn(console, 'info').mockImplementation();
            // Act
            await keyManager.scheduleRotation();
            // Assert
            expect(consoleInfoSpy).toHaveBeenCalledWith(expect.stringContaining('Scheduling rotation for'));
            expect(mockKMSClient.generateDataKey).toHaveBeenCalledTimes(3);
            consoleInfoSpy.mockRestore();
        });
    });
    describe('Key Versioning & Backward Compatibility', ()=>{
        it('should maintain key version history', async ()=>{
            // Arrange
            const tenantId = 'tenant-versioning';
            const keyHistory = [
                {
                    id: 'key-v3',
                    tenant_id: tenantId,
                    kms_key_id: 'arn:aws:kms:v3',
                    encrypted_data_key: 'encrypted-v3',
                    version: 3,
                    is_active: true,
                    created_at: new Date().toISOString(),
                    expires_at: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString(),
                    rotated_at: null
                },
                {
                    id: 'key-v2',
                    tenant_id: tenantId,
                    kms_key_id: 'arn:aws:kms:v2',
                    encrypted_data_key: 'encrypted-v2',
                    version: 2,
                    is_active: false,
                    created_at: new Date(Date.now() - 100 * 24 * 60 * 60 * 1000).toISOString(),
                    expires_at: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString(),
                    rotated_at: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()
                },
                {
                    id: 'key-v1',
                    tenant_id: tenantId,
                    kms_key_id: 'arn:aws:kms:v1',
                    encrypted_data_key: 'encrypted-v1',
                    version: 1,
                    is_active: false,
                    created_at: new Date(Date.now() - 200 * 24 * 60 * 60 * 1000).toISOString(),
                    expires_at: new Date(Date.now() - 110 * 24 * 60 * 60 * 1000).toISOString(),
                    rotated_at: new Date(Date.now() - 105 * 24 * 60 * 60 * 1000).toISOString()
                }
            ];
            mockSupabaseClient.select.mockImplementation(()=>{
                return Promise.resolve({
                    data: keyHistory,
                    error: null
                });
            });
            // Act
            const history = await keyManager.getKeyHistory(tenantId);
            // Assert
            expect(history).toHaveLength(3);
            expect(history[0].version).toBe(3);
            expect(history[0].isActive).toBe(true);
            expect(history[1].version).toBe(2);
            expect(history[1].isActive).toBe(false);
            expect(history[1].rotatedAt).toBeDefined();
            expect(history[2].version).toBe(1);
            expect(history[2].isActive).toBe(false);
        });
        it('should increment version number correctly', async ()=>{
            // Arrange
            const tenantId = 'tenant-increment';
            const currentVersion = 5;
            // Mock existing key with version 5
            mockSupabaseClient.single.mockResolvedValueOnce({
                data: {
                    version: currentVersion,
                    tenant_id: tenantId
                },
                error: null
            }).mockResolvedValueOnce({
                data: null,
                error: null
            }); // For next version query
            mockSupabaseClient.limit.mockReturnThis();
            const newKeyPlaintext = _crypto.randomBytes(32);
            mockKMSClient.generateDataKey.mockResolvedValue({
                keyId: 'arn:aws:kms:new',
                plaintext: newKeyPlaintext,
                ciphertext: 'encrypted-new-key'
            });
            mockSupabaseClient.insert.mockImplementation((data)=>{
                // Verify version is incremented
                expect(data.version).toBe(currentVersion + 1);
                return Promise.resolve({
                    data: null,
                    error: null
                });
            });
            // Act
            await keyManager.createKey(tenantId);
            // Assert
            expect(mockSupabaseClient.insert).toHaveBeenCalled();
        });
    });
    describe('Multi-Tenant Key Isolation', ()=>{
        it('should maintain separate keys for different tenants', async ()=>{
            // Arrange
            const tenant1 = 'tenant-alice';
            const tenant2 = 'tenant-bob';
            const key1Plaintext = _crypto.randomBytes(32);
            const key2Plaintext = _crypto.randomBytes(32);
            // Mock database responses for different tenants
            mockSupabaseClient.single.mockResolvedValueOnce({
                data: {
                    id: 'key-alice',
                    tenant_id: tenant1,
                    kms_key_id: 'arn:aws:kms:alice',
                    encrypted_data_key: 'encrypted-alice-key',
                    version: 1,
                    is_active: true,
                    created_at: new Date().toISOString(),
                    expires_at: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString()
                },
                error: null
            }).mockResolvedValueOnce({
                data: {
                    id: 'key-bob',
                    tenant_id: tenant2,
                    kms_key_id: 'arn:aws:kms:bob',
                    encrypted_data_key: 'encrypted-bob-key',
                    version: 1,
                    is_active: true,
                    created_at: new Date().toISOString(),
                    expires_at: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString()
                },
                error: null
            });
            // Mock KMS decryption for different tenants
            mockKMSClient.decryptDataKey.mockResolvedValueOnce({
                keyId: 'arn:aws:kms:alice',
                plaintext: key1Plaintext
            }).mockResolvedValueOnce({
                keyId: 'arn:aws:kms:bob',
                plaintext: key2Plaintext
            });
            // Act
            const aliceKey = await keyManager.getEncryptionKey(tenant1);
            const bobKey = await keyManager.getEncryptionKey(tenant2);
            // Assert
            expect(aliceKey).not.toEqual(bobKey);
            expect(aliceKey).toEqual(key1Plaintext);
            expect(bobKey).toEqual(key2Plaintext);
            expect(mockKMSClient.decryptDataKey).toHaveBeenCalledWith('encrypted-alice-key', tenant1);
            expect(mockKMSClient.decryptDataKey).toHaveBeenCalledWith('encrypted-bob-key', tenant2);
        });
        it('should get key statistics per tenant', async ()=>{
            // Arrange
            const tenantId = 'tenant-stats';
            const now = new Date();
            const tenantKeys = [
                {
                    is_active: true,
                    created_at: new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000).toISOString(),
                    expires_at: new Date(now.getTime() + 60 * 24 * 60 * 60 * 1000).toISOString()
                },
                {
                    is_active: false,
                    created_at: new Date(now.getTime() - 120 * 24 * 60 * 60 * 1000).toISOString(),
                    expires_at: new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000).toISOString()
                }
            ];
            mockSupabaseClient.select.mockImplementation(()=>{
                return Promise.resolve({
                    data: tenantKeys,
                    error: null
                });
            });
            // Act
            const stats = await keyManager.getKeyStats(tenantId);
            // Assert
            expect(stats).toBeDefined();
            expect(stats.totalKeys).toBe(2);
            expect(stats.activeKeys).toBe(1);
            expect(stats.expiredKeys).toBe(1);
            expect(stats.averageKeyAge).toBeGreaterThan(0);
            expect(mockSupabaseClient.eq).toHaveBeenCalledWith('tenant_id', tenantId);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxBaSBQcm9qZWN0ZW5cXEFEU2FwcFxcdGVzdHNcXHVuaXRcXGxpYlxcc2VjdXJpdHlcXGtleS1tYW5hZ2VyLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBLZXkgTWFuYWdlciBVbml0IFRlc3RzXG4gKlxuICogVGVzdHMga2V5IHJvdGF0aW9uICg5MC1kYXkgZXhwaXJhdGlvbiksIGtleSB2ZXJzaW9uaW5nLFxuICogYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgYW5kIG11bHRpLXRlbmFudCBrZXkgaXNvbGF0aW9uLlxuICovXG5cbmltcG9ydCB7XG4gIEtleU1hbmFnZXIsXG4gIGdldEtleU1hbmFnZXIsXG4gIHJlc2V0S2V5TWFuYWdlcixcbiAgX190ZXN0aW5nX18sXG59IGZyb20gJ0AvbGliL3NlY3VyaXR5L2tleS1tYW5hZ2VyJztcbmltcG9ydCB7IEtNU0NsaWVudCB9IGZyb20gJ0AvbGliL3NlY3VyaXR5L2ttcy1jbGllbnQnO1xuaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbi8vIE1vY2sgZGVwZW5kZW5jaWVzXG5qZXN0Lm1vY2soJ0AvbGliL3N1cGFiYXNlL3NlcnZlcicpO1xuamVzdC5tb2NrKCdAL2xpYi9zZWN1cml0eS9rbXMtY2xpZW50Jyk7XG5cbmltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0AvbGliL3N1cGFiYXNlL3NlcnZlcic7XG5cbmRlc2NyaWJlKCdLZXlNYW5hZ2VyIC0gS2V5IFJvdGF0aW9uICYgVmVyc2lvbmluZycsICgpID0+IHtcbiAgbGV0IGtleU1hbmFnZXI6IEtleU1hbmFnZXI7XG4gIGxldCBtb2NrS01TQ2xpZW50OiBqZXN0Lk1vY2tlZDxLTVNDbGllbnQ+O1xuICBsZXQgbW9ja1N1cGFiYXNlQ2xpZW50OiBhbnk7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgLy8gUmVzZXQga2V5IG1hbmFnZXIgc2luZ2xldG9uXG4gICAgcmVzZXRLZXlNYW5hZ2VyKCk7XG5cbiAgICAvLyBDcmVhdGUgbW9jayBLTVMgY2xpZW50XG4gICAgbW9ja0tNU0NsaWVudCA9IHtcbiAgICAgIGdlbmVyYXRlRGF0YUtleTogamVzdC5mbigpLFxuICAgICAgZGVjcnlwdERhdGFLZXk6IGplc3QuZm4oKSxcbiAgICAgIGVuY3J5cHREYXRhS2V5OiBqZXN0LmZuKCksXG4gICAgICByb3RhdGVLZXk6IGplc3QuZm4oKSxcbiAgICAgIGxpc3RLZXlzOiBqZXN0LmZuKCksXG4gICAgICBkZXNjcmliZUtleTogamVzdC5mbigpLFxuICAgICAgc2NoZWR1bGVLZXlEZWxldGlvbjogamVzdC5mbigpLFxuICAgICAgY2FuY2VsS2V5RGVsZXRpb246IGplc3QuZm4oKSxcbiAgICAgIGdldEtleVJvdGF0aW9uU3RhdHVzOiBqZXN0LmZuKCksXG4gICAgICBlbmFibGVLZXlSb3RhdGlvbjogamVzdC5mbigpLFxuICAgICAgZGlzYWJsZUtleVJvdGF0aW9uOiBqZXN0LmZuKCksXG4gICAgICBjcmVhdGVBbGlhczogamVzdC5mbigpLFxuICAgICAgdXBkYXRlQWxpYXM6IGplc3QuZm4oKSxcbiAgICAgIGRlbGV0ZUFsaWFzOiBqZXN0LmZuKCksXG4gICAgICBsaXN0QWxpYXNlczogamVzdC5mbigpLFxuICAgIH0gYXMgYW55O1xuXG4gICAgLy8gQ3JlYXRlIG1vY2sgU3VwYWJhc2UgY2xpZW50XG4gICAgbW9ja1N1cGFiYXNlQ2xpZW50ID0ge1xuICAgICAgZnJvbTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgICAgaW5zZXJ0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICBkZWxldGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgICAgbHRlOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgIG9yZGVyOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgIGxpbWl0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgIHNpbmdsZTogamVzdC5mbigpLFxuICAgIH07XG5cbiAgICAvLyBNb2NrIGNyZWF0ZUNsaWVudCB0byByZXR1cm4gb3VyIG1vY2tcbiAgICAoY3JlYXRlQ2xpZW50IGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGNyZWF0ZUNsaWVudD4pID0gamVzdFxuICAgICAgLmZuKClcbiAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VwYWJhc2VDbGllbnQpO1xuXG4gICAgLy8gQ3JlYXRlIGtleSBtYW5hZ2VyIHdpdGggbW9ja2VkIEtNUyBjbGllbnRcbiAgICBrZXlNYW5hZ2VyID0gbmV3IEtleU1hbmFnZXIobW9ja0tNU0NsaWVudCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgcmVzZXRLZXlNYW5hZ2VyKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdLZXkgUm90YXRpb24gKDkwLWRheSBFeHBpcmF0aW9uKScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJvdGF0ZSBrZXkgYWZ0ZXIgOTAtZGF5IGV4cGlyYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0ZW5hbnRJZCA9ICd0ZW5hbnQtYWJjMTIzJztcbiAgICAgIGNvbnN0IGN1cnJlbnRWZXJzaW9uID0gMTtcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBleHBpcmVkRGF0ZSA9IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgLSA5MSAqIDI0ICogNjAgKiA2MCAqIDEwMDApOyAvLyA5MSBkYXlzIGFnb1xuXG4gICAgICBjb25zdCBleHBpcmVkS2V5ID0ge1xuICAgICAgICBpZDogJ2tleS1vbGQtMTIzJyxcbiAgICAgICAgdGVuYW50X2lkOiB0ZW5hbnRJZCxcbiAgICAgICAga21zX2tleV9pZDogJ2Fybjphd3M6a21zOm9sZCcsXG4gICAgICAgIGVuY3J5cHRlZF9kYXRhX2tleTogJ2VuY3J5cHRlZC1vbGQta2V5LWJhc2U2NCcsXG4gICAgICAgIHZlcnNpb246IGN1cnJlbnRWZXJzaW9uLFxuICAgICAgICBpc19hY3RpdmU6IHRydWUsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IGV4cGlyZWREYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZWREYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHJvdGF0ZWRfYXQ6IG51bGwsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBuZXdLZXlQbGFpbnRleHQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMzIpO1xuICAgICAgY29uc3QgbmV3S2V5RW5jcnlwdGVkID0gJ2VuY3J5cHRlZC1uZXcta2V5LWJhc2U2NCc7XG5cbiAgICAgIC8vIE1vY2sgZGF0YWJhc2UgcmVzcG9uc2VzXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuc2luZ2xlXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBkYXRhOiBleHBpcmVkS2V5LCBlcnJvcjogbnVsbCB9KSAvLyBHZXQgYWN0aXZlIGtleVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfSk7IC8vIEdldCBuZXh0IHZlcnNpb25cblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LnVwZGF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH0pO1xuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50Lmluc2VydC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH0pO1xuXG4gICAgICAvLyBNb2NrIEtNUyByZXNwb25zZXNcbiAgICAgIG1vY2tLTVNDbGllbnQuZ2VuZXJhdGVEYXRhS2V5Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAga2V5SWQ6ICdhcm46YXdzOmttczpuZXcnLFxuICAgICAgICBwbGFpbnRleHQ6IG5ld0tleVBsYWludGV4dCxcbiAgICAgICAgY2lwaGVydGV4dDogbmV3S2V5RW5jcnlwdGVkLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgbmV3S2V5ID0gYXdhaXQga2V5TWFuYWdlci5yb3RhdGVLZXkodGVuYW50SWQpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChuZXdLZXkpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QobmV3S2V5KS50b0JlSW5zdGFuY2VPZihCdWZmZXIpO1xuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZUNsaWVudC51cGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrS01TQ2xpZW50LmdlbmVyYXRlRGF0YUtleSkudG9IYXZlQmVlbkNhbGxlZFdpdGgodGVuYW50SWQpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkZXRlY3Qga2V5cyBhcHByb2FjaGluZyBleHBpcmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdGVuYW50SWQgPSAndGVuYW50LXdhcm5pbmcnO1xuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IG5lYXJFeHBpcmF0aW9uRGF0ZSA9IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgKyA1ICogMjQgKiA2MCAqIDYwICogMTAwMCk7IC8vIDUgZGF5cyBmcm9tIG5vd1xuXG4gICAgICBjb25zdCBrZXkgPSB7XG4gICAgICAgIGlkOiAna2V5LXdhcm5pbmctMTIzJyxcbiAgICAgICAgdGVuYW50X2lkOiB0ZW5hbnRJZCxcbiAgICAgICAga21zX2tleV9pZDogJ2Fybjphd3M6a21zOmtleScsXG4gICAgICAgIGVuY3J5cHRlZF9kYXRhX2tleTogJ2VuY3J5cHRlZC1rZXktYmFzZTY0JyxcbiAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICBjcmVhdGVkX2F0OiBub3cudG9JU09TdHJpbmcoKSxcbiAgICAgICAgZXhwaXJlc19hdDogbmVhckV4cGlyYXRpb25EYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHJvdGF0ZWRfYXQ6IG51bGwsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBrZXlQbGFpbnRleHQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMzIpO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGF0YToga2V5LCBlcnJvcjogbnVsbCB9KTtcbiAgICAgIG1vY2tLTVNDbGllbnQuZGVjcnlwdERhdGFLZXkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBrZXlJZDoga2V5Lmttc19rZXlfaWQsXG4gICAgICAgIHBsYWludGV4dDoga2V5UGxhaW50ZXh0LFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFNweSBvbiBjb25zb2xlIHRvIHZlcmlmeSB3YXJuaW5nXG4gICAgICBjb25zdCBjb25zb2xlSW5mb1NweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ2luZm8nKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBhd2FpdCBrZXlNYW5hZ2VyLmdldEVuY3J5cHRpb25LZXkodGVuYW50SWQpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChjb25zb2xlSW5mb1NweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdhcHByb2FjaGluZyBleHBpcmF0aW9uJylcbiAgICAgICk7XG5cbiAgICAgIGNvbnNvbGVJbmZvU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNjaGVkdWxlIGF1dG9tYXRpYyByb3RhdGlvbiBmb3IgZXhwaXJlZCBrZXlzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IGV4cGlyZWREYXRlID0gbmV3IERhdGUobm93LmdldFRpbWUoKSAtIDEgKiAyNCAqIDYwICogNjAgKiAxMDAwKTsgLy8gMSBkYXkgYWdvXG4gICAgICBjb25zdCB3YXJuaW5nRGF0ZSA9IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgKyA3ICogMjQgKiA2MCAqIDYwICogMTAwMCk7IC8vIDcgZGF5cyBmcm9tIG5vd1xuXG4gICAgICBjb25zdCBrZXlzTmVlZGluZ1JvdGF0aW9uID0gW1xuICAgICAgICB7IHRlbmFudF9pZDogJ3RlbmFudC0xJyB9LFxuICAgICAgICB7IHRlbmFudF9pZDogJ3RlbmFudC0yJyB9LFxuICAgICAgICB7IHRlbmFudF9pZDogJ3RlbmFudC0zJyB9LFxuICAgICAgXTtcblxuICAgICAgLy8gTW9jayBkYXRhYmFzZSB0byByZXR1cm4ga2V5cyBuZWVkaW5nIHJvdGF0aW9uXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfSk7XG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuc2VsZWN0Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkYXRhOiBrZXlzTmVlZGluZ1JvdGF0aW9uLCBlcnJvcjogbnVsbCB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIEtNUyBmb3Iga2V5IGdlbmVyYXRpb25cbiAgICAgIGNvbnN0IG5ld0tleVBsYWludGV4dCA9IGNyeXB0by5yYW5kb21CeXRlcygzMik7XG4gICAgICBtb2NrS01TQ2xpZW50LmdlbmVyYXRlRGF0YUtleS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGtleUlkOiAnYXJuOmF3czprbXM6bmV3JyxcbiAgICAgICAgcGxhaW50ZXh0OiBuZXdLZXlQbGFpbnRleHQsXG4gICAgICAgIGNpcGhlcnRleHQ6ICdlbmNyeXB0ZWQtbmV3LWtleScsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50Lmluc2VydC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH0pO1xuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LnVwZGF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH0pO1xuXG4gICAgICAvLyBTcHkgb24gY29uc29sZVxuICAgICAgY29uc3QgY29uc29sZUluZm9TcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdpbmZvJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgYXdhaXQga2V5TWFuYWdlci5zY2hlZHVsZVJvdGF0aW9uKCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGNvbnNvbGVJbmZvU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ1NjaGVkdWxpbmcgcm90YXRpb24gZm9yJylcbiAgICAgICk7XG4gICAgICBleHBlY3QobW9ja0tNU0NsaWVudC5nZW5lcmF0ZURhdGFLZXkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygzKTtcblxuICAgICAgY29uc29sZUluZm9TcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0tleSBWZXJzaW9uaW5nICYgQmFja3dhcmQgQ29tcGF0aWJpbGl0eScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIG1haW50YWluIGtleSB2ZXJzaW9uIGhpc3RvcnknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0ZW5hbnRJZCA9ICd0ZW5hbnQtdmVyc2lvbmluZyc7XG4gICAgICBjb25zdCBrZXlIaXN0b3J5ID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdrZXktdjMnLFxuICAgICAgICAgIHRlbmFudF9pZDogdGVuYW50SWQsXG4gICAgICAgICAga21zX2tleV9pZDogJ2Fybjphd3M6a21zOnYzJyxcbiAgICAgICAgICBlbmNyeXB0ZWRfZGF0YV9rZXk6ICdlbmNyeXB0ZWQtdjMnLFxuICAgICAgICAgIHZlcnNpb246IDMsXG4gICAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBleHBpcmVzX2F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgOTAgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHJvdGF0ZWRfYXQ6IG51bGwsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2tleS12MicsXG4gICAgICAgICAgdGVuYW50X2lkOiB0ZW5hbnRJZCxcbiAgICAgICAgICBrbXNfa2V5X2lkOiAnYXJuOmF3czprbXM6djInLFxuICAgICAgICAgIGVuY3J5cHRlZF9kYXRhX2tleTogJ2VuY3J5cHRlZC12MicsXG4gICAgICAgICAgdmVyc2lvbjogMixcbiAgICAgICAgICBpc19hY3RpdmU6IGZhbHNlLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSAxMDAgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIGV4cGlyZXNfYXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSAxMCAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgcm90YXRlZF9hdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDUgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdrZXktdjEnLFxuICAgICAgICAgIHRlbmFudF9pZDogdGVuYW50SWQsXG4gICAgICAgICAga21zX2tleV9pZDogJ2Fybjphd3M6a21zOnYxJyxcbiAgICAgICAgICBlbmNyeXB0ZWRfZGF0YV9rZXk6ICdlbmNyeXB0ZWQtdjEnLFxuICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgaXNfYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMjAwICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBleHBpcmVzX2F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMTEwICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICByb3RhdGVkX2F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMTA1ICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5zZWxlY3QubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRhdGE6IGtleUhpc3RvcnksIGVycm9yOiBudWxsIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgaGlzdG9yeSA9IGF3YWl0IGtleU1hbmFnZXIuZ2V0S2V5SGlzdG9yeSh0ZW5hbnRJZCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGhpc3RvcnkpLnRvSGF2ZUxlbmd0aCgzKTtcbiAgICAgIGV4cGVjdChoaXN0b3J5WzBdLnZlcnNpb24pLnRvQmUoMyk7XG4gICAgICBleHBlY3QoaGlzdG9yeVswXS5pc0FjdGl2ZSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChoaXN0b3J5WzFdLnZlcnNpb24pLnRvQmUoMik7XG4gICAgICBleHBlY3QoaGlzdG9yeVsxXS5pc0FjdGl2ZSkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoaGlzdG9yeVsxXS5yb3RhdGVkQXQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoaGlzdG9yeVsyXS52ZXJzaW9uKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KGhpc3RvcnlbMl0uaXNBY3RpdmUpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBpbmNyZW1lbnQgdmVyc2lvbiBudW1iZXIgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdGVuYW50SWQgPSAndGVuYW50LWluY3JlbWVudCc7XG4gICAgICBjb25zdCBjdXJyZW50VmVyc2lvbiA9IDU7XG5cbiAgICAgIC8vIE1vY2sgZXhpc3Rpbmcga2V5IHdpdGggdmVyc2lvbiA1XG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuc2luZ2xlXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHZlcnNpb246IGN1cnJlbnRWZXJzaW9uLFxuICAgICAgICAgICAgdGVuYW50X2lkOiB0ZW5hbnRJZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICB9KVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfSk7IC8vIEZvciBuZXh0IHZlcnNpb24gcXVlcnlcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmxpbWl0Lm1vY2tSZXR1cm5UaGlzKCk7XG5cbiAgICAgIGNvbnN0IG5ld0tleVBsYWludGV4dCA9IGNyeXB0by5yYW5kb21CeXRlcygzMik7XG4gICAgICBtb2NrS01TQ2xpZW50LmdlbmVyYXRlRGF0YUtleS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGtleUlkOiAnYXJuOmF3czprbXM6bmV3JyxcbiAgICAgICAgcGxhaW50ZXh0OiBuZXdLZXlQbGFpbnRleHQsXG4gICAgICAgIGNpcGhlcnRleHQ6ICdlbmNyeXB0ZWQtbmV3LWtleScsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50Lmluc2VydC5tb2NrSW1wbGVtZW50YXRpb24oKGRhdGEpID0+IHtcbiAgICAgICAgLy8gVmVyaWZ5IHZlcnNpb24gaXMgaW5jcmVtZW50ZWRcbiAgICAgICAgZXhwZWN0KGRhdGEudmVyc2lvbikudG9CZShjdXJyZW50VmVyc2lvbiArIDEpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBhd2FpdCBrZXlNYW5hZ2VyLmNyZWF0ZUtleSh0ZW5hbnRJZCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZUNsaWVudC5pbnNlcnQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ011bHRpLVRlbmFudCBLZXkgSXNvbGF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gc2VwYXJhdGUga2V5cyBmb3IgZGlmZmVyZW50IHRlbmFudHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0ZW5hbnQxID0gJ3RlbmFudC1hbGljZSc7XG4gICAgICBjb25zdCB0ZW5hbnQyID0gJ3RlbmFudC1ib2InO1xuXG4gICAgICBjb25zdCBrZXkxUGxhaW50ZXh0ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDMyKTtcbiAgICAgIGNvbnN0IGtleTJQbGFpbnRleHQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMzIpO1xuXG4gICAgICAvLyBNb2NrIGRhdGFiYXNlIHJlc3BvbnNlcyBmb3IgZGlmZmVyZW50IHRlbmFudHNcbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5zaW5nbGVcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaWQ6ICdrZXktYWxpY2UnLFxuICAgICAgICAgICAgdGVuYW50X2lkOiB0ZW5hbnQxLFxuICAgICAgICAgICAga21zX2tleV9pZDogJ2Fybjphd3M6a21zOmFsaWNlJyxcbiAgICAgICAgICAgIGVuY3J5cHRlZF9kYXRhX2tleTogJ2VuY3J5cHRlZC1hbGljZS1rZXknLFxuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGV4cGlyZXNfYXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyA5MCAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgfSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaWQ6ICdrZXktYm9iJyxcbiAgICAgICAgICAgIHRlbmFudF9pZDogdGVuYW50MixcbiAgICAgICAgICAgIGttc19rZXlfaWQ6ICdhcm46YXdzOmttczpib2InLFxuICAgICAgICAgICAgZW5jcnlwdGVkX2RhdGFfa2V5OiAnZW5jcnlwdGVkLWJvYi1rZXknLFxuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGV4cGlyZXNfYXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyA5MCAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2sgS01TIGRlY3J5cHRpb24gZm9yIGRpZmZlcmVudCB0ZW5hbnRzXG4gICAgICBtb2NrS01TQ2xpZW50LmRlY3J5cHREYXRhS2V5XG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIGtleUlkOiAnYXJuOmF3czprbXM6YWxpY2UnLFxuICAgICAgICAgIHBsYWludGV4dDoga2V5MVBsYWludGV4dCxcbiAgICAgICAgfSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAga2V5SWQ6ICdhcm46YXdzOmttczpib2InLFxuICAgICAgICAgIHBsYWludGV4dDoga2V5MlBsYWludGV4dCxcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgYWxpY2VLZXkgPSBhd2FpdCBrZXlNYW5hZ2VyLmdldEVuY3J5cHRpb25LZXkodGVuYW50MSk7XG4gICAgICBjb25zdCBib2JLZXkgPSBhd2FpdCBrZXlNYW5hZ2VyLmdldEVuY3J5cHRpb25LZXkodGVuYW50Mik7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGFsaWNlS2V5KS5ub3QudG9FcXVhbChib2JLZXkpO1xuICAgICAgZXhwZWN0KGFsaWNlS2V5KS50b0VxdWFsKGtleTFQbGFpbnRleHQpO1xuICAgICAgZXhwZWN0KGJvYktleSkudG9FcXVhbChrZXkyUGxhaW50ZXh0KTtcbiAgICAgIGV4cGVjdChtb2NrS01TQ2xpZW50LmRlY3J5cHREYXRhS2V5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnZW5jcnlwdGVkLWFsaWNlLWtleScsIHRlbmFudDEpO1xuICAgICAgZXhwZWN0KG1vY2tLTVNDbGllbnQuZGVjcnlwdERhdGFLZXkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdlbmNyeXB0ZWQtYm9iLWtleScsIHRlbmFudDIpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBnZXQga2V5IHN0YXRpc3RpY3MgcGVyIHRlbmFudCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHRlbmFudElkID0gJ3RlbmFudC1zdGF0cyc7XG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICBjb25zdCB0ZW5hbnRLZXlzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgLSAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgZXhwaXJlc19hdDogbmV3IERhdGUobm93LmdldFRpbWUoKSArIDYwICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlzX2FjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUobm93LmdldFRpbWUoKSAtIDEyMCAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgZXhwaXJlc19hdDogbmV3IERhdGUobm93LmdldFRpbWUoKSAtIDMwICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5zZWxlY3QubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRhdGE6IHRlbmFudEtleXMsIGVycm9yOiBudWxsIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBrZXlNYW5hZ2VyLmdldEtleVN0YXRzKHRlbmFudElkKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3Qoc3RhdHMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3Qoc3RhdHMudG90YWxLZXlzKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHN0YXRzLmFjdGl2ZUtleXMpLnRvQmUoMSk7XG4gICAgICBleHBlY3Qoc3RhdHMuZXhwaXJlZEtleXMpLnRvQmUoMSk7XG4gICAgICBleHBlY3Qoc3RhdHMuYXZlcmFnZUtleUFnZSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZUNsaWVudC5lcSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3RlbmFudF9pZCcsIHRlbmFudElkKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImRlc2NyaWJlIiwia2V5TWFuYWdlciIsIm1vY2tLTVNDbGllbnQiLCJtb2NrU3VwYWJhc2VDbGllbnQiLCJiZWZvcmVFYWNoIiwicmVzZXRLZXlNYW5hZ2VyIiwiZ2VuZXJhdGVEYXRhS2V5IiwiZm4iLCJkZWNyeXB0RGF0YUtleSIsImVuY3J5cHREYXRhS2V5Iiwicm90YXRlS2V5IiwibGlzdEtleXMiLCJkZXNjcmliZUtleSIsInNjaGVkdWxlS2V5RGVsZXRpb24iLCJjYW5jZWxLZXlEZWxldGlvbiIsImdldEtleVJvdGF0aW9uU3RhdHVzIiwiZW5hYmxlS2V5Um90YXRpb24iLCJkaXNhYmxlS2V5Um90YXRpb24iLCJjcmVhdGVBbGlhcyIsInVwZGF0ZUFsaWFzIiwiZGVsZXRlQWxpYXMiLCJsaXN0QWxpYXNlcyIsImZyb20iLCJtb2NrUmV0dXJuVGhpcyIsInNlbGVjdCIsImluc2VydCIsInVwZGF0ZSIsImRlbGV0ZSIsImVxIiwibHRlIiwib3JkZXIiLCJsaW1pdCIsInNpbmdsZSIsImNyZWF0ZUNsaWVudCIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiS2V5TWFuYWdlciIsImFmdGVyRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJpdCIsInRlbmFudElkIiwiY3VycmVudFZlcnNpb24iLCJub3ciLCJEYXRlIiwiZXhwaXJlZERhdGUiLCJnZXRUaW1lIiwiZXhwaXJlZEtleSIsImlkIiwidGVuYW50X2lkIiwia21zX2tleV9pZCIsImVuY3J5cHRlZF9kYXRhX2tleSIsInZlcnNpb24iLCJpc19hY3RpdmUiLCJjcmVhdGVkX2F0IiwidG9JU09TdHJpbmciLCJleHBpcmVzX2F0Iiwicm90YXRlZF9hdCIsIm5ld0tleVBsYWludGV4dCIsImNyeXB0byIsInJhbmRvbUJ5dGVzIiwibmV3S2V5RW5jcnlwdGVkIiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwiZGF0YSIsImVycm9yIiwia2V5SWQiLCJwbGFpbnRleHQiLCJjaXBoZXJ0ZXh0IiwibmV3S2V5IiwiZXhwZWN0IiwidG9CZURlZmluZWQiLCJ0b0JlSW5zdGFuY2VPZiIsIkJ1ZmZlciIsInRvSGF2ZUJlZW5DYWxsZWQiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIm5lYXJFeHBpcmF0aW9uRGF0ZSIsImtleSIsImtleVBsYWludGV4dCIsImNvbnNvbGVJbmZvU3B5Iiwic3B5T24iLCJjb25zb2xlIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiZ2V0RW5jcnlwdGlvbktleSIsInN0cmluZ0NvbnRhaW5pbmciLCJtb2NrUmVzdG9yZSIsIndhcm5pbmdEYXRlIiwia2V5c05lZWRpbmdSb3RhdGlvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwic2NoZWR1bGVSb3RhdGlvbiIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsImtleUhpc3RvcnkiLCJoaXN0b3J5IiwiZ2V0S2V5SGlzdG9yeSIsInRvSGF2ZUxlbmd0aCIsInRvQmUiLCJpc0FjdGl2ZSIsInJvdGF0ZWRBdCIsImNyZWF0ZUtleSIsInRlbmFudDEiLCJ0ZW5hbnQyIiwia2V5MVBsYWludGV4dCIsImtleTJQbGFpbnRleHQiLCJhbGljZUtleSIsImJvYktleSIsIm5vdCIsInRvRXF1YWwiLCJ0ZW5hbnRLZXlzIiwic3RhdHMiLCJnZXRLZXlTdGF0cyIsInRvdGFsS2V5cyIsImFjdGl2ZUtleXMiLCJleHBpcmVkS2V5cyIsImF2ZXJhZ2VLZXlBZ2UiLCJ0b0JlR3JlYXRlclRoYW4iXSwibWFwcGlu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