b323cc32e0d59ab49ff5ef257e001640
/**
 * Formatting Utility Tests
 *
 * Tests for phone number formatting and date/time formatting with timezone support.
 *
 * @module tests/unit/utils/formatting
 */ "use strict";
describe('Formatting Utilities', ()=>{
    describe('Test 17: Phone Number Formatting', ()=>{
        /**
     * Format phone number to international format
     */ function formatPhoneNumber(phone) {
            // Remove all non-digit characters
            const digits = phone.replace(/\D/g, '');
            // Check if it starts with country code
            if (digits.startsWith('1') && digits.length === 11) {
                // US/Canada format: +1 (XXX) XXX-XXXX
                return `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;
            } else if (digits.startsWith('44') && digits.length >= 11) {
                // UK format: +44 XX XXXX XXXX
                return `+44 ${digits.slice(2, 4)} ${digits.slice(4, 8)} ${digits.slice(8)}`;
            } else if (digits.startsWith('31') && digits.length >= 11) {
                // Netherlands format: +31 X XXXX XXXX
                return `+31 ${digits.slice(2, 3)} ${digits.slice(3, 7)} ${digits.slice(7)}`;
            } else if (digits.length >= 10) {
                // Generic international format: +XX XXX XXX XXXX
                return `+${digits}`;
            }
            return phone; // Return original if can't format
        }
        it('should format US phone number to international format', ()=>{
            // Arrange
            const usPhone = '12345678900';
            // Act
            const formatted = formatPhoneNumber(usPhone);
            // Assert
            expect(formatted).toBe('+1 (234) 567-8900');
        });
        it('should handle phone number with formatting characters', ()=>{
            // Arrange
            const phoneWithFormatting = '+1 (234) 567-8900';
            // Act
            const formatted = formatPhoneNumber(phoneWithFormatting);
            // Assert
            expect(formatted).toBe('+1 (234) 567-8900');
            expect(formatted).toContain('+1');
            expect(formatted).toMatch(/\(\d{3}\)/);
        });
        it('should format UK phone number correctly', ()=>{
            // Arrange
            const ukPhone = '442079460958';
            // Act
            const formatted = formatPhoneNumber(ukPhone);
            // Assert
            expect(formatted).toBe('+44 20 7946 0958');
            expect(formatted).toStartWith('+44');
        });
        it('should format Netherlands phone number correctly', ()=>{
            // Arrange
            const nlPhone = '31612345678';
            // Act
            const formatted = formatPhoneNumber(nlPhone);
            // Assert
            expect(formatted).toBe('+31 6 1234 5678');
            expect(formatted).toStartWith('+31');
        });
        it('should handle phone number without country code', ()=>{
            // Arrange
            const phoneWithoutCountry = '1234567890';
            // Act
            const formatted = formatPhoneNumber(phoneWithoutCountry);
            // Assert
            expect(formatted).toBeDefined();
            expect(formatted.replace(/\D/g, '')).toBe('1234567890');
        });
        it('should remove special characters and format', ()=>{
            // Arrange
            const phoneWithSpecialChars = '+1-234-567-8900';
            // Act
            const formatted = formatPhoneNumber(phoneWithSpecialChars);
            // Assert
            expect(formatted).toBe('+1 (234) 567-8900');
            expect(formatted).not.toContain('-');
        });
        it('should handle empty string', ()=>{
            // Arrange
            const emptyPhone = '';
            // Act
            const formatted = formatPhoneNumber(emptyPhone);
            // Assert
            expect(formatted).toBe('');
        });
        it('should handle invalid phone number gracefully', ()=>{
            // Arrange
            const invalidPhone = 'not-a-phone';
            // Act
            const formatted = formatPhoneNumber(invalidPhone);
            // Assert
            expect(formatted).toBe('not-a-phone'); // Returns original if can't format
        });
    });
    describe('Test 18: Date/Time Formatting with Timezone', ()=>{
        /**
     * Format date with timezone support
     */ function formatDateWithTimezone(date, timezone = 'UTC', format = 'short') {
            const dateObj = typeof date === 'string' ? new Date(date) : date;
            if (isNaN(dateObj.getTime())) {
                return 'Invalid Date';
            }
            if (format === 'relative') {
                return formatRelativeTime(dateObj);
            }
            const options = {
                timeZone: timezone,
                year: 'numeric',
                month: format === 'long' ? 'long' : '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: format === 'long' ? '2-digit' : undefined,
                hour12: false
            };
            return new Intl.DateTimeFormat('en-US', options).format(dateObj);
        }
        /**
     * Format relative time (e.g., "2 hours ago")
     */ function formatRelativeTime(date) {
            const now = new Date();
            const diffMs = now.getTime() - date.getTime();
            const diffSeconds = Math.floor(diffMs / 1000);
            const diffMinutes = Math.floor(diffSeconds / 60);
            const diffHours = Math.floor(diffMinutes / 60);
            const diffDays = Math.floor(diffHours / 24);
            if (diffSeconds < 60) {
                return `${diffSeconds} seconds ago`;
            } else if (diffMinutes < 60) {
                return `${diffMinutes} minutes ago`;
            } else if (diffHours < 24) {
                return `${diffHours} hours ago`;
            } else if (diffDays < 30) {
                return `${diffDays} days ago`;
            } else {
                const diffMonths = Math.floor(diffDays / 30);
                return `${diffMonths} months ago`;
            }
        }
        it('should format date in UTC timezone', ()=>{
            // Arrange
            const date = new Date('2024-01-15T10:30:00Z');
            // Act
            const formatted = formatDateWithTimezone(date, 'UTC', 'short');
            // Assert
            expect(formatted).toBeDefined();
            expect(formatted).toContain('2024');
            expect(formatted).toContain('01');
            expect(formatted).toContain('15');
        });
        it('should format date in specific timezone (America/New_York)', ()=>{
            // Arrange
            const date = new Date('2024-01-15T10:30:00Z');
            // Act
            const formatted = formatDateWithTimezone(date, 'America/New_York', 'short');
            // Assert
            expect(formatted).toBeDefined();
            expect(formatted).toContain('2024');
        // Date should be adjusted for timezone
        });
        it('should format date in long format', ()=>{
            // Arrange
            const date = new Date('2024-01-15T10:30:45Z');
            // Act
            const formatted = formatDateWithTimezone(date, 'UTC', 'long');
            // Assert
            expect(formatted).toBeDefined();
            expect(formatted).toContain('January');
            expect(formatted).toContain('15');
            expect(formatted).toContain('2024');
            expect(formatted).toContain('10');
            expect(formatted).toContain('30');
            expect(formatted).toContain('45');
        });
        it('should format relative time for recent dates', ()=>{
            // Arrange
            const now = new Date();
            const fiveMinutesAgo = new Date(now.getTime() - 5 * 60 * 1000);
            // Act
            const formatted = formatDateWithTimezone(fiveMinutesAgo, 'UTC', 'relative');
            // Assert
            expect(formatted).toBeDefined();
            expect(formatted).toContain('minutes ago');
        });
        it('should format relative time for hours ago', ()=>{
            // Arrange
            const now = new Date();
            const twoHoursAgo = new Date(now.getTime() - 2 * 60 * 60 * 1000);
            // Act
            const formatted = formatDateWithTimezone(twoHoursAgo, 'UTC', 'relative');
            // Assert
            expect(formatted).toBeDefined();
            expect(formatted).toContain('hours ago');
        });
        it('should format relative time for days ago', ()=>{
            // Arrange
            const now = new Date();
            const threeDaysAgo = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000);
            // Act
            const formatted = formatDateWithTimezone(threeDaysAgo, 'UTC', 'relative');
            // Assert
            expect(formatted).toBeDefined();
            expect(formatted).toContain('days ago');
        });
        it('should handle date string input', ()=>{
            // Arrange
            const dateString = '2024-01-15T10:30:00Z';
            // Act
            const formatted = formatDateWithTimezone(dateString, 'UTC', 'short');
            // Assert
            expect(formatted).toBeDefined();
            expect(formatted).not.toBe('Invalid Date');
        });
        it('should return "Invalid Date" for invalid date', ()=>{
            // Arrange
            const invalidDate = 'not-a-date';
            // Act
            const formatted = formatDateWithTimezone(invalidDate, 'UTC', 'short');
            // Assert
            expect(formatted).toBe('Invalid Date');
        });
        it('should handle Asia/Tokyo timezone', ()=>{
            // Arrange
            const date = new Date('2024-01-15T10:30:00Z');
            // Act
            const formatted = formatDateWithTimezone(date, 'Asia/Tokyo', 'short');
            // Assert
            expect(formatted).toBeDefined();
            expect(formatted).toContain('2024');
        // Time should be adjusted for Tokyo timezone (UTC+9)
        });
        it('should handle Europe/Amsterdam timezone', ()=>{
            // Arrange
            const date = new Date('2024-01-15T10:30:00Z');
            // Act
            const formatted = formatDateWithTimezone(date, 'Europe/Amsterdam', 'short');
            // Assert
            expect(formatted).toBeDefined();
            expect(formatted).toContain('2024');
        // Time should be adjusted for Amsterdam timezone
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxBaSBQcm9qZWN0ZW5cXEFEU2FwcFxcdGVzdHNcXHVuaXRcXHV0aWxzXFxmb3JtYXR0aW5nLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBGb3JtYXR0aW5nIFV0aWxpdHkgVGVzdHNcbiAqXG4gKiBUZXN0cyBmb3IgcGhvbmUgbnVtYmVyIGZvcm1hdHRpbmcgYW5kIGRhdGUvdGltZSBmb3JtYXR0aW5nIHdpdGggdGltZXpvbmUgc3VwcG9ydC5cbiAqXG4gKiBAbW9kdWxlIHRlc3RzL3VuaXQvdXRpbHMvZm9ybWF0dGluZ1xuICovXG5cbmRlc2NyaWJlKCdGb3JtYXR0aW5nIFV0aWxpdGllcycsICgpID0+IHtcbiAgZGVzY3JpYmUoJ1Rlc3QgMTc6IFBob25lIE51bWJlciBGb3JtYXR0aW5nJywgKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIEZvcm1hdCBwaG9uZSBudW1iZXIgdG8gaW50ZXJuYXRpb25hbCBmb3JtYXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JtYXRQaG9uZU51bWJlcihwaG9uZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgIC8vIFJlbW92ZSBhbGwgbm9uLWRpZ2l0IGNoYXJhY3RlcnNcbiAgICAgIGNvbnN0IGRpZ2l0cyA9IHBob25lLnJlcGxhY2UoL1xcRC9nLCAnJyk7XG5cbiAgICAgIC8vIENoZWNrIGlmIGl0IHN0YXJ0cyB3aXRoIGNvdW50cnkgY29kZVxuICAgICAgaWYgKGRpZ2l0cy5zdGFydHNXaXRoKCcxJykgJiYgZGlnaXRzLmxlbmd0aCA9PT0gMTEpIHtcbiAgICAgICAgLy8gVVMvQ2FuYWRhIGZvcm1hdDogKzEgKFhYWCkgWFhYLVhYWFhcbiAgICAgICAgcmV0dXJuIGArMSAoJHtkaWdpdHMuc2xpY2UoMSwgNCl9KSAke2RpZ2l0cy5zbGljZSg0LCA3KX0tJHtkaWdpdHMuc2xpY2UoNyl9YDtcbiAgICAgIH0gZWxzZSBpZiAoZGlnaXRzLnN0YXJ0c1dpdGgoJzQ0JykgJiYgZGlnaXRzLmxlbmd0aCA+PSAxMSkge1xuICAgICAgICAvLyBVSyBmb3JtYXQ6ICs0NCBYWCBYWFhYIFhYWFhcbiAgICAgICAgcmV0dXJuIGArNDQgJHtkaWdpdHMuc2xpY2UoMiwgNCl9ICR7ZGlnaXRzLnNsaWNlKDQsIDgpfSAke2RpZ2l0cy5zbGljZSg4KX1gO1xuICAgICAgfSBlbHNlIGlmIChkaWdpdHMuc3RhcnRzV2l0aCgnMzEnKSAmJiBkaWdpdHMubGVuZ3RoID49IDExKSB7XG4gICAgICAgIC8vIE5ldGhlcmxhbmRzIGZvcm1hdDogKzMxIFggWFhYWCBYWFhYXG4gICAgICAgIHJldHVybiBgKzMxICR7ZGlnaXRzLnNsaWNlKDIsIDMpfSAke2RpZ2l0cy5zbGljZSgzLCA3KX0gJHtkaWdpdHMuc2xpY2UoNyl9YDtcbiAgICAgIH0gZWxzZSBpZiAoZGlnaXRzLmxlbmd0aCA+PSAxMCkge1xuICAgICAgICAvLyBHZW5lcmljIGludGVybmF0aW9uYWwgZm9ybWF0OiArWFggWFhYIFhYWCBYWFhYXG4gICAgICAgIHJldHVybiBgKyR7ZGlnaXRzfWA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwaG9uZTsgLy8gUmV0dXJuIG9yaWdpbmFsIGlmIGNhbid0IGZvcm1hdFxuICAgIH1cblxuICAgIGl0KCdzaG91bGQgZm9ybWF0IFVTIHBob25lIG51bWJlciB0byBpbnRlcm5hdGlvbmFsIGZvcm1hdCcsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHVzUGhvbmUgPSAnMTIzNDU2Nzg5MDAnO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdFBob25lTnVtYmVyKHVzUGhvbmUpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWQpLnRvQmUoJysxICgyMzQpIDU2Ny04OTAwJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBwaG9uZSBudW1iZXIgd2l0aCBmb3JtYXR0aW5nIGNoYXJhY3RlcnMnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBwaG9uZVdpdGhGb3JtYXR0aW5nID0gJysxICgyMzQpIDU2Ny04OTAwJztcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXRQaG9uZU51bWJlcihwaG9uZVdpdGhGb3JtYXR0aW5nKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZm9ybWF0dGVkKS50b0JlKCcrMSAoMjM0KSA1NjctODkwMCcpO1xuICAgICAgZXhwZWN0KGZvcm1hdHRlZCkudG9Db250YWluKCcrMScpO1xuICAgICAgZXhwZWN0KGZvcm1hdHRlZCkudG9NYXRjaCgvXFwoXFxkezN9XFwpLyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZvcm1hdCBVSyBwaG9uZSBudW1iZXIgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdWtQaG9uZSA9ICc0NDIwNzk0NjA5NTgnO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdFBob25lTnVtYmVyKHVrUGhvbmUpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWQpLnRvQmUoJys0NCAyMCA3OTQ2IDA5NTgnKTtcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWQpLnRvU3RhcnRXaXRoKCcrNDQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZm9ybWF0IE5ldGhlcmxhbmRzIHBob25lIG51bWJlciBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBubFBob25lID0gJzMxNjEyMzQ1Njc4JztcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXRQaG9uZU51bWJlcihubFBob25lKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZm9ybWF0dGVkKS50b0JlKCcrMzEgNiAxMjM0IDU2NzgnKTtcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWQpLnRvU3RhcnRXaXRoKCcrMzEnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHBob25lIG51bWJlciB3aXRob3V0IGNvdW50cnkgY29kZScsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHBob25lV2l0aG91dENvdW50cnkgPSAnMTIzNDU2Nzg5MCc7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgZm9ybWF0dGVkID0gZm9ybWF0UGhvbmVOdW1iZXIocGhvbmVXaXRob3V0Q291bnRyeSk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGZvcm1hdHRlZCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWQucmVwbGFjZSgvXFxEL2csICcnKSkudG9CZSgnMTIzNDU2Nzg5MCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZW1vdmUgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBmb3JtYXQnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBwaG9uZVdpdGhTcGVjaWFsQ2hhcnMgPSAnKzEtMjM0LTU2Ny04OTAwJztcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXRQaG9uZU51bWJlcihwaG9uZVdpdGhTcGVjaWFsQ2hhcnMpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWQpLnRvQmUoJysxICgyMzQpIDU2Ny04OTAwJyk7XG4gICAgICBleHBlY3QoZm9ybWF0dGVkKS5ub3QudG9Db250YWluKCctJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlbXB0eSBzdHJpbmcnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBlbXB0eVBob25lID0gJyc7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgZm9ybWF0dGVkID0gZm9ybWF0UGhvbmVOdW1iZXIoZW1wdHlQaG9uZSk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGZvcm1hdHRlZCkudG9CZSgnJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBpbnZhbGlkIHBob25lIG51bWJlciBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgaW52YWxpZFBob25lID0gJ25vdC1hLXBob25lJztcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXRQaG9uZU51bWJlcihpbnZhbGlkUGhvbmUpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWQpLnRvQmUoJ25vdC1hLXBob25lJyk7IC8vIFJldHVybnMgb3JpZ2luYWwgaWYgY2FuJ3QgZm9ybWF0XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdUZXN0IDE4OiBEYXRlL1RpbWUgRm9ybWF0dGluZyB3aXRoIFRpbWV6b25lJywgKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIEZvcm1hdCBkYXRlIHdpdGggdGltZXpvbmUgc3VwcG9ydFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvcm1hdERhdGVXaXRoVGltZXpvbmUoXG4gICAgICBkYXRlOiBEYXRlIHwgc3RyaW5nLFxuICAgICAgdGltZXpvbmU6IHN0cmluZyA9ICdVVEMnLFxuICAgICAgZm9ybWF0OiAnc2hvcnQnIHwgJ2xvbmcnIHwgJ3JlbGF0aXZlJyA9ICdzaG9ydCdcbiAgICApOiBzdHJpbmcge1xuICAgICAgY29uc3QgZGF0ZU9iaiA9IHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJyA/IG5ldyBEYXRlKGRhdGUpIDogZGF0ZTtcblxuICAgICAgaWYgKGlzTmFOKGRhdGVPYmouZ2V0VGltZSgpKSkge1xuICAgICAgICByZXR1cm4gJ0ludmFsaWQgRGF0ZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtYXQgPT09ICdyZWxhdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFJlbGF0aXZlVGltZShkYXRlT2JqKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3B0aW9uczogSW50bC5EYXRlVGltZUZvcm1hdE9wdGlvbnMgPSB7XG4gICAgICAgIHRpbWVab25lOiB0aW1lem9uZSxcbiAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICBtb250aDogZm9ybWF0ID09PSAnbG9uZycgPyAnbG9uZycgOiAnMi1kaWdpdCcsXG4gICAgICAgIGRheTogJzItZGlnaXQnLFxuICAgICAgICBob3VyOiAnMi1kaWdpdCcsXG4gICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgICAgICBzZWNvbmQ6IGZvcm1hdCA9PT0gJ2xvbmcnID8gJzItZGlnaXQnIDogdW5kZWZpbmVkLFxuICAgICAgICBob3VyMTI6IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCdlbi1VUycsIG9wdGlvbnMpLmZvcm1hdChkYXRlT2JqKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgcmVsYXRpdmUgdGltZSAoZS5nLiwgXCIyIGhvdXJzIGFnb1wiKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvcm1hdFJlbGF0aXZlVGltZShkYXRlOiBEYXRlKTogc3RyaW5nIHtcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBkaWZmTXMgPSBub3cuZ2V0VGltZSgpIC0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgICBjb25zdCBkaWZmU2Vjb25kcyA9IE1hdGguZmxvb3IoZGlmZk1zIC8gMTAwMCk7XG4gICAgICBjb25zdCBkaWZmTWludXRlcyA9IE1hdGguZmxvb3IoZGlmZlNlY29uZHMgLyA2MCk7XG4gICAgICBjb25zdCBkaWZmSG91cnMgPSBNYXRoLmZsb29yKGRpZmZNaW51dGVzIC8gNjApO1xuICAgICAgY29uc3QgZGlmZkRheXMgPSBNYXRoLmZsb29yKGRpZmZIb3VycyAvIDI0KTtcblxuICAgICAgaWYgKGRpZmZTZWNvbmRzIDwgNjApIHtcbiAgICAgICAgcmV0dXJuIGAke2RpZmZTZWNvbmRzfSBzZWNvbmRzIGFnb2A7XG4gICAgICB9IGVsc2UgaWYgKGRpZmZNaW51dGVzIDwgNjApIHtcbiAgICAgICAgcmV0dXJuIGAke2RpZmZNaW51dGVzfSBtaW51dGVzIGFnb2A7XG4gICAgICB9IGVsc2UgaWYgKGRpZmZIb3VycyA8IDI0KSB7XG4gICAgICAgIHJldHVybiBgJHtkaWZmSG91cnN9IGhvdXJzIGFnb2A7XG4gICAgICB9IGVsc2UgaWYgKGRpZmZEYXlzIDwgMzApIHtcbiAgICAgICAgcmV0dXJuIGAke2RpZmZEYXlzfSBkYXlzIGFnb2A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkaWZmTW9udGhzID0gTWF0aC5mbG9vcihkaWZmRGF5cyAvIDMwKTtcbiAgICAgICAgcmV0dXJuIGAke2RpZmZNb250aHN9IG1vbnRocyBhZ29gO1xuICAgICAgfVxuICAgIH1cblxuICAgIGl0KCdzaG91bGQgZm9ybWF0IGRhdGUgaW4gVVRDIHRpbWV6b25lJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCcyMDI0LTAxLTE1VDEwOjMwOjAwWicpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdERhdGVXaXRoVGltZXpvbmUoZGF0ZSwgJ1VUQycsICdzaG9ydCcpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZm9ybWF0dGVkKS50b0NvbnRhaW4oJzIwMjQnKTtcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWQpLnRvQ29udGFpbignMDEnKTtcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWQpLnRvQ29udGFpbignMTUnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZm9ybWF0IGRhdGUgaW4gc3BlY2lmaWMgdGltZXpvbmUgKEFtZXJpY2EvTmV3X1lvcmspJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCcyMDI0LTAxLTE1VDEwOjMwOjAwWicpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdERhdGVXaXRoVGltZXpvbmUoZGF0ZSwgJ0FtZXJpY2EvTmV3X1lvcmsnLCAnc2hvcnQnKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZm9ybWF0dGVkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGZvcm1hdHRlZCkudG9Db250YWluKCcyMDI0Jyk7XG4gICAgICAvLyBEYXRlIHNob3VsZCBiZSBhZGp1c3RlZCBmb3IgdGltZXpvbmVcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZm9ybWF0IGRhdGUgaW4gbG9uZyBmb3JtYXQnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoJzIwMjQtMDEtMTVUMTA6MzA6NDVaJyk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgZm9ybWF0dGVkID0gZm9ybWF0RGF0ZVdpdGhUaW1lem9uZShkYXRlLCAnVVRDJywgJ2xvbmcnKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZm9ybWF0dGVkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGZvcm1hdHRlZCkudG9Db250YWluKCdKYW51YXJ5Jyk7XG4gICAgICBleHBlY3QoZm9ybWF0dGVkKS50b0NvbnRhaW4oJzE1Jyk7XG4gICAgICBleHBlY3QoZm9ybWF0dGVkKS50b0NvbnRhaW4oJzIwMjQnKTtcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWQpLnRvQ29udGFpbignMTAnKTtcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWQpLnRvQ29udGFpbignMzAnKTtcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWQpLnRvQ29udGFpbignNDUnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZm9ybWF0IHJlbGF0aXZlIHRpbWUgZm9yIHJlY2VudCBkYXRlcycsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBmaXZlTWludXRlc0FnbyA9IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgLSA1ICogNjAgKiAxMDAwKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXREYXRlV2l0aFRpbWV6b25lKGZpdmVNaW51dGVzQWdvLCAnVVRDJywgJ3JlbGF0aXZlJyk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGZvcm1hdHRlZCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWQpLnRvQ29udGFpbignbWludXRlcyBhZ28nKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZm9ybWF0IHJlbGF0aXZlIHRpbWUgZm9yIGhvdXJzIGFnbycsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB0d29Ib3Vyc0FnbyA9IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgLSAyICogNjAgKiA2MCAqIDEwMDApO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdERhdGVXaXRoVGltZXpvbmUodHdvSG91cnNBZ28sICdVVEMnLCAncmVsYXRpdmUnKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZm9ybWF0dGVkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGZvcm1hdHRlZCkudG9Db250YWluKCdob3VycyBhZ28nKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZm9ybWF0IHJlbGF0aXZlIHRpbWUgZm9yIGRheXMgYWdvJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHRocmVlRGF5c0FnbyA9IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgLSAzICogMjQgKiA2MCAqIDYwICogMTAwMCk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgZm9ybWF0dGVkID0gZm9ybWF0RGF0ZVdpdGhUaW1lem9uZSh0aHJlZURheXNBZ28sICdVVEMnLCAncmVsYXRpdmUnKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZm9ybWF0dGVkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGZvcm1hdHRlZCkudG9Db250YWluKCdkYXlzIGFnbycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0ZSBzdHJpbmcgaW5wdXQnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBkYXRlU3RyaW5nID0gJzIwMjQtMDEtMTVUMTA6MzA6MDBaJztcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXREYXRlV2l0aFRpbWV6b25lKGRhdGVTdHJpbmcsICdVVEMnLCAnc2hvcnQnKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZm9ybWF0dGVkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGZvcm1hdHRlZCkubm90LnRvQmUoJ0ludmFsaWQgRGF0ZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gXCJJbnZhbGlkIERhdGVcIiBmb3IgaW52YWxpZCBkYXRlJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgaW52YWxpZERhdGUgPSAnbm90LWEtZGF0ZSc7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgZm9ybWF0dGVkID0gZm9ybWF0RGF0ZVdpdGhUaW1lem9uZShpbnZhbGlkRGF0ZSwgJ1VUQycsICdzaG9ydCcpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWQpLnRvQmUoJ0ludmFsaWQgRGF0ZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgQXNpYS9Ub2t5byB0aW1lem9uZScsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgnMjAyNC0wMS0xNVQxMDozMDowMFonKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXREYXRlV2l0aFRpbWV6b25lKGRhdGUsICdBc2lhL1Rva3lvJywgJ3Nob3J0Jyk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGZvcm1hdHRlZCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWQpLnRvQ29udGFpbignMjAyNCcpO1xuICAgICAgLy8gVGltZSBzaG91bGQgYmUgYWRqdXN0ZWQgZm9yIFRva3lvIHRpbWV6b25lIChVVEMrOSlcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIEV1cm9wZS9BbXN0ZXJkYW0gdGltZXpvbmUnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoJzIwMjQtMDEtMTVUMTA6MzA6MDBaJyk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgZm9ybWF0dGVkID0gZm9ybWF0RGF0ZVdpdGhUaW1lem9uZShkYXRlLCAnRXVyb3BlL0Ftc3RlcmRhbScsICdzaG9ydCcpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZm9ybWF0dGVkKS50b0NvbnRhaW4oJzIwMjQnKTtcbiAgICAgIC8vIFRpbWUgc2hvdWxkIGJlIGFkanVzdGVkIGZvciBBbXN0ZXJkYW0gdGltZXpvbmVcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJkZXNjcmliZSIsImZvcm1hdFBob25lTnVtYmVyIiwicGhvbmUiLCJkaWdpdHMiLCJyZXBsYWNlIiwic3RhcnRzV2l0aCIsImxlbmd0aCIsInNsaWNlIiwiaXQiLCJ1c1Bob25lIiwiZm9ybWF0dGVkIiwiZXhwZWN0IiwidG9CZSIsInBob25lV2l0aEZvcm1hdHRpbmciLCJ0b0NvbnRhaW4iLCJ0b01hdGNoIiwidWtQaG9uZSIsInRvU3RhcnRXaXRoIiwibmxQaG9uZSIsInBob25lV2l0aG91dENvdW50cnkiLCJ0b0JlRGVmaW5lZCIsInBob25lV2l0aFNwZWNpYWxDaGFycyIsIm5vdCIsImVtcHR5UGhvbmUiLCJpbnZhbGlkUGhvbmUiLCJmb3JtYXREYXRlV2l0aFRpbWV6b25lIiwiZGF0ZSIsInRpbWV6b25lIiwiZm9ybWF0IiwiZGF0ZU9iaiIsIkRhdGUiLCJpc05hTiIsImdldFRpbWUiLCJmb3JtYXRSZWxhdGl2ZVRpbWUiLCJvcHRpb25zIiwidGltZVpvbmUiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwidW5kZWZpbmVkIiwiaG91cjEyIiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0Iiwibm93IiwiZGlmZk1zIiwiZGlmZlNlY29uZHMiLCJNYXRoIiwiZmxvb3IiLCJkaWZmTWludXRlcyIsImRpZmZIb3VycyIsImRpZmZEYXlzIiwiZGlmZk1vbnRocyIsImZpdmVNaW51dGVzQWdvIiwidHdvSG91cnNBZ28iLCJ0aHJlZURheXNBZ28iLCJkYXRlU3RyaW5nIiwiaW52YWxpZERhdGUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQztBQUVEQSxTQUFTLHdCQUF3QjtJQUMvQkEsU0FBUyxvQ0FBb0M7UUFDM0M7O0tBRUMsR0FDRCxTQUFTQyxrQkFBa0JDLEtBQWE7WUFDdEMsa0NBQWtDO1lBQ2xDLE1BQU1DLFNBQVNELE1BQU1FLE9BQU8sQ0FBQyxPQUFPO1lBRXBDLHVDQUF1QztZQUN2QyxJQUFJRCxPQUFPRSxVQUFVLENBQUMsUUFBUUYsT0FBT0csTUFBTSxLQUFLLElBQUk7Z0JBQ2xELHNDQUFzQztnQkFD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