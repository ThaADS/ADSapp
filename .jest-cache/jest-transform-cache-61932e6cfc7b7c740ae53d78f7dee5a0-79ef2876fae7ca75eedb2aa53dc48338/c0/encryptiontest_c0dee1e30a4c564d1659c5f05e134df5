e2e7f9c530c8a0fc197a8bdac5c9d50e
/**
 * Unit Tests for Encryption System
 *
 * Comprehensive test suite for the field-level encryption implementation.
 * Tests core encryption/decryption, key management, error handling, and edge cases.
 *
 * @module tests/unit/encryption
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _crypto = /*#__PURE__*/ _interop_require_wildcard(require("crypto"));
const _encryption = require("../../src/lib/crypto/encryption");
const _types = require("../../src/lib/crypto/types");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('Encryption Core', ()=>{
    // Store original env to restore after tests
    const originalEnv = process.env.ENCRYPTION_KEY;
    beforeAll(()=>{
        // Generate a test encryption key
        const testKey = _crypto.randomBytes(32).toString('base64');
        process.env.ENCRYPTION_KEY = testKey;
    });
    afterAll(()=>{
        // Restore original env
        if (originalEnv) {
            process.env.ENCRYPTION_KEY = originalEnv;
        } else {
            delete process.env.ENCRYPTION_KEY;
        }
    });
    describe('Key Management', ()=>{
        test('should load encryption key from environment', ()=>{
            const key = (0, _encryption.loadEncryptionKey)();
            expect(key).toBeInstanceOf(Buffer);
            expect(key.length).toBe(_types.ENCRYPTION_CONSTANTS.KEY_SIZE);
        });
        test('should throw error when encryption key is missing', ()=>{
            const originalKey = process.env.ENCRYPTION_KEY;
            delete process.env.ENCRYPTION_KEY;
            expect(()=>(0, _encryption.loadEncryptionKey)()).toThrow(_types.KeyManagementError);
            expect(()=>(0, _encryption.loadEncryptionKey)()).toThrow(/ENCRYPTION_KEY environment variable is not set/);
            process.env.ENCRYPTION_KEY = originalKey;
        });
        test('should throw error for invalid key length', ()=>{
            const originalKey = process.env.ENCRYPTION_KEY;
            process.env.ENCRYPTION_KEY = Buffer.from('short').toString('base64');
            expect(()=>(0, _encryption.loadEncryptionKey)()).toThrow(_types.KeyManagementError);
            expect(()=>(0, _encryption.loadEncryptionKey)()).toThrow(/Invalid key length/);
            process.env.ENCRYPTION_KEY = originalKey;
        });
        test('should throw error for invalid base64 key', ()=>{
            const originalKey = process.env.ENCRYPTION_KEY;
            process.env.ENCRYPTION_KEY = 'not-valid-base64!!!';
            expect(()=>(0, _encryption.loadEncryptionKey)()).toThrow(_types.KeyManagementError);
            process.env.ENCRYPTION_KEY = originalKey;
        });
        test('should generate cryptographically secure IV', ()=>{
            const iv1 = (0, _encryption.generateIV)();
            const iv2 = (0, _encryption.generateIV)();
            expect(iv1).toBeInstanceOf(Buffer);
            expect(iv1.length).toBe(_types.ENCRYPTION_CONSTANTS.IV_SIZE);
            expect(iv2.length).toBe(_types.ENCRYPTION_CONSTANTS.IV_SIZE);
            expect(iv1.equals(iv2)).toBe(false); // IVs should be unique
        });
    });
    describe('Basic Encryption/Decryption', ()=>{
        test('should encrypt plaintext successfully', ()=>{
            const plaintext = 'sensitive data';
            const result = (0, _encryption.encrypt)(plaintext);
            expect(result).toHaveProperty('encrypted');
            expect(result).toHaveProperty('version');
            expect(result).toHaveProperty('algorithm');
            expect(result).toHaveProperty('iv');
            expect(result).toHaveProperty('authTag');
            expect(result.version).toBe(_types.ENCRYPTION_CONSTANTS.CURRENT_VERSION);
            expect(result.algorithm).toBe(_types.ENCRYPTION_CONSTANTS.ALGORITHM);
            expect(result.encrypted).not.toBe(plaintext);
            expect(result.encrypted.length).toBeGreaterThan(0);
        });
        test('should decrypt encrypted data successfully', ()=>{
            const plaintext = 'test data 123';
            const encrypted = (0, _encryption.encrypt)(plaintext);
            const decrypted = (0, _encryption.decrypt)(encrypted.encrypted, encrypted.version);
            expect(decrypted.plaintext).toBe(plaintext);
            expect(decrypted.version).toBe(encrypted.version);
            expect(decrypted.algorithm).toBe(encrypted.algorithm);
        });
        test('should handle round-trip encryption/decryption', ()=>{
            const testCases = [
                'simple text',
                '+1234567890',
                'user@example.com',
                'Complex $tring with special chars!@#',
                'æ—¥æœ¬èªž unicode ãƒ†ã‚¹ãƒˆ',
                ' ',
                'a',
                'x'.repeat(1000)
            ];
            for (const testCase of testCases){
                const encrypted = (0, _encryption.encrypt)(testCase);
                const decrypted = (0, _encryption.decrypt)(encrypted.encrypted, encrypted.version);
                expect(decrypted.plaintext).toBe(testCase);
            }
        });
        test('should produce different ciphertext for same plaintext', ()=>{
            const plaintext = 'same data';
            const result1 = (0, _encryption.encrypt)(plaintext);
            const result2 = (0, _encryption.encrypt)(plaintext);
            // Different IVs should produce different ciphertext
            expect(result1.iv).not.toBe(result2.iv);
            expect(result1.encrypted).not.toBe(result2.encrypted);
            // But both should decrypt to same plaintext
            expect((0, _encryption.decrypt)(result1.encrypted, result1.version).plaintext).toBe(plaintext);
            expect((0, _encryption.decrypt)(result2.encrypted, result2.version).plaintext).toBe(plaintext);
        });
    });
    describe('Error Handling', ()=>{
        test('should throw DecryptionError for corrupted data', ()=>{
            const plaintext = 'test';
            const encrypted = (0, _encryption.encrypt)(plaintext);
            // Corrupt the encrypted data
            const buffer = Buffer.from(encrypted.encrypted, 'base64');
            buffer[buffer.length - 1] ^= 0xFF; // Flip bits in auth tag
            const corrupted = buffer.toString('base64');
            expect(()=>(0, _encryption.decrypt)(corrupted, encrypted.version)).toThrow(_types.DecryptionError);
        });
        test('should throw DecryptionError for invalid encrypted data format', ()=>{
            expect(()=>(0, _encryption.decrypt)('invalid-data', _types.ENCRYPTION_CONSTANTS.CURRENT_VERSION)).toThrow(_types.DecryptionError);
        });
        test('should throw DecryptionError for too short data', ()=>{
            const shortData = Buffer.from('abc').toString('base64');
            expect(()=>(0, _encryption.decrypt)(shortData, _types.ENCRYPTION_CONSTANTS.CURRENT_VERSION)).toThrow(_types.DecryptionError);
            expect(()=>(0, _encryption.decrypt)(shortData, _types.ENCRYPTION_CONSTANTS.CURRENT_VERSION)).toThrow(/too short/);
        });
        test('should handle empty encryption gracefully', ()=>{
            expect(()=>(0, _encryption.encrypt)('')).not.toThrow();
        });
    });
    describe('Data Validation', ()=>{
        test('should validate correct encrypted data structure', ()=>{
            const plaintext = 'test';
            const encrypted = (0, _encryption.encrypt)(plaintext);
            const validation = (0, _encryption.validateEncryptedData)(encrypted.encrypted, encrypted.version);
            expect(validation.valid).toBe(true);
            expect(validation.details?.isBase64).toBe(true);
            expect(validation.details?.hasValidStructure).toBe(true);
        });
        test('should reject empty encrypted data', ()=>{
            const validation = (0, _encryption.validateEncryptedData)('', _types.ENCRYPTION_CONSTANTS.CURRENT_VERSION);
            expect(validation.valid).toBe(false);
            expect(validation.error).toBeDefined();
        });
        test('should reject invalid base64', ()=>{
            const validation = (0, _encryption.validateEncryptedData)('not-base64!!!', _types.ENCRYPTION_CONSTANTS.CURRENT_VERSION);
            expect(validation.valid).toBe(false);
            expect(validation.details?.isBase64).toBe(false);
        });
        test('should reject data that is too short', ()=>{
            const shortData = Buffer.from('abc').toString('base64');
            const validation = (0, _encryption.validateEncryptedData)(shortData, _types.ENCRYPTION_CONSTANTS.CURRENT_VERSION);
            expect(validation.valid).toBe(false);
            expect(validation.details?.hasValidStructure).toBe(false);
        });
    });
    describe('Batch Operations', ()=>{
        test('should encrypt multiple values in batch', ()=>{
            const values = [
                '+1234567890',
                'user@example.com',
                'secret123'
            ];
            const results = (0, _encryption.encryptBatch)(values);
            expect(results).toHaveLength(3);
            results.forEach((result, index)=>{
                expect(result.encrypted).toBeDefined();
                expect(result.version).toBe(_types.ENCRYPTION_CONSTANTS.CURRENT_VERSION);
                // Verify can decrypt
                const decrypted = (0, _encryption.decrypt)(result.encrypted, result.version);
                expect(decrypted.plaintext).toBe(values[index]);
            });
        });
        test('should decrypt multiple values in batch', ()=>{
            const plaintexts = [
                'data1',
                'data2',
                'data3'
            ];
            const encrypted = (0, _encryption.encryptBatch)(plaintexts);
            const encryptedValues = encrypted.map((e)=>({
                    data: e.encrypted,
                    version: e.version
                }));
            const decrypted = (0, _encryption.decryptBatch)(encryptedValues);
            expect(decrypted).toHaveLength(3);
            decrypted.forEach((result, index)=>{
                expect(result.plaintext).toBe(plaintexts[index]);
            });
        });
    });
    describe('Key Rotation', ()=>{
        test('should re-encrypt data with new version', ()=>{
            const plaintext = 'rotate this';
            const encrypted = (0, _encryption.encrypt)(plaintext, {
                version: 'v1'
            });
            const reEncrypted = (0, _encryption.reEncrypt)(encrypted.encrypted, 'v1', 'v2', {
                version: 'v1'
            }, {
                version: 'v2'
            });
            expect(reEncrypted.version).toBe('v2');
            expect(reEncrypted.encrypted).not.toBe(encrypted.encrypted);
            // Verify can decrypt with new version
            const decrypted = (0, _encryption.decrypt)(reEncrypted.encrypted, 'v2');
            expect(decrypted.plaintext).toBe(plaintext);
        });
    });
    describe('System Tests', ()=>{
        test('should pass encryption system test', ()=>{
            const result = (0, _encryption.testEncryption)();
            expect(result).toBe(true);
        });
        test('should return correct encryption status', ()=>{
            const status = (0, _encryption.getEncryptionStatus)();
            expect(status.keyLoaded).toBe(true);
            expect(status.version).toBe(_types.ENCRYPTION_CONSTANTS.CURRENT_VERSION);
            expect(status.algorithm).toBe(_types.ENCRYPTION_CONSTANTS.ALGORITHM);
            expect(status.testPassed).toBe(true);
        });
        test('should report failed status when key is missing', ()=>{
            const originalKey = process.env.ENCRYPTION_KEY;
            delete process.env.ENCRYPTION_KEY;
            const status = (0, _encryption.getEncryptionStatus)();
            expect(status.keyLoaded).toBe(false);
            expect(status.testPassed).toBe(false);
            process.env.ENCRYPTION_KEY = originalKey;
        });
    });
    describe('Security Features', ()=>{
        test('should use unique IV for each encryption', ()=>{
            const plaintext = 'same data';
            const ivs = new Set();
            for(let i = 0; i < 100; i++){
                const result = (0, _encryption.encrypt)(plaintext);
                ivs.add(result.iv);
            }
            expect(ivs.size).toBe(100); // All IVs should be unique
        });
        test('should include authentication tag', ()=>{
            const plaintext = 'authenticated';
            const result = (0, _encryption.encrypt)(plaintext);
            expect(result.authTag).toBeDefined();
            expect(result.authTag.length).toBeGreaterThan(0);
            // Verify auth tag is Base64
            expect(()=>Buffer.from(result.authTag, 'base64')).not.toThrow();
        });
        test('should clear sensitive buffer data', ()=>{
            const buffer = Buffer.from('sensitive data');
            const original = Buffer.from(buffer);
            (0, _encryption.clearBuffer)(buffer);
            // Buffer should be modified
            expect(buffer.equals(original)).toBe(false);
        });
    });
    describe('Edge Cases', ()=>{
        test('should handle empty string encryption', ()=>{
            const result = (0, _encryption.encrypt)('');
            expect(result.encrypted).toBeDefined();
            const decrypted = (0, _encryption.decrypt)(result.encrypted, result.version);
            expect(decrypted.plaintext).toBe('');
        });
        test('should handle very long strings', ()=>{
            const longString = 'x'.repeat(10000);
            const result = (0, _encryption.encrypt)(longString);
            const decrypted = (0, _encryption.decrypt)(result.encrypted, result.version);
            expect(decrypted.plaintext).toBe(longString);
            expect(decrypted.plaintext.length).toBe(10000);
        });
        test('should handle unicode characters', ()=>{
            const unicode = 'ðŸ”’ æ—¥æœ¬èªž Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©';
            const result = (0, _encryption.encrypt)(unicode);
            const decrypted = (0, _encryption.decrypt)(result.encrypted, result.version);
            expect(decrypted.plaintext).toBe(unicode);
        });
        test('should handle special characters', ()=>{
            const special = '!@#$%^&*()_+-=[]{}|;:\'",.<>?/\\`~';
            const result = (0, _encryption.encrypt)(special);
            const decrypted = (0, _encryption.decrypt)(result.encrypted, result.version);
            expect(decrypted.plaintext).toBe(special);
        });
        test('should handle whitespace-only strings', ()=>{
            const whitespace = '   \n\t   ';
            const result = (0, _encryption.encrypt)(whitespace);
            const decrypted = (0, _encryption.decrypt)(result.encrypted, result.version);
            expect(decrypted.plaintext).toBe(whitespace);
        });
    });
    describe('Performance', ()=>{
        test('should encrypt/decrypt within acceptable time', ()=>{
            const plaintext = 'performance test';
            const iterations = 1000;
            const startEncrypt = Date.now();
            for(let i = 0; i < iterations; i++){
                (0, _encryption.encrypt)(plaintext);
            }
            const encryptTime = Date.now() - startEncrypt;
            const encrypted = (0, _encryption.encrypt)(plaintext);
            const startDecrypt = Date.now();
            for(let i = 0; i < iterations; i++){
                (0, _encryption.decrypt)(encrypted.encrypted, encrypted.version);
            }
            const decryptTime = Date.now() - startDecrypt;
            console.log(`Encryption: ${iterations} operations in ${encryptTime}ms (${(iterations / encryptTime * 1000).toFixed(0)} ops/sec)`);
            console.log(`Decryption: ${iterations} operations in ${decryptTime}ms (${(iterations / decryptTime * 1000).toFixed(0)} ops/sec)`);
            // Should be reasonably fast (adjust thresholds as needed)
            expect(encryptTime).toBeLessThan(5000); // 5 seconds for 1000 encryptions
            expect(decryptTime).toBeLessThan(5000); // 5 seconds for 1000 decryptions
        });
        test('should handle batch operations efficiently', ()=>{
            const values = Array(100).fill('test data');
            const start = Date.now();
            const encrypted = (0, _encryption.encryptBatch)(values);
            const encryptTime = Date.now() - start;
            const encryptedValues = encrypted.map((e)=>({
                    data: e.encrypted,
                    version: e.version
                }));
            const startDecrypt = Date.now();
            const decrypted = (0, _encryption.decryptBatch)(encryptedValues);
            const decryptTime = Date.now() - startDecrypt;
            console.log(`Batch encrypt: ${values.length} values in ${encryptTime}ms`);
            console.log(`Batch decrypt: ${values.length} values in ${decryptTime}ms`);
            expect(encrypted).toHaveLength(100);
            expect(decrypted).toHaveLength(100);
            expect(encryptTime).toBeLessThan(1000);
            expect(decryptTime).toBeLessThan(1000);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxBaSBQcm9qZWN0ZW5cXEFEU2FwcFxcdGVzdHNcXHVuaXRcXGVuY3J5cHRpb24udGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVuaXQgVGVzdHMgZm9yIEVuY3J5cHRpb24gU3lzdGVtXG4gKlxuICogQ29tcHJlaGVuc2l2ZSB0ZXN0IHN1aXRlIGZvciB0aGUgZmllbGQtbGV2ZWwgZW5jcnlwdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAqIFRlc3RzIGNvcmUgZW5jcnlwdGlvbi9kZWNyeXB0aW9uLCBrZXkgbWFuYWdlbWVudCwgZXJyb3IgaGFuZGxpbmcsIGFuZCBlZGdlIGNhc2VzLlxuICpcbiAqIEBtb2R1bGUgdGVzdHMvdW5pdC9lbmNyeXB0aW9uXG4gKi9cblxuaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQge1xuICBlbmNyeXB0LFxuICBkZWNyeXB0LFxuICBsb2FkRW5jcnlwdGlvbktleSxcbiAgZ2VuZXJhdGVJVixcbiAgdmFsaWRhdGVFbmNyeXB0ZWREYXRhLFxuICB0ZXN0RW5jcnlwdGlvbixcbiAgZ2V0RW5jcnlwdGlvblN0YXR1cyxcbiAgZW5jcnlwdEJhdGNoLFxuICBkZWNyeXB0QmF0Y2gsXG4gIHJlRW5jcnlwdCxcbiAgY2xlYXJCdWZmZXIsXG59IGZyb20gJy4uLy4uL3NyYy9saWIvY3J5cHRvL2VuY3J5cHRpb24nO1xuaW1wb3J0IHtcbiAgRW5jcnlwdGlvbkVycm9yLFxuICBEZWNyeXB0aW9uRXJyb3IsXG4gIEtleU1hbmFnZW1lbnRFcnJvcixcbiAgRU5DUllQVElPTl9DT05TVEFOVFMsXG59IGZyb20gJy4uLy4uL3NyYy9saWIvY3J5cHRvL3R5cGVzJztcblxuZGVzY3JpYmUoJ0VuY3J5cHRpb24gQ29yZScsICgpID0+IHtcbiAgLy8gU3RvcmUgb3JpZ2luYWwgZW52IHRvIHJlc3RvcmUgYWZ0ZXIgdGVzdHNcbiAgY29uc3Qgb3JpZ2luYWxFbnYgPSBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWTtcblxuICBiZWZvcmVBbGwoKCkgPT4ge1xuICAgIC8vIEdlbmVyYXRlIGEgdGVzdCBlbmNyeXB0aW9uIGtleVxuICAgIGNvbnN0IHRlc3RLZXkgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMzIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWSA9IHRlc3RLZXk7XG4gIH0pO1xuXG4gIGFmdGVyQWxsKCgpID0+IHtcbiAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGVudlxuICAgIGlmIChvcmlnaW5hbEVudikge1xuICAgICAgcHJvY2Vzcy5lbnYuRU5DUllQVElPTl9LRVkgPSBvcmlnaW5hbEVudjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHByb2Nlc3MuZW52LkVOQ1JZUFRJT05fS0VZO1xuICAgIH1cbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0tleSBNYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBsb2FkIGVuY3J5cHRpb24ga2V5IGZyb20gZW52aXJvbm1lbnQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBsb2FkRW5jcnlwdGlvbktleSgpO1xuICAgICAgZXhwZWN0KGtleSkudG9CZUluc3RhbmNlT2YoQnVmZmVyKTtcbiAgICAgIGV4cGVjdChrZXkubGVuZ3RoKS50b0JlKEVOQ1JZUFRJT05fQ09OU1RBTlRTLktFWV9TSVpFKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB0aHJvdyBlcnJvciB3aGVuIGVuY3J5cHRpb24ga2V5IGlzIG1pc3NpbmcnLCAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbEtleSA9IHByb2Nlc3MuZW52LkVOQ1JZUFRJT05fS0VZO1xuICAgICAgZGVsZXRlIHByb2Nlc3MuZW52LkVOQ1JZUFRJT05fS0VZO1xuXG4gICAgICBleHBlY3QoKCkgPT4gbG9hZEVuY3J5cHRpb25LZXkoKSkudG9UaHJvdyhLZXlNYW5hZ2VtZW50RXJyb3IpO1xuICAgICAgZXhwZWN0KCgpID0+IGxvYWRFbmNyeXB0aW9uS2V5KCkpLnRvVGhyb3coL0VOQ1JZUFRJT05fS0VZIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBzZXQvKTtcblxuICAgICAgcHJvY2Vzcy5lbnYuRU5DUllQVElPTl9LRVkgPSBvcmlnaW5hbEtleTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3IgaW52YWxpZCBrZXkgbGVuZ3RoJywgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxLZXkgPSBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWTtcbiAgICAgIHByb2Nlc3MuZW52LkVOQ1JZUFRJT05fS0VZID0gQnVmZmVyLmZyb20oJ3Nob3J0JykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXG4gICAgICBleHBlY3QoKCkgPT4gbG9hZEVuY3J5cHRpb25LZXkoKSkudG9UaHJvdyhLZXlNYW5hZ2VtZW50RXJyb3IpO1xuICAgICAgZXhwZWN0KCgpID0+IGxvYWRFbmNyeXB0aW9uS2V5KCkpLnRvVGhyb3coL0ludmFsaWQga2V5IGxlbmd0aC8pO1xuXG4gICAgICBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWSA9IG9yaWdpbmFsS2V5O1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBpbnZhbGlkIGJhc2U2NCBrZXknLCAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbEtleSA9IHByb2Nlc3MuZW52LkVOQ1JZUFRJT05fS0VZO1xuICAgICAgcHJvY2Vzcy5lbnYuRU5DUllQVElPTl9LRVkgPSAnbm90LXZhbGlkLWJhc2U2NCEhISc7XG5cbiAgICAgIGV4cGVjdCgoKSA9PiBsb2FkRW5jcnlwdGlvbktleSgpKS50b1Rocm93KEtleU1hbmFnZW1lbnRFcnJvcik7XG5cbiAgICAgIHByb2Nlc3MuZW52LkVOQ1JZUFRJT05fS0VZID0gb3JpZ2luYWxLZXk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZ2VuZXJhdGUgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIElWJywgKCkgPT4ge1xuICAgICAgY29uc3QgaXYxID0gZ2VuZXJhdGVJVigpO1xuICAgICAgY29uc3QgaXYyID0gZ2VuZXJhdGVJVigpO1xuXG4gICAgICBleHBlY3QoaXYxKS50b0JlSW5zdGFuY2VPZihCdWZmZXIpO1xuICAgICAgZXhwZWN0KGl2MS5sZW5ndGgpLnRvQmUoRU5DUllQVElPTl9DT05TVEFOVFMuSVZfU0laRSk7XG4gICAgICBleHBlY3QoaXYyLmxlbmd0aCkudG9CZShFTkNSWVBUSU9OX0NPTlNUQU5UUy5JVl9TSVpFKTtcbiAgICAgIGV4cGVjdChpdjEuZXF1YWxzKGl2MikpLnRvQmUoZmFsc2UpOyAvLyBJVnMgc2hvdWxkIGJlIHVuaXF1ZVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQmFzaWMgRW5jcnlwdGlvbi9EZWNyeXB0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBlbmNyeXB0IHBsYWludGV4dCBzdWNjZXNzZnVsbHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBwbGFpbnRleHQgPSAnc2Vuc2l0aXZlIGRhdGEnO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZW5jcnlwdChwbGFpbnRleHQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0hhdmVQcm9wZXJ0eSgnZW5jcnlwdGVkJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0hhdmVQcm9wZXJ0eSgndmVyc2lvbicpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlUHJvcGVydHkoJ2FsZ29yaXRobScpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlUHJvcGVydHkoJ2l2Jyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0hhdmVQcm9wZXJ0eSgnYXV0aFRhZycpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnZlcnNpb24pLnRvQmUoRU5DUllQVElPTl9DT05TVEFOVFMuQ1VSUkVOVF9WRVJTSU9OKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWxnb3JpdGhtKS50b0JlKEVOQ1JZUFRJT05fQ09OU1RBTlRTLkFMR09SSVRITSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVuY3J5cHRlZCkubm90LnRvQmUocGxhaW50ZXh0KTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZW5jcnlwdGVkLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGRlY3J5cHQgZW5jcnlwdGVkIGRhdGEgc3VjY2Vzc2Z1bGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgcGxhaW50ZXh0ID0gJ3Rlc3QgZGF0YSAxMjMnO1xuICAgICAgY29uc3QgZW5jcnlwdGVkID0gZW5jcnlwdChwbGFpbnRleHQpO1xuICAgICAgY29uc3QgZGVjcnlwdGVkID0gZGVjcnlwdChlbmNyeXB0ZWQuZW5jcnlwdGVkLCBlbmNyeXB0ZWQudmVyc2lvbik7XG5cbiAgICAgIGV4cGVjdChkZWNyeXB0ZWQucGxhaW50ZXh0KS50b0JlKHBsYWludGV4dCk7XG4gICAgICBleHBlY3QoZGVjcnlwdGVkLnZlcnNpb24pLnRvQmUoZW5jcnlwdGVkLnZlcnNpb24pO1xuICAgICAgZXhwZWN0KGRlY3J5cHRlZC5hbGdvcml0aG0pLnRvQmUoZW5jcnlwdGVkLmFsZ29yaXRobSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIHJvdW5kLXRyaXAgZW5jcnlwdGlvbi9kZWNyeXB0aW9uJywgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENhc2VzID0gW1xuICAgICAgICAnc2ltcGxlIHRleHQnLFxuICAgICAgICAnKzEyMzQ1Njc4OTAnLFxuICAgICAgICAndXNlckBleGFtcGxlLmNvbScsXG4gICAgICAgICdDb21wbGV4ICR0cmluZyB3aXRoIHNwZWNpYWwgY2hhcnMhQCMnLFxuICAgICAgICAn5pel5pys6KqeIHVuaWNvZGUg44OG44K544OIJyxcbiAgICAgICAgJyAnLFxuICAgICAgICAnYScsXG4gICAgICAgICd4Jy5yZXBlYXQoMTAwMCksIC8vIExvbmcgc3RyaW5nXG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IHRlc3RDYXNlIG9mIHRlc3RDYXNlcykge1xuICAgICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0KHRlc3RDYXNlKTtcbiAgICAgICAgY29uc3QgZGVjcnlwdGVkID0gZGVjcnlwdChlbmNyeXB0ZWQuZW5jcnlwdGVkLCBlbmNyeXB0ZWQudmVyc2lvbik7XG4gICAgICAgIGV4cGVjdChkZWNyeXB0ZWQucGxhaW50ZXh0KS50b0JlKHRlc3RDYXNlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBwcm9kdWNlIGRpZmZlcmVudCBjaXBoZXJ0ZXh0IGZvciBzYW1lIHBsYWludGV4dCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHBsYWludGV4dCA9ICdzYW1lIGRhdGEnO1xuICAgICAgY29uc3QgcmVzdWx0MSA9IGVuY3J5cHQocGxhaW50ZXh0KTtcbiAgICAgIGNvbnN0IHJlc3VsdDIgPSBlbmNyeXB0KHBsYWludGV4dCk7XG5cbiAgICAgIC8vIERpZmZlcmVudCBJVnMgc2hvdWxkIHByb2R1Y2UgZGlmZmVyZW50IGNpcGhlcnRleHRcbiAgICAgIGV4cGVjdChyZXN1bHQxLml2KS5ub3QudG9CZShyZXN1bHQyLml2KTtcbiAgICAgIGV4cGVjdChyZXN1bHQxLmVuY3J5cHRlZCkubm90LnRvQmUocmVzdWx0Mi5lbmNyeXB0ZWQpO1xuXG4gICAgICAvLyBCdXQgYm90aCBzaG91bGQgZGVjcnlwdCB0byBzYW1lIHBsYWludGV4dFxuICAgICAgZXhwZWN0KGRlY3J5cHQocmVzdWx0MS5lbmNyeXB0ZWQsIHJlc3VsdDEudmVyc2lvbikucGxhaW50ZXh0KS50b0JlKHBsYWludGV4dCk7XG4gICAgICBleHBlY3QoZGVjcnlwdChyZXN1bHQyLmVuY3J5cHRlZCwgcmVzdWx0Mi52ZXJzaW9uKS5wbGFpbnRleHQpLnRvQmUocGxhaW50ZXh0KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCB0aHJvdyBEZWNyeXB0aW9uRXJyb3IgZm9yIGNvcnJ1cHRlZCBkYXRhJywgKCkgPT4ge1xuICAgICAgY29uc3QgcGxhaW50ZXh0ID0gJ3Rlc3QnO1xuICAgICAgY29uc3QgZW5jcnlwdGVkID0gZW5jcnlwdChwbGFpbnRleHQpO1xuXG4gICAgICAvLyBDb3JydXB0IHRoZSBlbmNyeXB0ZWQgZGF0YVxuICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZW5jcnlwdGVkLmVuY3J5cHRlZCwgJ2Jhc2U2NCcpO1xuICAgICAgYnVmZmVyW2J1ZmZlci5sZW5ndGggLSAxXSBePSAweEZGOyAvLyBGbGlwIGJpdHMgaW4gYXV0aCB0YWdcbiAgICAgIGNvbnN0IGNvcnJ1cHRlZCA9IGJ1ZmZlci50b1N0cmluZygnYmFzZTY0Jyk7XG5cbiAgICAgIGV4cGVjdCgoKSA9PiBkZWNyeXB0KGNvcnJ1cHRlZCwgZW5jcnlwdGVkLnZlcnNpb24pKS50b1Rocm93KERlY3J5cHRpb25FcnJvcik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdGhyb3cgRGVjcnlwdGlvbkVycm9yIGZvciBpbnZhbGlkIGVuY3J5cHRlZCBkYXRhIGZvcm1hdCcsICgpID0+IHtcbiAgICAgIGV4cGVjdCgoKSA9PiBkZWNyeXB0KCdpbnZhbGlkLWRhdGEnLCBFTkNSWVBUSU9OX0NPTlNUQU5UUy5DVVJSRU5UX1ZFUlNJT04pKS50b1Rocm93KFxuICAgICAgICBEZWNyeXB0aW9uRXJyb3JcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdGhyb3cgRGVjcnlwdGlvbkVycm9yIGZvciB0b28gc2hvcnQgZGF0YScsICgpID0+IHtcbiAgICAgIGNvbnN0IHNob3J0RGF0YSA9IEJ1ZmZlci5mcm9tKCdhYmMnKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICBleHBlY3QoKCkgPT4gZGVjcnlwdChzaG9ydERhdGEsIEVOQ1JZUFRJT05fQ09OU1RBTlRTLkNVUlJFTlRfVkVSU0lPTikpLnRvVGhyb3coXG4gICAgICAgIERlY3J5cHRpb25FcnJvclxuICAgICAgKTtcbiAgICAgIGV4cGVjdCgoKSA9PiBkZWNyeXB0KHNob3J0RGF0YSwgRU5DUllQVElPTl9DT05TVEFOVFMuQ1VSUkVOVF9WRVJTSU9OKSkudG9UaHJvdyhcbiAgICAgICAgL3RvbyBzaG9ydC9cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGVtcHR5IGVuY3J5cHRpb24gZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGV4cGVjdCgoKSA9PiBlbmNyeXB0KCcnKSkubm90LnRvVGhyb3coKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0RhdGEgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgdmFsaWRhdGUgY29ycmVjdCBlbmNyeXB0ZWQgZGF0YSBzdHJ1Y3R1cmUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwbGFpbnRleHQgPSAndGVzdCc7XG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0KHBsYWludGV4dCk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gdmFsaWRhdGVFbmNyeXB0ZWREYXRhKGVuY3J5cHRlZC5lbmNyeXB0ZWQsIGVuY3J5cHRlZC52ZXJzaW9uKTtcblxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24udmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5kZXRhaWxzPy5pc0Jhc2U2NCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmRldGFpbHM/Lmhhc1ZhbGlkU3RydWN0dXJlKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJlamVjdCBlbXB0eSBlbmNyeXB0ZWQgZGF0YScsICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB2YWxpZGF0ZUVuY3J5cHRlZERhdGEoJycsIEVOQ1JZUFRJT05fQ09OU1RBTlRTLkNVUlJFTlRfVkVSU0lPTik7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi52YWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBiYXNlNjQnLCAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gdmFsaWRhdGVFbmNyeXB0ZWREYXRhKCdub3QtYmFzZTY0ISEhJywgRU5DUllQVElPTl9DT05TVEFOVFMuQ1VSUkVOVF9WRVJTSU9OKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmRldGFpbHM/LmlzQmFzZTY0KS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZWplY3QgZGF0YSB0aGF0IGlzIHRvbyBzaG9ydCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHNob3J0RGF0YSA9IEJ1ZmZlci5mcm9tKCdhYmMnKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gdmFsaWRhdGVFbmNyeXB0ZWREYXRhKHNob3J0RGF0YSwgRU5DUllQVElPTl9DT05TVEFOVFMuQ1VSUkVOVF9WRVJTSU9OKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmRldGFpbHM/Lmhhc1ZhbGlkU3RydWN0dXJlKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0JhdGNoIE9wZXJhdGlvbnMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGVuY3J5cHQgbXVsdGlwbGUgdmFsdWVzIGluIGJhdGNoJywgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVzID0gW1xuICAgICAgICAnKzEyMzQ1Njc4OTAnLFxuICAgICAgICAndXNlckBleGFtcGxlLmNvbScsXG4gICAgICAgICdzZWNyZXQxMjMnLFxuICAgICAgXTtcblxuICAgICAgY29uc3QgcmVzdWx0cyA9IGVuY3J5cHRCYXRjaCh2YWx1ZXMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0cykudG9IYXZlTGVuZ3RoKDMpO1xuICAgICAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGluZGV4KSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZW5jcnlwdGVkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZlcnNpb24pLnRvQmUoRU5DUllQVElPTl9DT05TVEFOVFMuQ1VSUkVOVF9WRVJTSU9OKTtcblxuICAgICAgICAvLyBWZXJpZnkgY2FuIGRlY3J5cHRcbiAgICAgICAgY29uc3QgZGVjcnlwdGVkID0gZGVjcnlwdChyZXN1bHQuZW5jcnlwdGVkLCByZXN1bHQudmVyc2lvbik7XG4gICAgICAgIGV4cGVjdChkZWNyeXB0ZWQucGxhaW50ZXh0KS50b0JlKHZhbHVlc1tpbmRleF0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZGVjcnlwdCBtdWx0aXBsZSB2YWx1ZXMgaW4gYmF0Y2gnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwbGFpbnRleHRzID0gWydkYXRhMScsICdkYXRhMicsICdkYXRhMyddO1xuICAgICAgY29uc3QgZW5jcnlwdGVkID0gZW5jcnlwdEJhdGNoKHBsYWludGV4dHMpO1xuXG4gICAgICBjb25zdCBlbmNyeXB0ZWRWYWx1ZXMgPSBlbmNyeXB0ZWQubWFwKGUgPT4gKHtcbiAgICAgICAgZGF0YTogZS5lbmNyeXB0ZWQsXG4gICAgICAgIHZlcnNpb246IGUudmVyc2lvbixcbiAgICAgIH0pKTtcblxuICAgICAgY29uc3QgZGVjcnlwdGVkID0gZGVjcnlwdEJhdGNoKGVuY3J5cHRlZFZhbHVlcyk7XG5cbiAgICAgIGV4cGVjdChkZWNyeXB0ZWQpLnRvSGF2ZUxlbmd0aCgzKTtcbiAgICAgIGRlY3J5cHRlZC5mb3JFYWNoKChyZXN1bHQsIGluZGV4KSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQucGxhaW50ZXh0KS50b0JlKHBsYWludGV4dHNbaW5kZXhdKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnS2V5IFJvdGF0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCByZS1lbmNyeXB0IGRhdGEgd2l0aCBuZXcgdmVyc2lvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHBsYWludGV4dCA9ICdyb3RhdGUgdGhpcyc7XG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0KHBsYWludGV4dCwgeyB2ZXJzaW9uOiAndjEnIH0pO1xuXG4gICAgICBjb25zdCByZUVuY3J5cHRlZCA9IHJlRW5jcnlwdChcbiAgICAgICAgZW5jcnlwdGVkLmVuY3J5cHRlZCxcbiAgICAgICAgJ3YxJyxcbiAgICAgICAgJ3YyJyxcbiAgICAgICAgeyB2ZXJzaW9uOiAndjEnIH0sXG4gICAgICAgIHsgdmVyc2lvbjogJ3YyJyB9XG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVFbmNyeXB0ZWQudmVyc2lvbikudG9CZSgndjInKTtcbiAgICAgIGV4cGVjdChyZUVuY3J5cHRlZC5lbmNyeXB0ZWQpLm5vdC50b0JlKGVuY3J5cHRlZC5lbmNyeXB0ZWQpO1xuXG4gICAgICAvLyBWZXJpZnkgY2FuIGRlY3J5cHQgd2l0aCBuZXcgdmVyc2lvblxuICAgICAgY29uc3QgZGVjcnlwdGVkID0gZGVjcnlwdChyZUVuY3J5cHRlZC5lbmNyeXB0ZWQsICd2MicpO1xuICAgICAgZXhwZWN0KGRlY3J5cHRlZC5wbGFpbnRleHQpLnRvQmUocGxhaW50ZXh0KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1N5c3RlbSBUZXN0cycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcGFzcyBlbmNyeXB0aW9uIHN5c3RlbSB0ZXN0JywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGVzdEVuY3J5cHRpb24oKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIGNvcnJlY3QgZW5jcnlwdGlvbiBzdGF0dXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBzdGF0dXMgPSBnZXRFbmNyeXB0aW9uU3RhdHVzKCk7XG5cbiAgICAgIGV4cGVjdChzdGF0dXMua2V5TG9hZGVkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHN0YXR1cy52ZXJzaW9uKS50b0JlKEVOQ1JZUFRJT05fQ09OU1RBTlRTLkNVUlJFTlRfVkVSU0lPTik7XG4gICAgICBleHBlY3Qoc3RhdHVzLmFsZ29yaXRobSkudG9CZShFTkNSWVBUSU9OX0NPTlNUQU5UUy5BTEdPUklUSE0pO1xuICAgICAgZXhwZWN0KHN0YXR1cy50ZXN0UGFzc2VkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJlcG9ydCBmYWlsZWQgc3RhdHVzIHdoZW4ga2V5IGlzIG1pc3NpbmcnLCAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbEtleSA9IHByb2Nlc3MuZW52LkVOQ1JZUFRJT05fS0VZO1xuICAgICAgZGVsZXRlIHByb2Nlc3MuZW52LkVOQ1JZUFRJT05fS0VZO1xuXG4gICAgICBjb25zdCBzdGF0dXMgPSBnZXRFbmNyeXB0aW9uU3RhdHVzKCk7XG4gICAgICBleHBlY3Qoc3RhdHVzLmtleUxvYWRlZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3Qoc3RhdHVzLnRlc3RQYXNzZWQpLnRvQmUoZmFsc2UpO1xuXG4gICAgICBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWSA9IG9yaWdpbmFsS2V5O1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2VjdXJpdHkgRmVhdHVyZXMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHVzZSB1bmlxdWUgSVYgZm9yIGVhY2ggZW5jcnlwdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHBsYWludGV4dCA9ICdzYW1lIGRhdGEnO1xuICAgICAgY29uc3QgaXZzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZW5jcnlwdChwbGFpbnRleHQpO1xuICAgICAgICBpdnMuYWRkKHJlc3VsdC5pdik7XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdChpdnMuc2l6ZSkudG9CZSgxMDApOyAvLyBBbGwgSVZzIHNob3VsZCBiZSB1bmlxdWVcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBpbmNsdWRlIGF1dGhlbnRpY2F0aW9uIHRhZycsICgpID0+IHtcbiAgICAgIGNvbnN0IHBsYWludGV4dCA9ICdhdXRoZW50aWNhdGVkJztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGVuY3J5cHQocGxhaW50ZXh0KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5hdXRoVGFnKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5hdXRoVGFnLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuXG4gICAgICAvLyBWZXJpZnkgYXV0aCB0YWcgaXMgQmFzZTY0XG4gICAgICBleHBlY3QoKCkgPT4gQnVmZmVyLmZyb20ocmVzdWx0LmF1dGhUYWcsICdiYXNlNjQnKSkubm90LnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBjbGVhciBzZW5zaXRpdmUgYnVmZmVyIGRhdGEnLCAoKSA9PiB7XG4gICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbSgnc2Vuc2l0aXZlIGRhdGEnKTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsID0gQnVmZmVyLmZyb20oYnVmZmVyKTtcblxuICAgICAgY2xlYXJCdWZmZXIoYnVmZmVyKTtcblxuICAgICAgLy8gQnVmZmVyIHNob3VsZCBiZSBtb2RpZmllZFxuICAgICAgZXhwZWN0KGJ1ZmZlci5lcXVhbHMob3JpZ2luYWwpKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0VkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBlbXB0eSBzdHJpbmcgZW5jcnlwdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGVuY3J5cHQoJycpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lbmNyeXB0ZWQpLnRvQmVEZWZpbmVkKCk7XG5cbiAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGRlY3J5cHQocmVzdWx0LmVuY3J5cHRlZCwgcmVzdWx0LnZlcnNpb24pO1xuICAgICAgZXhwZWN0KGRlY3J5cHRlZC5wbGFpbnRleHQpLnRvQmUoJycpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSB2ZXJ5IGxvbmcgc3RyaW5ncycsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvbmdTdHJpbmcgPSAneCcucmVwZWF0KDEwMDAwKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGVuY3J5cHQobG9uZ1N0cmluZyk7XG4gICAgICBjb25zdCBkZWNyeXB0ZWQgPSBkZWNyeXB0KHJlc3VsdC5lbmNyeXB0ZWQsIHJlc3VsdC52ZXJzaW9uKTtcblxuICAgICAgZXhwZWN0KGRlY3J5cHRlZC5wbGFpbnRleHQpLnRvQmUobG9uZ1N0cmluZyk7XG4gICAgICBleHBlY3QoZGVjcnlwdGVkLnBsYWludGV4dC5sZW5ndGgpLnRvQmUoMTAwMDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSB1bmljb2RlIGNoYXJhY3RlcnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB1bmljb2RlID0gJ/CflJIg5pel5pys6KqeINin2YTYudix2KjZitipJztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGVuY3J5cHQodW5pY29kZSk7XG4gICAgICBjb25zdCBkZWNyeXB0ZWQgPSBkZWNyeXB0KHJlc3VsdC5lbmNyeXB0ZWQsIHJlc3VsdC52ZXJzaW9uKTtcblxuICAgICAgZXhwZWN0KGRlY3J5cHRlZC5wbGFpbnRleHQpLnRvQmUodW5pY29kZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIHNwZWNpYWwgY2hhcmFjdGVycycsICgpID0+IHtcbiAgICAgIGNvbnN0IHNwZWNpYWwgPSAnIUAjJCVeJiooKV8rLT1bXXt9fDs6XFwnXCIsLjw+Py9cXFxcYH4nO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZW5jcnlwdChzcGVjaWFsKTtcbiAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGRlY3J5cHQocmVzdWx0LmVuY3J5cHRlZCwgcmVzdWx0LnZlcnNpb24pO1xuXG4gICAgICBleHBlY3QoZGVjcnlwdGVkLnBsYWludGV4dCkudG9CZShzcGVjaWFsKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgd2hpdGVzcGFjZS1vbmx5IHN0cmluZ3MnLCAoKSA9PiB7XG4gICAgICBjb25zdCB3aGl0ZXNwYWNlID0gJyAgIFxcblxcdCAgICc7XG4gICAgICBjb25zdCByZXN1bHQgPSBlbmNyeXB0KHdoaXRlc3BhY2UpO1xuICAgICAgY29uc3QgZGVjcnlwdGVkID0gZGVjcnlwdChyZXN1bHQuZW5jcnlwdGVkLCByZXN1bHQudmVyc2lvbik7XG5cbiAgICAgIGV4cGVjdChkZWNyeXB0ZWQucGxhaW50ZXh0KS50b0JlKHdoaXRlc3BhY2UpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGVuY3J5cHQvZGVjcnlwdCB3aXRoaW4gYWNjZXB0YWJsZSB0aW1lJywgKCkgPT4ge1xuICAgICAgY29uc3QgcGxhaW50ZXh0ID0gJ3BlcmZvcm1hbmNlIHRlc3QnO1xuICAgICAgY29uc3QgaXRlcmF0aW9ucyA9IDEwMDA7XG5cbiAgICAgIGNvbnN0IHN0YXJ0RW5jcnlwdCA9IERhdGUubm93KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICBlbmNyeXB0KHBsYWludGV4dCk7XG4gICAgICB9XG4gICAgICBjb25zdCBlbmNyeXB0VGltZSA9IERhdGUubm93KCkgLSBzdGFydEVuY3J5cHQ7XG5cbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHQocGxhaW50ZXh0KTtcbiAgICAgIGNvbnN0IHN0YXJ0RGVjcnlwdCA9IERhdGUubm93KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICBkZWNyeXB0KGVuY3J5cHRlZC5lbmNyeXB0ZWQsIGVuY3J5cHRlZC52ZXJzaW9uKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlY3J5cHRUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0RGVjcnlwdDtcblxuICAgICAgY29uc29sZS5sb2coYEVuY3J5cHRpb246ICR7aXRlcmF0aW9uc30gb3BlcmF0aW9ucyBpbiAke2VuY3J5cHRUaW1lfW1zICgkeyhpdGVyYXRpb25zIC8gZW5jcnlwdFRpbWUgKiAxMDAwKS50b0ZpeGVkKDApfSBvcHMvc2VjKWApO1xuICAgICAgY29uc29sZS5sb2coYERlY3J5cHRpb246ICR7aXRlcmF0aW9uc30gb3BlcmF0aW9ucyBpbiAke2RlY3J5cHRUaW1lfW1zICgkeyhpdGVyYXRpb25zIC8gZGVjcnlwdFRpbWUgKiAxMDAwKS50b0ZpeGVkKDApfSBvcHMvc2VjKWApO1xuXG4gICAgICAvLyBTaG91bGQgYmUgcmVhc29uYWJseSBmYXN0IChhZGp1c3QgdGhyZXNob2xkcyBhcyBuZWVkZWQpXG4gICAgICBleHBlY3QoZW5jcnlwdFRpbWUpLnRvQmVMZXNzVGhhbig1MDAwKTsgLy8gNSBzZWNvbmRzIGZvciAxMDAwIGVuY3J5cHRpb25zXG4gICAgICBleHBlY3QoZGVjcnlwdFRpbWUpLnRvQmVMZXNzVGhhbig1MDAwKTsgLy8gNSBzZWNvbmRzIGZvciAxMDAwIGRlY3J5cHRpb25zXG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGJhdGNoIG9wZXJhdGlvbnMgZWZmaWNpZW50bHknLCAoKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheSgxMDApLmZpbGwoJ3Rlc3QgZGF0YScpO1xuXG4gICAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0QmF0Y2godmFsdWVzKTtcbiAgICAgIGNvbnN0IGVuY3J5cHRUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0O1xuXG4gICAgICBjb25zdCBlbmNyeXB0ZWRWYWx1ZXMgPSBlbmNyeXB0ZWQubWFwKGUgPT4gKHtcbiAgICAgICAgZGF0YTogZS5lbmNyeXB0ZWQsXG4gICAgICAgIHZlcnNpb246IGUudmVyc2lvbixcbiAgICAgIH0pKTtcblxuICAgICAgY29uc3Qgc3RhcnREZWNyeXB0ID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGRlY3J5cHRCYXRjaChlbmNyeXB0ZWRWYWx1ZXMpO1xuICAgICAgY29uc3QgZGVjcnlwdFRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnREZWNyeXB0O1xuXG4gICAgICBjb25zb2xlLmxvZyhgQmF0Y2ggZW5jcnlwdDogJHt2YWx1ZXMubGVuZ3RofSB2YWx1ZXMgaW4gJHtlbmNyeXB0VGltZX1tc2ApO1xuICAgICAgY29uc29sZS5sb2coYEJhdGNoIGRlY3J5cHQ6ICR7dmFsdWVzLmxlbmd0aH0gdmFsdWVzIGluICR7ZGVjcnlwdFRpbWV9bXNgKTtcblxuICAgICAgZXhwZWN0KGVuY3J5cHRlZCkudG9IYXZlTGVuZ3RoKDEwMCk7XG4gICAgICBleHBlY3QoZGVjcnlwdGVkKS50b0hhdmVMZW5ndGgoMTAwKTtcbiAgICAgIGV4cGVjdChlbmNyeXB0VGltZSkudG9CZUxlc3NUaGFuKDEwMDApO1xuICAgICAgZXhwZWN0KGRlY3J5cHRUaW1lKS50b0JlTGVzc1RoYW4oMTAwMCk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJvcmlnaW5hbEVudiIsInByb2Nlc3MiLCJlbnYiLCJFTkNSWVBUSU9OX0tFWSIsImJlZm9yZUFsbCIsInRlc3RLZXkiLCJjcnlwdG8iLCJyYW5kb21CeXRlcyIsInRvU3RyaW5nIiwiYWZ0ZXJBbGwiLCJ0ZXN0Iiwia2V5IiwibG9hZEVuY3J5cHRpb25LZXkiLCJleHBlY3QiLCJ0b0JlSW5zdGFuY2VPZiIsIkJ1ZmZlciIsImxlbmd0aCIsInRvQmUiLCJFTkNSWVBUSU9OX0NPTlNUQU5UUyIsIktFWV9TSVpFIiwib3JpZ2luYWxLZXkiLCJ0b1Rocm93IiwiS2V5TWFuYWdlbWVudEVycm9yIiwiZnJvbSIsIml2MSIsImdlbmVyYXRlSVYiLCJpdjIiLCJJVl9TSVpFIiwiZXF1YWxzIiwicGxhaW50ZXh0IiwicmVzdWx0IiwiZW5jcnlwdCIsInRvSGF2ZVByb3BlcnR5IiwidmVyc2lvbiIsIkNVUlJFTlRfVkVSU0lPTiIsImFsZ29yaXRobSIsIkFMR09SSVRITSIsImVuY3J5cHRlZCIsIm5vdCIsInRvQmVHcmVhdGVyVGhhbiIsImRlY3J5cHRlZCIsImRlY3J5cHQiLCJ0ZXN0Q2FzZXMiLCJyZXBlYXQiLCJ0ZXN0Q2FzZSIsInJlc3VsdDEiLCJyZXN1bHQyIiwiaXYiLCJidWZmZXIiLCJjb3JydXB0ZWQiLCJEZWNyeXB0aW9uRXJyb3IiLCJzaG9ydERhdGEiLCJ2YWxpZGF0aW9uIiwidmFsaWRhdGVFbmNyeXB0ZWREYXRhIiwidmFsaWQiLCJkZXRhaWxzIiwiaXNCYXNlNjQiLCJoYXNWYWxpZFN0cnVjdHVyZSIsImVycm9yIiwidG9CZURlZmluZWQiLCJ2YWx1ZXMiLCJyZXN1bHRzIiwiZW5jcnlwdEJhdGNoIiwidG9IYXZlTGVuZ3RoIiwiZm9yRWFjaCIsImluZGV4IiwicGxhaW50ZXh0cyIsImVuY3J5cHRlZFZhbHVlcyIsIm1hcCIsImUiLCJkYXRhIiwiZGVjcnlwdEJhdGNoIiwicmVFbmNyeXB0ZWQiLCJyZUVuY3J5cHQiLCJ0ZXN0RW5jcnlwdGlvbiIsInN0YXR1cyIsImdldEVuY3J5cHRpb25TdGF0dXMiLCJrZXlMb2FkZWQiLCJ0ZXN0UGFzc2VkIiwiaXZzIiwiU2V0IiwiaSIsImFkZCIsInNpemUiLCJhdXRoVGFnIiwib3JpZ2luYWwiLCJjbGVhckJ1ZmZlciIsImxvbmdTdHJpbmciLCJ1bmljb2RlIiwic3BlY2lhbCIsIndoaXRlc3BhY2UiLCJpdGVyYXRpb25zIiwic3RhcnRFbmNyeXB0IiwiRGF0ZSIsIm5vdyIsImVuY3J5cHRUaW1lIiwic3RhcnREZWNyeXB0IiwiZGVjcnlwdFRpbWUiLCJjb25zb2xlIiwibG9nIiwidG9GaXhlZCIsInRvQmVMZXNzVGhhbiIsIkFycmF5IiwiZmlsbCIsInN0YXJ0Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DOzs7O2dFQUV1Qjs0QkFhakI7dUJBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVQQSxTQUFTLG1CQUFtQjtJQUMxQiw0Q0FBNEM7SUFDNUMsTUFBTUMsY0FBY0MsUUFBUUMsR0FBRyxDQUFDQyxjQUFjO0lBRTlDQyxVQUFVO1FBQ1IsaUNBQWlDO1FBQ2pDLE1BQU1DLFVBQVVDLFFBQU9DLFdBQVcsQ0FBQyxJQUFJQyxRQUFRLENBQUM7UUFDaERQLFFBQVFDLEdBQUcsQ0FBQ0MsY0FBYyxHQUFHRTtJQUMvQjtJQUVBSSxTQUFTO1FBQ1AsdUJBQXVCO1FBQ3ZCLElBQUlULGFBQWE7WUFDZkMsUUFBUUMsR0FBRyxDQUFDQyxjQUFjLEdBQUdIO1FBQy9CLE9BQU87WUFDTCxPQUFPQyxRQUFRQyxHQUFHLENBQUNDLGNBQWM7UUFDbkM7SUFDRjtJQUVBSixTQUFTLGtCQUFrQjtRQUN6QlcsS0FBSywrQ0FBK0M7WUFDbEQsTUFBTUMsTUFBTUMsSUFBQUEsNkJBQWlCO1lBQzdCQyxPQUFPRixLQUFLRyxjQUFjLENBQUNDO1lBQzNCRixPQUFPRixJQUFJSyxNQUFNLEVBQUVDLElBQUksQ0FBQ0MsMkJBQW9CLENBQUNDLFFBQVE7UUFDdkQ7UUFFQVQsS0FBSyxxREFBcUQ7WUFDeEQsTUFBTVUsY0FBY25CLFFBQVFDLEdBQUcsQ0FBQ0MsY0FBYztZQUM5QyxPQUFPRixRQUFRQyxHQUFHLENBQUNDLGNBQWM7WUFFakNVLE9B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