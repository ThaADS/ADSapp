{"version":3,"sources":["C:\\Ai Projecten\\ADSapp\\tests\\unit\\encryption.test.ts"],"sourcesContent":["/**\n * Unit Tests for Encryption System\n *\n * Comprehensive test suite for the field-level encryption implementation.\n * Tests core encryption/decryption, key management, error handling, and edge cases.\n *\n * @module tests/unit/encryption\n */\n\nimport * as crypto from 'crypto';\nimport {\n  encrypt,\n  decrypt,\n  loadEncryptionKey,\n  generateIV,\n  validateEncryptedData,\n  testEncryption,\n  getEncryptionStatus,\n  encryptBatch,\n  decryptBatch,\n  reEncrypt,\n  clearBuffer,\n} from '../../src/lib/crypto/encryption';\nimport {\n  EncryptionError,\n  DecryptionError,\n  KeyManagementError,\n  ENCRYPTION_CONSTANTS,\n} from '../../src/lib/crypto/types';\n\ndescribe('Encryption Core', () => {\n  // Store original env to restore after tests\n  const originalEnv = process.env.ENCRYPTION_KEY;\n\n  beforeAll(() => {\n    // Generate a test encryption key\n    const testKey = crypto.randomBytes(32).toString('base64');\n    process.env.ENCRYPTION_KEY = testKey;\n  });\n\n  afterAll(() => {\n    // Restore original env\n    if (originalEnv) {\n      process.env.ENCRYPTION_KEY = originalEnv;\n    } else {\n      delete process.env.ENCRYPTION_KEY;\n    }\n  });\n\n  describe('Key Management', () => {\n    test('should load encryption key from environment', () => {\n      const key = loadEncryptionKey();\n      expect(key).toBeInstanceOf(Buffer);\n      expect(key.length).toBe(ENCRYPTION_CONSTANTS.KEY_SIZE);\n    });\n\n    test('should throw error when encryption key is missing', () => {\n      const originalKey = process.env.ENCRYPTION_KEY;\n      delete process.env.ENCRYPTION_KEY;\n\n      expect(() => loadEncryptionKey()).toThrow(KeyManagementError);\n      expect(() => loadEncryptionKey()).toThrow(/ENCRYPTION_KEY environment variable is not set/);\n\n      process.env.ENCRYPTION_KEY = originalKey;\n    });\n\n    test('should throw error for invalid key length', () => {\n      const originalKey = process.env.ENCRYPTION_KEY;\n      process.env.ENCRYPTION_KEY = Buffer.from('short').toString('base64');\n\n      expect(() => loadEncryptionKey()).toThrow(KeyManagementError);\n      expect(() => loadEncryptionKey()).toThrow(/Invalid key length/);\n\n      process.env.ENCRYPTION_KEY = originalKey;\n    });\n\n    test('should throw error for invalid base64 key', () => {\n      const originalKey = process.env.ENCRYPTION_KEY;\n      process.env.ENCRYPTION_KEY = 'not-valid-base64!!!';\n\n      expect(() => loadEncryptionKey()).toThrow(KeyManagementError);\n\n      process.env.ENCRYPTION_KEY = originalKey;\n    });\n\n    test('should generate cryptographically secure IV', () => {\n      const iv1 = generateIV();\n      const iv2 = generateIV();\n\n      expect(iv1).toBeInstanceOf(Buffer);\n      expect(iv1.length).toBe(ENCRYPTION_CONSTANTS.IV_SIZE);\n      expect(iv2.length).toBe(ENCRYPTION_CONSTANTS.IV_SIZE);\n      expect(iv1.equals(iv2)).toBe(false); // IVs should be unique\n    });\n  });\n\n  describe('Basic Encryption/Decryption', () => {\n    test('should encrypt plaintext successfully', () => {\n      const plaintext = 'sensitive data';\n      const result = encrypt(plaintext);\n\n      expect(result).toHaveProperty('encrypted');\n      expect(result).toHaveProperty('version');\n      expect(result).toHaveProperty('algorithm');\n      expect(result).toHaveProperty('iv');\n      expect(result).toHaveProperty('authTag');\n\n      expect(result.version).toBe(ENCRYPTION_CONSTANTS.CURRENT_VERSION);\n      expect(result.algorithm).toBe(ENCRYPTION_CONSTANTS.ALGORITHM);\n      expect(result.encrypted).not.toBe(plaintext);\n      expect(result.encrypted.length).toBeGreaterThan(0);\n    });\n\n    test('should decrypt encrypted data successfully', () => {\n      const plaintext = 'test data 123';\n      const encrypted = encrypt(plaintext);\n      const decrypted = decrypt(encrypted.encrypted, encrypted.version);\n\n      expect(decrypted.plaintext).toBe(plaintext);\n      expect(decrypted.version).toBe(encrypted.version);\n      expect(decrypted.algorithm).toBe(encrypted.algorithm);\n    });\n\n    test('should handle round-trip encryption/decryption', () => {\n      const testCases = [\n        'simple text',\n        '+1234567890',\n        'user@example.com',\n        'Complex $tring with special chars!@#',\n        'æ—¥æœ¬èªž unicode ãƒ†ã‚¹ãƒˆ',\n        ' ',\n        'a',\n        'x'.repeat(1000), // Long string\n      ];\n\n      for (const testCase of testCases) {\n        const encrypted = encrypt(testCase);\n        const decrypted = decrypt(encrypted.encrypted, encrypted.version);\n        expect(decrypted.plaintext).toBe(testCase);\n      }\n    });\n\n    test('should produce different ciphertext for same plaintext', () => {\n      const plaintext = 'same data';\n      const result1 = encrypt(plaintext);\n      const result2 = encrypt(plaintext);\n\n      // Different IVs should produce different ciphertext\n      expect(result1.iv).not.toBe(result2.iv);\n      expect(result1.encrypted).not.toBe(result2.encrypted);\n\n      // But both should decrypt to same plaintext\n      expect(decrypt(result1.encrypted, result1.version).plaintext).toBe(plaintext);\n      expect(decrypt(result2.encrypted, result2.version).plaintext).toBe(plaintext);\n    });\n  });\n\n  describe('Error Handling', () => {\n    test('should throw DecryptionError for corrupted data', () => {\n      const plaintext = 'test';\n      const encrypted = encrypt(plaintext);\n\n      // Corrupt the encrypted data\n      const buffer = Buffer.from(encrypted.encrypted, 'base64');\n      buffer[buffer.length - 1] ^= 0xFF; // Flip bits in auth tag\n      const corrupted = buffer.toString('base64');\n\n      expect(() => decrypt(corrupted, encrypted.version)).toThrow(DecryptionError);\n    });\n\n    test('should throw DecryptionError for invalid encrypted data format', () => {\n      expect(() => decrypt('invalid-data', ENCRYPTION_CONSTANTS.CURRENT_VERSION)).toThrow(\n        DecryptionError\n      );\n    });\n\n    test('should throw DecryptionError for too short data', () => {\n      const shortData = Buffer.from('abc').toString('base64');\n      expect(() => decrypt(shortData, ENCRYPTION_CONSTANTS.CURRENT_VERSION)).toThrow(\n        DecryptionError\n      );\n      expect(() => decrypt(shortData, ENCRYPTION_CONSTANTS.CURRENT_VERSION)).toThrow(\n        /too short/\n      );\n    });\n\n    test('should handle empty encryption gracefully', () => {\n      expect(() => encrypt('')).not.toThrow();\n    });\n  });\n\n  describe('Data Validation', () => {\n    test('should validate correct encrypted data structure', () => {\n      const plaintext = 'test';\n      const encrypted = encrypt(plaintext);\n      const validation = validateEncryptedData(encrypted.encrypted, encrypted.version);\n\n      expect(validation.valid).toBe(true);\n      expect(validation.details?.isBase64).toBe(true);\n      expect(validation.details?.hasValidStructure).toBe(true);\n    });\n\n    test('should reject empty encrypted data', () => {\n      const validation = validateEncryptedData('', ENCRYPTION_CONSTANTS.CURRENT_VERSION);\n      expect(validation.valid).toBe(false);\n      expect(validation.error).toBeDefined();\n    });\n\n    test('should reject invalid base64', () => {\n      const validation = validateEncryptedData('not-base64!!!', ENCRYPTION_CONSTANTS.CURRENT_VERSION);\n      expect(validation.valid).toBe(false);\n      expect(validation.details?.isBase64).toBe(false);\n    });\n\n    test('should reject data that is too short', () => {\n      const shortData = Buffer.from('abc').toString('base64');\n      const validation = validateEncryptedData(shortData, ENCRYPTION_CONSTANTS.CURRENT_VERSION);\n      expect(validation.valid).toBe(false);\n      expect(validation.details?.hasValidStructure).toBe(false);\n    });\n  });\n\n  describe('Batch Operations', () => {\n    test('should encrypt multiple values in batch', () => {\n      const values = [\n        '+1234567890',\n        'user@example.com',\n        'secret123',\n      ];\n\n      const results = encryptBatch(values);\n\n      expect(results).toHaveLength(3);\n      results.forEach((result, index) => {\n        expect(result.encrypted).toBeDefined();\n        expect(result.version).toBe(ENCRYPTION_CONSTANTS.CURRENT_VERSION);\n\n        // Verify can decrypt\n        const decrypted = decrypt(result.encrypted, result.version);\n        expect(decrypted.plaintext).toBe(values[index]);\n      });\n    });\n\n    test('should decrypt multiple values in batch', () => {\n      const plaintexts = ['data1', 'data2', 'data3'];\n      const encrypted = encryptBatch(plaintexts);\n\n      const encryptedValues = encrypted.map(e => ({\n        data: e.encrypted,\n        version: e.version,\n      }));\n\n      const decrypted = decryptBatch(encryptedValues);\n\n      expect(decrypted).toHaveLength(3);\n      decrypted.forEach((result, index) => {\n        expect(result.plaintext).toBe(plaintexts[index]);\n      });\n    });\n  });\n\n  describe('Key Rotation', () => {\n    test('should re-encrypt data with new version', () => {\n      const plaintext = 'rotate this';\n      const encrypted = encrypt(plaintext, { version: 'v1' });\n\n      const reEncrypted = reEncrypt(\n        encrypted.encrypted,\n        'v1',\n        'v2',\n        { version: 'v1' },\n        { version: 'v2' }\n      );\n\n      expect(reEncrypted.version).toBe('v2');\n      expect(reEncrypted.encrypted).not.toBe(encrypted.encrypted);\n\n      // Verify can decrypt with new version\n      const decrypted = decrypt(reEncrypted.encrypted, 'v2');\n      expect(decrypted.plaintext).toBe(plaintext);\n    });\n  });\n\n  describe('System Tests', () => {\n    test('should pass encryption system test', () => {\n      const result = testEncryption();\n      expect(result).toBe(true);\n    });\n\n    test('should return correct encryption status', () => {\n      const status = getEncryptionStatus();\n\n      expect(status.keyLoaded).toBe(true);\n      expect(status.version).toBe(ENCRYPTION_CONSTANTS.CURRENT_VERSION);\n      expect(status.algorithm).toBe(ENCRYPTION_CONSTANTS.ALGORITHM);\n      expect(status.testPassed).toBe(true);\n    });\n\n    test('should report failed status when key is missing', () => {\n      const originalKey = process.env.ENCRYPTION_KEY;\n      delete process.env.ENCRYPTION_KEY;\n\n      const status = getEncryptionStatus();\n      expect(status.keyLoaded).toBe(false);\n      expect(status.testPassed).toBe(false);\n\n      process.env.ENCRYPTION_KEY = originalKey;\n    });\n  });\n\n  describe('Security Features', () => {\n    test('should use unique IV for each encryption', () => {\n      const plaintext = 'same data';\n      const ivs = new Set<string>();\n\n      for (let i = 0; i < 100; i++) {\n        const result = encrypt(plaintext);\n        ivs.add(result.iv);\n      }\n\n      expect(ivs.size).toBe(100); // All IVs should be unique\n    });\n\n    test('should include authentication tag', () => {\n      const plaintext = 'authenticated';\n      const result = encrypt(plaintext);\n\n      expect(result.authTag).toBeDefined();\n      expect(result.authTag.length).toBeGreaterThan(0);\n\n      // Verify auth tag is Base64\n      expect(() => Buffer.from(result.authTag, 'base64')).not.toThrow();\n    });\n\n    test('should clear sensitive buffer data', () => {\n      const buffer = Buffer.from('sensitive data');\n      const original = Buffer.from(buffer);\n\n      clearBuffer(buffer);\n\n      // Buffer should be modified\n      expect(buffer.equals(original)).toBe(false);\n    });\n  });\n\n  describe('Edge Cases', () => {\n    test('should handle empty string encryption', () => {\n      const result = encrypt('');\n      expect(result.encrypted).toBeDefined();\n\n      const decrypted = decrypt(result.encrypted, result.version);\n      expect(decrypted.plaintext).toBe('');\n    });\n\n    test('should handle very long strings', () => {\n      const longString = 'x'.repeat(10000);\n      const result = encrypt(longString);\n      const decrypted = decrypt(result.encrypted, result.version);\n\n      expect(decrypted.plaintext).toBe(longString);\n      expect(decrypted.plaintext.length).toBe(10000);\n    });\n\n    test('should handle unicode characters', () => {\n      const unicode = 'ðŸ”’ æ—¥æœ¬èªž Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©';\n      const result = encrypt(unicode);\n      const decrypted = decrypt(result.encrypted, result.version);\n\n      expect(decrypted.plaintext).toBe(unicode);\n    });\n\n    test('should handle special characters', () => {\n      const special = '!@#$%^&*()_+-=[]{}|;:\\'\",.<>?/\\\\`~';\n      const result = encrypt(special);\n      const decrypted = decrypt(result.encrypted, result.version);\n\n      expect(decrypted.plaintext).toBe(special);\n    });\n\n    test('should handle whitespace-only strings', () => {\n      const whitespace = '   \\n\\t   ';\n      const result = encrypt(whitespace);\n      const decrypted = decrypt(result.encrypted, result.version);\n\n      expect(decrypted.plaintext).toBe(whitespace);\n    });\n  });\n\n  describe('Performance', () => {\n    test('should encrypt/decrypt within acceptable time', () => {\n      const plaintext = 'performance test';\n      const iterations = 1000;\n\n      const startEncrypt = Date.now();\n      for (let i = 0; i < iterations; i++) {\n        encrypt(plaintext);\n      }\n      const encryptTime = Date.now() - startEncrypt;\n\n      const encrypted = encrypt(plaintext);\n      const startDecrypt = Date.now();\n      for (let i = 0; i < iterations; i++) {\n        decrypt(encrypted.encrypted, encrypted.version);\n      }\n      const decryptTime = Date.now() - startDecrypt;\n\n      console.log(`Encryption: ${iterations} operations in ${encryptTime}ms (${(iterations / encryptTime * 1000).toFixed(0)} ops/sec)`);\n      console.log(`Decryption: ${iterations} operations in ${decryptTime}ms (${(iterations / decryptTime * 1000).toFixed(0)} ops/sec)`);\n\n      // Should be reasonably fast (adjust thresholds as needed)\n      expect(encryptTime).toBeLessThan(5000); // 5 seconds for 1000 encryptions\n      expect(decryptTime).toBeLessThan(5000); // 5 seconds for 1000 decryptions\n    });\n\n    test('should handle batch operations efficiently', () => {\n      const values = Array(100).fill('test data');\n\n      const start = Date.now();\n      const encrypted = encryptBatch(values);\n      const encryptTime = Date.now() - start;\n\n      const encryptedValues = encrypted.map(e => ({\n        data: e.encrypted,\n        version: e.version,\n      }));\n\n      const startDecrypt = Date.now();\n      const decrypted = decryptBatch(encryptedValues);\n      const decryptTime = Date.now() - startDecrypt;\n\n      console.log(`Batch encrypt: ${values.length} values in ${encryptTime}ms`);\n      console.log(`Batch decrypt: ${values.length} values in ${decryptTime}ms`);\n\n      expect(encrypted).toHaveLength(100);\n      expect(decrypted).toHaveLength(100);\n      expect(encryptTime).toBeLessThan(1000);\n      expect(decryptTime).toBeLessThan(1000);\n    });\n  });\n});\n"],"names":["describe","originalEnv","process","env","ENCRYPTION_KEY","beforeAll","testKey","crypto","randomBytes","toString","afterAll","test","key","loadEncryptionKey","expect","toBeInstanceOf","Buffer","length","toBe","ENCRYPTION_CONSTANTS","KEY_SIZE","originalKey","toThrow","KeyManagementError","from","iv1","generateIV","iv2","IV_SIZE","equals","plaintext","result","encrypt","toHaveProperty","version","CURRENT_VERSION","algorithm","ALGORITHM","encrypted","not","toBeGreaterThan","decrypted","decrypt","testCases","repeat","testCase","result1","result2","iv","buffer","corrupted","DecryptionError","shortData","validation","validateEncryptedData","valid","details","isBase64","hasValidStructure","error","toBeDefined","values","results","encryptBatch","toHaveLength","forEach","index","plaintexts","encryptedValues","map","e","data","decryptBatch","reEncrypted","reEncrypt","testEncryption","status","getEncryptionStatus","keyLoaded","testPassed","ivs","Set","i","add","size","authTag","original","clearBuffer","longString","unicode","special","whitespace","iterations","startEncrypt","Date","now","encryptTime","startDecrypt","decryptTime","console","log","toFixed","toBeLessThan","Array","fill","start"],"mappings":"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"}