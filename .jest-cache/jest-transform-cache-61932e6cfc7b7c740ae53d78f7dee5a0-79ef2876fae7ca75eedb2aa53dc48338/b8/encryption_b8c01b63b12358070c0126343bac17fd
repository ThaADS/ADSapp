94a116f89c395b10da39e8411006228a
/**
 * Core Encryption Library
 *
 * Provides low-level AES-256-GCM encryption and decryption functions
 * for field-level encryption of sensitive PII data.
 *
 * Features:
 * - AES-256-GCM encryption with authentication
 * - Secure IV generation for each encryption
 * - Key derivation from environment variables
 * - Version support for key rotation
 * - Comprehensive error handling
 * - Audit logging capabilities
 *
 * @module crypto/encryption
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get __testing__ () {
        return __testing__;
    },
    get clearBuffer () {
        return clearBuffer;
    },
    get decrypt () {
        return decrypt;
    },
    get decryptBatch () {
        return decryptBatch;
    },
    get decryptBatchWithKMS () {
        return decryptBatchWithKMS;
    },
    get decryptWithKMS () {
        return decryptWithKMS;
    },
    get encrypt () {
        return encrypt;
    },
    get encryptBatch () {
        return encryptBatch;
    },
    get encryptBatchWithKMS () {
        return encryptBatchWithKMS;
    },
    get encryptWithKMS () {
        return encryptWithKMS;
    },
    get generateIV () {
        return generateIV;
    },
    get getEncryptionConfig () {
        return getEncryptionConfig;
    },
    get getEncryptionStatus () {
        return getEncryptionStatus;
    },
    get loadEncryptionKey () {
        return loadEncryptionKey;
    },
    get loadEncryptionKeyWithKMS () {
        return loadEncryptionKeyWithKMS;
    },
    get reEncrypt () {
        return reEncrypt;
    },
    get testEncryption () {
        return testEncryption;
    },
    get validateEncryptedData () {
        return validateEncryptedData;
    }
});
const _crypto = /*#__PURE__*/ _interop_require_wildcard(require("crypto"));
const _types = require("./types");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * Default encryption configuration
 */ const DEFAULT_CONFIG = {
    algorithm: _types.ENCRYPTION_CONSTANTS.ALGORITHM,
    version: _types.ENCRYPTION_CONSTANTS.CURRENT_VERSION,
    ivLength: _types.ENCRYPTION_CONSTANTS.IV_SIZE,
    authTagLength: _types.ENCRYPTION_CONSTANTS.AUTH_TAG_SIZE
};
function loadEncryptionKey() {
    const keyBase64 = process.env.ENCRYPTION_KEY;
    if (!keyBase64) {
        throw new _types.KeyManagementError('ENCRYPTION_KEY environment variable is not set', 'MISSING_KEY', {
            hint: 'For production, use AWS KMS-managed keys. For development, run: npm run generate-encryption-key'
        });
    }
    try {
        const key = Buffer.from(keyBase64, 'base64');
        if (key.length !== _types.ENCRYPTION_CONSTANTS.KEY_SIZE) {
            throw new _types.KeyManagementError(`Invalid key length: expected ${_types.ENCRYPTION_CONSTANTS.KEY_SIZE} bytes, got ${key.length}`, 'INVALID_KEY_LENGTH', {
                expected: _types.ENCRYPTION_CONSTANTS.KEY_SIZE,
                actual: key.length
            });
        }
        return key;
    } catch (error) {
        if (error instanceof _types.KeyManagementError) {
            throw error;
        }
        throw new _types.KeyManagementError('Failed to decode encryption key from base64', 'INVALID_KEY_FORMAT', {
            originalError: error
        });
    }
}
async function loadEncryptionKeyWithKMS(tenantId) {
    // Check if KMS is configured
    const useKMS = !!process.env.AWS_KMS_KEY_ID;
    if (useKMS && tenantId) {
        // Use KMS-managed keys for production
        try {
            const { getKeyManager } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../security/key-manager")));
            const keyManager = getKeyManager();
            return await keyManager.getEncryptionKey(tenantId);
        } catch (error) {
            console.error('Failed to load KMS key, falling back to environment key:', error);
        // Fall through to legacy method
        }
    }
    // Fall back to environment variable (development/testing)
    return loadEncryptionKey();
}
function getEncryptionConfig(customConfig) {
    const key = loadEncryptionKey();
    return {
        key,
        ...DEFAULT_CONFIG,
        ...customConfig
    };
}
function generateIV(length = _types.ENCRYPTION_CONSTANTS.IV_SIZE) {
    return _crypto.randomBytes(length);
}
/**
 * Validate encryption configuration
 *
 * @param config - Configuration to validate
 * @throws {KeyManagementError} If configuration is invalid
 */ function validateConfig(config) {
    if (!config.key || config.key.length !== _types.ENCRYPTION_CONSTANTS.KEY_SIZE) {
        throw new _types.KeyManagementError('Invalid encryption key', 'INVALID_KEY', {
            keyLength: config.key?.length
        });
    }
    if (!config.version) {
        throw new _types.KeyManagementError('Version is required for key rotation support', 'MISSING_VERSION');
    }
    if (!config.algorithm) {
        throw new _types.KeyManagementError('Algorithm is required', 'MISSING_ALGORITHM');
    }
}
function encrypt(plaintext, config) {
    try {
        const fullConfig = getEncryptionConfig(config);
        validateConfig(fullConfig);
        // Generate random IV for this encryption
        const iv = generateIV(fullConfig.ivLength);
        // Create cipher
        const cipher = _crypto.createCipheriv(fullConfig.algorithm, fullConfig.key, iv, {
            authTagLength: fullConfig.authTagLength
        });
        // Encrypt the data
        let encrypted = cipher.update(plaintext, _types.ENCRYPTION_CONSTANTS.STRING_ENCODING, _types.ENCRYPTION_CONSTANTS.ENCODING);
        encrypted += cipher.final(_types.ENCRYPTION_CONSTANTS.ENCODING);
        // Get authentication tag
        const authTag = cipher.getAuthTag();
        // Combine IV + encrypted data + authTag for storage
        const combined = Buffer.concat([
            iv,
            Buffer.from(encrypted, _types.ENCRYPTION_CONSTANTS.ENCODING),
            authTag
        ]);
        const encryptedBase64 = combined.toString(_types.ENCRYPTION_CONSTANTS.ENCODING);
        return {
            encrypted: encryptedBase64,
            version: fullConfig.version,
            algorithm: fullConfig.algorithm,
            iv: iv.toString(_types.ENCRYPTION_CONSTANTS.ENCODING),
            authTag: authTag.toString(_types.ENCRYPTION_CONSTANTS.ENCODING)
        };
    } catch (error) {
        // If it's already an encryption-related error, rethrow
        if (error instanceof _types.EncryptionError || error instanceof _types.KeyManagementError) {
            throw error;
        }
        // Wrap other errors
        throw new _types.EncryptionError('Encryption failed', 'ENCRYPTION_FAILED', {
            originalError: error instanceof Error ? error.message : String(error),
            stack: error instanceof Error ? error.stack : undefined
        });
    }
}
function decrypt(encryptedData, version, config) {
    try {
        const fullConfig = getEncryptionConfig({
            ...config,
            version
        });
        validateConfig(fullConfig);
        // Decode the combined data
        const combined = Buffer.from(encryptedData, _types.ENCRYPTION_CONSTANTS.ENCODING);
        // Extract components
        const ivLength = fullConfig.ivLength || _types.ENCRYPTION_CONSTANTS.IV_SIZE;
        const authTagLength = fullConfig.authTagLength || _types.ENCRYPTION_CONSTANTS.AUTH_TAG_SIZE;
        if (combined.length < ivLength + authTagLength) {
            throw new _types.DecryptionError('Invalid encrypted data: too short', 'INVALID_DATA_LENGTH', {
                dataLength: combined.length,
                minimumLength: ivLength + authTagLength
            });
        }
        const iv = combined.subarray(0, ivLength);
        const authTag = combined.subarray(combined.length - authTagLength);
        const ciphertext = combined.subarray(ivLength, combined.length - authTagLength);
        // Create decipher
        const decipher = _crypto.createDecipheriv(fullConfig.algorithm, fullConfig.key, iv, {
            authTagLength
        });
        // Set auth tag for verification
        decipher.setAuthTag(authTag);
        // Decrypt the data
        let plaintext = decipher.update(ciphertext, undefined, _types.ENCRYPTION_CONSTANTS.STRING_ENCODING);
        plaintext += decipher.final(_types.ENCRYPTION_CONSTANTS.STRING_ENCODING);
        return {
            plaintext,
            version: fullConfig.version,
            algorithm: fullConfig.algorithm
        };
    } catch (error) {
        // If it's already a decryption-related error, rethrow
        if (error instanceof _types.DecryptionError || error instanceof _types.KeyManagementError) {
            throw error;
        }
        // Authentication tag verification failure
        if (error instanceof Error && error.message.includes('Unsupported state')) {
            throw new _types.DecryptionError('Authentication tag verification failed: data may be corrupted or tampered', 'AUTH_TAG_VERIFICATION_FAILED', {
                originalError: error.message
            });
        }
        // Wrap other errors
        throw new _types.DecryptionError('Decryption failed', 'DECRYPTION_FAILED', {
            originalError: error instanceof Error ? error.message : String(error),
            stack: error instanceof Error ? error.stack : undefined
        });
    }
}
function validateEncryptedData(encryptedData, version) {
    const result = {
        valid: true,
        details: {
            hasVersion: !!version,
            hasEncrypted: !!encryptedData,
            isBase64: false,
            hasValidStructure: false
        }
    };
    // Check if data exists
    if (!encryptedData) {
        result.valid = false;
        result.error = 'Encrypted data is empty';
        return result;
    }
    // Check if it's valid base64
    try {
        const buffer = Buffer.from(encryptedData, _types.ENCRYPTION_CONSTANTS.ENCODING);
        result.details.isBase64 = buffer.toString(_types.ENCRYPTION_CONSTANTS.ENCODING) === encryptedData;
        // Check minimum length (IV + at least 1 byte + authTag)
        const minLength = _types.ENCRYPTION_CONSTANTS.IV_SIZE + 1 + _types.ENCRYPTION_CONSTANTS.AUTH_TAG_SIZE;
        result.details.hasValidStructure = buffer.length >= minLength;
        if (!result.details.hasValidStructure) {
            result.valid = false;
            result.error = `Data too short: expected at least ${minLength} bytes, got ${buffer.length}`;
        }
    } catch (error) {
        result.valid = false;
        result.error = 'Invalid base64 encoding';
        result.details.isBase64 = false;
    }
    return result;
}
function encryptBatch(values, config) {
    return values.map((value)=>encrypt(value, config));
}
function decryptBatch(encryptedValues, config) {
    return encryptedValues.map((item)=>decrypt(item.data, item.version, config));
}
function reEncrypt(encryptedData, currentVersion, newVersion, oldConfig, newConfig) {
    // Decrypt with old key
    const decrypted = decrypt(encryptedData, currentVersion, oldConfig);
    // Encrypt with new key
    return encrypt(decrypted.plaintext, {
        ...newConfig,
        version: newVersion
    });
}
function testEncryption(testData = 'test-encryption-data') {
    try {
        const encrypted = encrypt(testData);
        const decrypted = decrypt(encrypted.encrypted, encrypted.version);
        return decrypted.plaintext === testData;
    } catch (error) {
        console.error('Encryption test failed:', error);
        return false;
    }
}
function getEncryptionStatus() {
    try {
        const config = getEncryptionConfig();
        const testPassed = testEncryption();
        return {
            keyLoaded: true,
            version: config.version,
            algorithm: config.algorithm,
            testPassed
        };
    } catch (error) {
        return {
            keyLoaded: false,
            version: 'unknown',
            algorithm: 'unknown',
            testPassed: false
        };
    }
}
function clearBuffer(buffer) {
    if (buffer && buffer.length > 0) {
        _crypto.randomFillSync(buffer);
    }
}
async function encryptWithKMS(plaintext, tenantId, config) {
    try {
        const key = await loadEncryptionKeyWithKMS(tenantId);
        return encrypt(plaintext, {
            ...config,
            key
        });
    } catch (error) {
        throw new _types.EncryptionError('KMS encryption failed', 'KMS_ENCRYPTION_FAILED', {
            tenantId,
            originalError: error instanceof Error ? error.message : String(error)
        });
    }
}
async function decryptWithKMS(encryptedData, version, tenantId, config) {
    try {
        const key = await loadEncryptionKeyWithKMS(tenantId);
        return decrypt(encryptedData, version, {
            ...config,
            key
        });
    } catch (error) {
        throw new _types.DecryptionError('KMS decryption failed', 'KMS_DECRYPTION_FAILED', {
            tenantId,
            originalError: error instanceof Error ? error.message : String(error)
        });
    }
}
async function encryptBatchWithKMS(values, tenantId, config) {
    const key = await loadEncryptionKeyWithKMS(tenantId);
    return values.map((value)=>encrypt(value, {
            ...config,
            key
        }));
}
async function decryptBatchWithKMS(encryptedValues, tenantId, config) {
    const key = await loadEncryptionKeyWithKMS(tenantId);
    return encryptedValues.map((item)=>decrypt(item.data, item.version, {
            ...config,
            key
        }));
}
const __testing__ = {
    generateIV,
    validateConfig,
    DEFAULT_CONFIG
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxBaSBQcm9qZWN0ZW5cXEFEU2FwcFxcc3JjXFxsaWJcXGNyeXB0b1xcZW5jcnlwdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcmUgRW5jcnlwdGlvbiBMaWJyYXJ5XG4gKlxuICogUHJvdmlkZXMgbG93LWxldmVsIEFFUy0yNTYtR0NNIGVuY3J5cHRpb24gYW5kIGRlY3J5cHRpb24gZnVuY3Rpb25zXG4gKiBmb3IgZmllbGQtbGV2ZWwgZW5jcnlwdGlvbiBvZiBzZW5zaXRpdmUgUElJIGRhdGEuXG4gKlxuICogRmVhdHVyZXM6XG4gKiAtIEFFUy0yNTYtR0NNIGVuY3J5cHRpb24gd2l0aCBhdXRoZW50aWNhdGlvblxuICogLSBTZWN1cmUgSVYgZ2VuZXJhdGlvbiBmb3IgZWFjaCBlbmNyeXB0aW9uXG4gKiAtIEtleSBkZXJpdmF0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKiAtIFZlcnNpb24gc3VwcG9ydCBmb3Iga2V5IHJvdGF0aW9uXG4gKiAtIENvbXByZWhlbnNpdmUgZXJyb3IgaGFuZGxpbmdcbiAqIC0gQXVkaXQgbG9nZ2luZyBjYXBhYmlsaXRpZXNcbiAqXG4gKiBAbW9kdWxlIGNyeXB0by9lbmNyeXB0aW9uXG4gKi9cblxuaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQge1xuICBFbmNyeXB0aW9uQ29uZmlnLFxuICBFbmNyeXB0aW9uUmVzdWx0LFxuICBEZWNyeXB0aW9uUmVzdWx0LFxuICBFbmNyeXB0aW9uRXJyb3IsXG4gIERlY3J5cHRpb25FcnJvcixcbiAgS2V5TWFuYWdlbWVudEVycm9yLFxuICBFTkNSWVBUSU9OX0NPTlNUQU5UUyxcbiAgVmFsaWRhdGlvblJlc3VsdCxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogRGVmYXVsdCBlbmNyeXB0aW9uIGNvbmZpZ3VyYXRpb25cbiAqL1xuY29uc3QgREVGQVVMVF9DT05GSUc6IFBhcnRpYWw8RW5jcnlwdGlvbkNvbmZpZz4gPSB7XG4gIGFsZ29yaXRobTogRU5DUllQVElPTl9DT05TVEFOVFMuQUxHT1JJVEhNLFxuICB2ZXJzaW9uOiBFTkNSWVBUSU9OX0NPTlNUQU5UUy5DVVJSRU5UX1ZFUlNJT04sXG4gIGl2TGVuZ3RoOiBFTkNSWVBUSU9OX0NPTlNUQU5UUy5JVl9TSVpFLFxuICBhdXRoVGFnTGVuZ3RoOiBFTkNSWVBUSU9OX0NPTlNUQU5UUy5BVVRIX1RBR19TSVpFLFxufTtcblxuLyoqXG4gKiBMb2FkIGVuY3J5cHRpb24ga2V5IGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGUgKGxlZ2FjeSBtZXRob2QpXG4gKiBGb3IgS01TLW1hbmFnZWQga2V5cywgdXNlIGdldEtleU1hbmFnZXIoKS5nZXRFbmNyeXB0aW9uS2V5KCkgaW5zdGVhZFxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBLTVMtbWFuYWdlZCBrZXlzIHZpYSBLZXlNYW5hZ2VyIGZvciBwcm9kdWN0aW9uXG4gKiBAdGhyb3dzIHtLZXlNYW5hZ2VtZW50RXJyb3J9IElmIEVOQ1JZUFRJT05fS0VZIGlzIG5vdCBzZXQgb3IgaW52YWxpZFxuICogQHJldHVybnMgTWFzdGVyIGVuY3J5cHRpb24ga2V5IGFzIEJ1ZmZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9hZEVuY3J5cHRpb25LZXkoKTogQnVmZmVyIHtcbiAgY29uc3Qga2V5QmFzZTY0ID0gcHJvY2Vzcy5lbnYuRU5DUllQVElPTl9LRVk7XG5cbiAgaWYgKCFrZXlCYXNlNjQpIHtcbiAgICB0aHJvdyBuZXcgS2V5TWFuYWdlbWVudEVycm9yKFxuICAgICAgJ0VOQ1JZUFRJT05fS0VZIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBzZXQnLFxuICAgICAgJ01JU1NJTkdfS0VZJyxcbiAgICAgIHtcbiAgICAgICAgaGludDogJ0ZvciBwcm9kdWN0aW9uLCB1c2UgQVdTIEtNUy1tYW5hZ2VkIGtleXMuIEZvciBkZXZlbG9wbWVudCwgcnVuOiBucG0gcnVuIGdlbmVyYXRlLWVuY3J5cHRpb24ta2V5JyxcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBrZXkgPSBCdWZmZXIuZnJvbShrZXlCYXNlNjQsICdiYXNlNjQnKTtcblxuICAgIGlmIChrZXkubGVuZ3RoICE9PSBFTkNSWVBUSU9OX0NPTlNUQU5UUy5LRVlfU0laRSkge1xuICAgICAgdGhyb3cgbmV3IEtleU1hbmFnZW1lbnRFcnJvcihcbiAgICAgICAgYEludmFsaWQga2V5IGxlbmd0aDogZXhwZWN0ZWQgJHtFTkNSWVBUSU9OX0NPTlNUQU5UUy5LRVlfU0laRX0gYnl0ZXMsIGdvdCAke2tleS5sZW5ndGh9YCxcbiAgICAgICAgJ0lOVkFMSURfS0VZX0xFTkdUSCcsXG4gICAgICAgIHsgZXhwZWN0ZWQ6IEVOQ1JZUFRJT05fQ09OU1RBTlRTLktFWV9TSVpFLCBhY3R1YWw6IGtleS5sZW5ndGggfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEtleU1hbmFnZW1lbnRFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEtleU1hbmFnZW1lbnRFcnJvcihcbiAgICAgICdGYWlsZWQgdG8gZGVjb2RlIGVuY3J5cHRpb24ga2V5IGZyb20gYmFzZTY0JyxcbiAgICAgICdJTlZBTElEX0tFWV9GT1JNQVQnLFxuICAgICAgeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9XG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIExvYWQgZW5jcnlwdGlvbiBrZXkgd2l0aCBLTVMgc3VwcG9ydFxuICogQXV0b21hdGljYWxseSB1c2VzIEtNUy1tYW5hZ2VkIGtleXMgaWYgQVdTX0tNU19LRVlfSUQgaXMgY29uZmlndXJlZCxcbiAqIG90aGVyd2lzZSBmYWxscyBiYWNrIHRvIGVudmlyb25tZW50IHZhcmlhYmxlXG4gKlxuICogQHBhcmFtIHRlbmFudElkIC0gVGVuYW50IGlkZW50aWZpZXIgZm9yIEtNUyBrZXkgcmV0cmlldmFsXG4gKiBAcmV0dXJucyBNYXN0ZXIgZW5jcnlwdGlvbiBrZXkgYXMgQnVmZmVyXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkRW5jcnlwdGlvbktleVdpdGhLTVModGVuYW50SWQ/OiBzdHJpbmcpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAvLyBDaGVjayBpZiBLTVMgaXMgY29uZmlndXJlZFxuICBjb25zdCB1c2VLTVMgPSAhIXByb2Nlc3MuZW52LkFXU19LTVNfS0VZX0lEO1xuXG4gIGlmICh1c2VLTVMgJiYgdGVuYW50SWQpIHtcbiAgICAvLyBVc2UgS01TLW1hbmFnZWQga2V5cyBmb3IgcHJvZHVjdGlvblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGdldEtleU1hbmFnZXIgfSA9IGF3YWl0IGltcG9ydCgnQC9saWIvc2VjdXJpdHkva2V5LW1hbmFnZXInKTtcbiAgICAgIGNvbnN0IGtleU1hbmFnZXIgPSBnZXRLZXlNYW5hZ2VyKCk7XG4gICAgICByZXR1cm4gYXdhaXQga2V5TWFuYWdlci5nZXRFbmNyeXB0aW9uS2V5KHRlbmFudElkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgS01TIGtleSwgZmFsbGluZyBiYWNrIHRvIGVudmlyb25tZW50IGtleTonLCBlcnJvcik7XG4gICAgICAvLyBGYWxsIHRocm91Z2ggdG8gbGVnYWN5IG1ldGhvZFxuICAgIH1cbiAgfVxuXG4gIC8vIEZhbGwgYmFjayB0byBlbnZpcm9ubWVudCB2YXJpYWJsZSAoZGV2ZWxvcG1lbnQvdGVzdGluZylcbiAgcmV0dXJuIGxvYWRFbmNyeXB0aW9uS2V5KCk7XG59XG5cbi8qKlxuICogR2V0IGVuY3J5cHRpb24gY29uZmlndXJhdGlvbiB3aXRoIGRlZmF1bHRzXG4gKlxuICogQHBhcmFtIGN1c3RvbUNvbmZpZyAtIE9wdGlvbmFsIGN1c3RvbSBjb25maWd1cmF0aW9uXG4gKiBAcmV0dXJucyBDb21wbGV0ZSBlbmNyeXB0aW9uIGNvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVuY3J5cHRpb25Db25maWcoXG4gIGN1c3RvbUNvbmZpZz86IFBhcnRpYWw8RW5jcnlwdGlvbkNvbmZpZz5cbik6IEVuY3J5cHRpb25Db25maWcge1xuICBjb25zdCBrZXkgPSBsb2FkRW5jcnlwdGlvbktleSgpO1xuXG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIC4uLkRFRkFVTFRfQ09ORklHLFxuICAgIC4uLmN1c3RvbUNvbmZpZyxcbiAgfSBhcyBFbmNyeXB0aW9uQ29uZmlnO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHJhbmRvbSBJVlxuICpcbiAqIEBwYXJhbSBsZW5ndGggLSBJViBsZW5ndGggaW4gYnl0ZXMgKGRlZmF1bHQ6IDEyIGZvciBHQ00pXG4gKiBAcmV0dXJucyBSYW5kb20gSVYgYXMgQnVmZmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUlWKGxlbmd0aDogbnVtYmVyID0gRU5DUllQVElPTl9DT05TVEFOVFMuSVZfU0laRSk6IEJ1ZmZlciB7XG4gIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMobGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBlbmNyeXB0aW9uIGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiB0byB2YWxpZGF0ZVxuICogQHRocm93cyB7S2V5TWFuYWdlbWVudEVycm9yfSBJZiBjb25maWd1cmF0aW9uIGlzIGludmFsaWRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb25maWcoY29uZmlnOiBFbmNyeXB0aW9uQ29uZmlnKTogdm9pZCB7XG4gIGlmICghY29uZmlnLmtleSB8fCBjb25maWcua2V5Lmxlbmd0aCAhPT0gRU5DUllQVElPTl9DT05TVEFOVFMuS0VZX1NJWkUpIHtcbiAgICB0aHJvdyBuZXcgS2V5TWFuYWdlbWVudEVycm9yKFxuICAgICAgJ0ludmFsaWQgZW5jcnlwdGlvbiBrZXknLFxuICAgICAgJ0lOVkFMSURfS0VZJyxcbiAgICAgIHsga2V5TGVuZ3RoOiBjb25maWcua2V5Py5sZW5ndGggfVxuICAgICk7XG4gIH1cblxuICBpZiAoIWNvbmZpZy52ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEtleU1hbmFnZW1lbnRFcnJvcihcbiAgICAgICdWZXJzaW9uIGlzIHJlcXVpcmVkIGZvciBrZXkgcm90YXRpb24gc3VwcG9ydCcsXG4gICAgICAnTUlTU0lOR19WRVJTSU9OJ1xuICAgICk7XG4gIH1cblxuICBpZiAoIWNvbmZpZy5hbGdvcml0aG0pIHtcbiAgICB0aHJvdyBuZXcgS2V5TWFuYWdlbWVudEVycm9yKFxuICAgICAgJ0FsZ29yaXRobSBpcyByZXF1aXJlZCcsXG4gICAgICAnTUlTU0lOR19BTEdPUklUSE0nXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuY3J5cHQgcGxhaW50ZXh0IHVzaW5nIEFFUy0yNTYtR0NNXG4gKlxuICogQHBhcmFtIHBsYWludGV4dCAtIERhdGEgdG8gZW5jcnlwdFxuICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIGVuY3J5cHRpb24gY29uZmlndXJhdGlvblxuICogQHJldHVybnMgRW5jcnlwdGlvbiByZXN1bHQgd2l0aCBlbmNyeXB0ZWQgZGF0YSBhbmQgbWV0YWRhdGFcbiAqIEB0aHJvd3Mge0VuY3J5cHRpb25FcnJvcn0gSWYgZW5jcnlwdGlvbiBmYWlsc1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCByZXN1bHQgPSBlbmNyeXB0KCcrMTIzNDU2Nzg5MCcpO1xuICogY29uc29sZS5sb2cocmVzdWx0LmVuY3J5cHRlZCk7IC8vIEJhc2U2NCBlbmNvZGVkIGVuY3J5cHRlZCBkYXRhXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY3J5cHQoXG4gIHBsYWludGV4dDogc3RyaW5nLFxuICBjb25maWc/OiBQYXJ0aWFsPEVuY3J5cHRpb25Db25maWc+XG4pOiBFbmNyeXB0aW9uUmVzdWx0IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmdWxsQ29uZmlnID0gZ2V0RW5jcnlwdGlvbkNvbmZpZyhjb25maWcpO1xuICAgIHZhbGlkYXRlQ29uZmlnKGZ1bGxDb25maWcpO1xuXG4gICAgLy8gR2VuZXJhdGUgcmFuZG9tIElWIGZvciB0aGlzIGVuY3J5cHRpb25cbiAgICBjb25zdCBpdiA9IGdlbmVyYXRlSVYoZnVsbENvbmZpZy5pdkxlbmd0aCk7XG5cbiAgICAvLyBDcmVhdGUgY2lwaGVyXG4gICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KFxuICAgICAgZnVsbENvbmZpZy5hbGdvcml0aG0hLFxuICAgICAgZnVsbENvbmZpZy5rZXksXG4gICAgICBpdixcbiAgICAgIHtcbiAgICAgICAgYXV0aFRhZ0xlbmd0aDogZnVsbENvbmZpZy5hdXRoVGFnTGVuZ3RoLFxuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBFbmNyeXB0IHRoZSBkYXRhXG4gICAgbGV0IGVuY3J5cHRlZCA9IGNpcGhlci51cGRhdGUoXG4gICAgICBwbGFpbnRleHQsXG4gICAgICBFTkNSWVBUSU9OX0NPTlNUQU5UUy5TVFJJTkdfRU5DT0RJTkcsXG4gICAgICBFTkNSWVBUSU9OX0NPTlNUQU5UUy5FTkNPRElOR1xuICAgICk7XG4gICAgZW5jcnlwdGVkICs9IGNpcGhlci5maW5hbChFTkNSWVBUSU9OX0NPTlNUQU5UUy5FTkNPRElORyk7XG5cbiAgICAvLyBHZXQgYXV0aGVudGljYXRpb24gdGFnXG4gICAgY29uc3QgYXV0aFRhZyA9IGNpcGhlci5nZXRBdXRoVGFnKCk7XG5cbiAgICAvLyBDb21iaW5lIElWICsgZW5jcnlwdGVkIGRhdGEgKyBhdXRoVGFnIGZvciBzdG9yYWdlXG4gICAgY29uc3QgY29tYmluZWQgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgIGl2LFxuICAgICAgQnVmZmVyLmZyb20oZW5jcnlwdGVkLCBFTkNSWVBUSU9OX0NPTlNUQU5UUy5FTkNPRElORyksXG4gICAgICBhdXRoVGFnLFxuICAgIF0pO1xuXG4gICAgY29uc3QgZW5jcnlwdGVkQmFzZTY0ID0gY29tYmluZWQudG9TdHJpbmcoRU5DUllQVElPTl9DT05TVEFOVFMuRU5DT0RJTkcpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY3J5cHRlZDogZW5jcnlwdGVkQmFzZTY0LFxuICAgICAgdmVyc2lvbjogZnVsbENvbmZpZy52ZXJzaW9uLFxuICAgICAgYWxnb3JpdGhtOiBmdWxsQ29uZmlnLmFsZ29yaXRobSEsXG4gICAgICBpdjogaXYudG9TdHJpbmcoRU5DUllQVElPTl9DT05TVEFOVFMuRU5DT0RJTkcpLFxuICAgICAgYXV0aFRhZzogYXV0aFRhZy50b1N0cmluZyhFTkNSWVBUSU9OX0NPTlNUQU5UUy5FTkNPRElORyksXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBJZiBpdCdzIGFscmVhZHkgYW4gZW5jcnlwdGlvbi1yZWxhdGVkIGVycm9yLCByZXRocm93XG4gICAgaWYgKFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFbmNyeXB0aW9uRXJyb3IgfHxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgS2V5TWFuYWdlbWVudEVycm9yXG4gICAgKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBXcmFwIG90aGVyIGVycm9yc1xuICAgIHRocm93IG5ldyBFbmNyeXB0aW9uRXJyb3IoXG4gICAgICAnRW5jcnlwdGlvbiBmYWlsZWQnLFxuICAgICAgJ0VOQ1JZUFRJT05fRkFJTEVEJyxcbiAgICAgIHtcbiAgICAgICAgb3JpZ2luYWxFcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICBzdGFjazogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogdW5kZWZpbmVkLFxuICAgICAgfVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWNyeXB0IGRhdGEgZW5jcnlwdGVkIHdpdGggQUVTLTI1Ni1HQ01cbiAqXG4gKiBAcGFyYW0gZW5jcnlwdGVkRGF0YSAtIEJhc2U2NCBlbmNvZGVkIGVuY3J5cHRlZCBkYXRhIChJViArIGNpcGhlcnRleHQgKyBhdXRoVGFnKVxuICogQHBhcmFtIHZlcnNpb24gLSBLZXkgdmVyc2lvbiB1c2VkIGZvciBlbmNyeXB0aW9uXG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgZGVjcnlwdGlvbiBjb25maWd1cmF0aW9uXG4gKiBAcmV0dXJucyBEZWNyeXB0aW9uIHJlc3VsdCB3aXRoIHBsYWludGV4dCBhbmQgbWV0YWRhdGFcbiAqIEB0aHJvd3Mge0RlY3J5cHRpb25FcnJvcn0gSWYgZGVjcnlwdGlvbiBmYWlsc1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCByZXN1bHQgPSBkZWNyeXB0KGVuY3J5cHRlZERhdGEsICd2MScpO1xuICogY29uc29sZS5sb2cocmVzdWx0LnBsYWludGV4dCk7IC8vIE9yaWdpbmFsIHBsYWludGV4dFxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNyeXB0KFxuICBlbmNyeXB0ZWREYXRhOiBzdHJpbmcsXG4gIHZlcnNpb246IHN0cmluZyxcbiAgY29uZmlnPzogUGFydGlhbDxFbmNyeXB0aW9uQ29uZmlnPlxuKTogRGVjcnlwdGlvblJlc3VsdCB7XG4gIHRyeSB7XG4gICAgY29uc3QgZnVsbENvbmZpZyA9IGdldEVuY3J5cHRpb25Db25maWcoeyAuLi5jb25maWcsIHZlcnNpb24gfSk7XG4gICAgdmFsaWRhdGVDb25maWcoZnVsbENvbmZpZyk7XG5cbiAgICAvLyBEZWNvZGUgdGhlIGNvbWJpbmVkIGRhdGFcbiAgICBjb25zdCBjb21iaW5lZCA9IEJ1ZmZlci5mcm9tKGVuY3J5cHRlZERhdGEsIEVOQ1JZUFRJT05fQ09OU1RBTlRTLkVOQ09ESU5HKTtcblxuICAgIC8vIEV4dHJhY3QgY29tcG9uZW50c1xuICAgIGNvbnN0IGl2TGVuZ3RoID0gZnVsbENvbmZpZy5pdkxlbmd0aCB8fCBFTkNSWVBUSU9OX0NPTlNUQU5UUy5JVl9TSVpFO1xuICAgIGNvbnN0IGF1dGhUYWdMZW5ndGggPSBmdWxsQ29uZmlnLmF1dGhUYWdMZW5ndGggfHwgRU5DUllQVElPTl9DT05TVEFOVFMuQVVUSF9UQUdfU0laRTtcblxuICAgIGlmIChjb21iaW5lZC5sZW5ndGggPCBpdkxlbmd0aCArIGF1dGhUYWdMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBEZWNyeXB0aW9uRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIGVuY3J5cHRlZCBkYXRhOiB0b28gc2hvcnQnLFxuICAgICAgICAnSU5WQUxJRF9EQVRBX0xFTkdUSCcsXG4gICAgICAgIHtcbiAgICAgICAgICBkYXRhTGVuZ3RoOiBjb21iaW5lZC5sZW5ndGgsXG4gICAgICAgICAgbWluaW11bUxlbmd0aDogaXZMZW5ndGggKyBhdXRoVGFnTGVuZ3RoLFxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGl2ID0gY29tYmluZWQuc3ViYXJyYXkoMCwgaXZMZW5ndGgpO1xuICAgIGNvbnN0IGF1dGhUYWcgPSBjb21iaW5lZC5zdWJhcnJheShjb21iaW5lZC5sZW5ndGggLSBhdXRoVGFnTGVuZ3RoKTtcbiAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gY29tYmluZWQuc3ViYXJyYXkoaXZMZW5ndGgsIGNvbWJpbmVkLmxlbmd0aCAtIGF1dGhUYWdMZW5ndGgpO1xuXG4gICAgLy8gQ3JlYXRlIGRlY2lwaGVyXG4gICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihcbiAgICAgIGZ1bGxDb25maWcuYWxnb3JpdGhtISxcbiAgICAgIGZ1bGxDb25maWcua2V5LFxuICAgICAgaXYsXG4gICAgICB7XG4gICAgICAgIGF1dGhUYWdMZW5ndGgsXG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIFNldCBhdXRoIHRhZyBmb3IgdmVyaWZpY2F0aW9uXG4gICAgZGVjaXBoZXIuc2V0QXV0aFRhZyhhdXRoVGFnKTtcblxuICAgIC8vIERlY3J5cHQgdGhlIGRhdGFcbiAgICBsZXQgcGxhaW50ZXh0ID0gZGVjaXBoZXIudXBkYXRlKFxuICAgICAgY2lwaGVydGV4dCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIEVOQ1JZUFRJT05fQ09OU1RBTlRTLlNUUklOR19FTkNPRElOR1xuICAgICk7XG4gICAgcGxhaW50ZXh0ICs9IGRlY2lwaGVyLmZpbmFsKEVOQ1JZUFRJT05fQ09OU1RBTlRTLlNUUklOR19FTkNPRElORyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGxhaW50ZXh0LFxuICAgICAgdmVyc2lvbjogZnVsbENvbmZpZy52ZXJzaW9uLFxuICAgICAgYWxnb3JpdGhtOiBmdWxsQ29uZmlnLmFsZ29yaXRobSEsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBJZiBpdCdzIGFscmVhZHkgYSBkZWNyeXB0aW9uLXJlbGF0ZWQgZXJyb3IsIHJldGhyb3dcbiAgICBpZiAoXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIERlY3J5cHRpb25FcnJvciB8fFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBLZXlNYW5hZ2VtZW50RXJyb3JcbiAgICApIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8vIEF1dGhlbnRpY2F0aW9uIHRhZyB2ZXJpZmljYXRpb24gZmFpbHVyZVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ1Vuc3VwcG9ydGVkIHN0YXRlJykpIHtcbiAgICAgIHRocm93IG5ldyBEZWNyeXB0aW9uRXJyb3IoXG4gICAgICAgICdBdXRoZW50aWNhdGlvbiB0YWcgdmVyaWZpY2F0aW9uIGZhaWxlZDogZGF0YSBtYXkgYmUgY29ycnVwdGVkIG9yIHRhbXBlcmVkJyxcbiAgICAgICAgJ0FVVEhfVEFHX1ZFUklGSUNBVElPTl9GQUlMRUQnLFxuICAgICAgICB7IG9yaWdpbmFsRXJyb3I6IGVycm9yLm1lc3NhZ2UgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBXcmFwIG90aGVyIGVycm9yc1xuICAgIHRocm93IG5ldyBEZWNyeXB0aW9uRXJyb3IoXG4gICAgICAnRGVjcnlwdGlvbiBmYWlsZWQnLFxuICAgICAgJ0RFQ1JZUFRJT05fRkFJTEVEJyxcbiAgICAgIHtcbiAgICAgICAgb3JpZ2luYWxFcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICBzdGFjazogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogdW5kZWZpbmVkLFxuICAgICAgfVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IGVuY3J5cHRlZCBkYXRhIGhhcyB0aGUgY29ycmVjdCBzdHJ1Y3R1cmVcbiAqXG4gKiBAcGFyYW0gZW5jcnlwdGVkRGF0YSAtIERhdGEgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gRXhwZWN0ZWQgdmVyc2lvblxuICogQHJldHVybnMgVmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRW5jcnlwdGVkRGF0YShcbiAgZW5jcnlwdGVkRGF0YTogc3RyaW5nLFxuICB2ZXJzaW9uPzogc3RyaW5nXG4pOiBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgY29uc3QgcmVzdWx0OiBWYWxpZGF0aW9uUmVzdWx0ID0ge1xuICAgIHZhbGlkOiB0cnVlLFxuICAgIGRldGFpbHM6IHtcbiAgICAgIGhhc1ZlcnNpb246ICEhdmVyc2lvbixcbiAgICAgIGhhc0VuY3J5cHRlZDogISFlbmNyeXB0ZWREYXRhLFxuICAgICAgaXNCYXNlNjQ6IGZhbHNlLFxuICAgICAgaGFzVmFsaWRTdHJ1Y3R1cmU6IGZhbHNlLFxuICAgIH0sXG4gIH07XG5cbiAgLy8gQ2hlY2sgaWYgZGF0YSBleGlzdHNcbiAgaWYgKCFlbmNyeXB0ZWREYXRhKSB7XG4gICAgcmVzdWx0LnZhbGlkID0gZmFsc2U7XG4gICAgcmVzdWx0LmVycm9yID0gJ0VuY3J5cHRlZCBkYXRhIGlzIGVtcHR5JztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgaXQncyB2YWxpZCBiYXNlNjRcbiAgdHJ5IHtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShlbmNyeXB0ZWREYXRhLCBFTkNSWVBUSU9OX0NPTlNUQU5UUy5FTkNPRElORyk7XG4gICAgcmVzdWx0LmRldGFpbHMhLmlzQmFzZTY0ID0gYnVmZmVyLnRvU3RyaW5nKEVOQ1JZUFRJT05fQ09OU1RBTlRTLkVOQ09ESU5HKSA9PT0gZW5jcnlwdGVkRGF0YTtcblxuICAgIC8vIENoZWNrIG1pbmltdW0gbGVuZ3RoIChJViArIGF0IGxlYXN0IDEgYnl0ZSArIGF1dGhUYWcpXG4gICAgY29uc3QgbWluTGVuZ3RoID0gRU5DUllQVElPTl9DT05TVEFOVFMuSVZfU0laRSArIDEgKyBFTkNSWVBUSU9OX0NPTlNUQU5UUy5BVVRIX1RBR19TSVpFO1xuICAgIHJlc3VsdC5kZXRhaWxzIS5oYXNWYWxpZFN0cnVjdHVyZSA9IGJ1ZmZlci5sZW5ndGggPj0gbWluTGVuZ3RoO1xuXG4gICAgaWYgKCFyZXN1bHQuZGV0YWlscyEuaGFzVmFsaWRTdHJ1Y3R1cmUpIHtcbiAgICAgIHJlc3VsdC52YWxpZCA9IGZhbHNlO1xuICAgICAgcmVzdWx0LmVycm9yID0gYERhdGEgdG9vIHNob3J0OiBleHBlY3RlZCBhdCBsZWFzdCAke21pbkxlbmd0aH0gYnl0ZXMsIGdvdCAke2J1ZmZlci5sZW5ndGh9YDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVzdWx0LnZhbGlkID0gZmFsc2U7XG4gICAgcmVzdWx0LmVycm9yID0gJ0ludmFsaWQgYmFzZTY0IGVuY29kaW5nJztcbiAgICByZXN1bHQuZGV0YWlscyEuaXNCYXNlNjQgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRW5jcnlwdCBtdWx0aXBsZSB2YWx1ZXMgaW4gYmF0Y2hcbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gQXJyYXkgb2YgcGxhaW50ZXh0IHZhbHVlcyB0byBlbmNyeXB0XG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgZW5jcnlwdGlvbiBjb25maWd1cmF0aW9uXG4gKiBAcmV0dXJucyBBcnJheSBvZiBlbmNyeXB0aW9uIHJlc3VsdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY3J5cHRCYXRjaChcbiAgdmFsdWVzOiBzdHJpbmdbXSxcbiAgY29uZmlnPzogUGFydGlhbDxFbmNyeXB0aW9uQ29uZmlnPlxuKTogRW5jcnlwdGlvblJlc3VsdFtdIHtcbiAgcmV0dXJuIHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBlbmNyeXB0KHZhbHVlLCBjb25maWcpKTtcbn1cblxuLyoqXG4gKiBEZWNyeXB0IG11bHRpcGxlIHZhbHVlcyBpbiBiYXRjaFxuICpcbiAqIEBwYXJhbSBlbmNyeXB0ZWRWYWx1ZXMgLSBBcnJheSBvZiBlbmNyeXB0ZWQgdmFsdWVzXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEtleSB2ZXJzaW9uIHVzZWQgZm9yIGVuY3J5cHRpb25cbiAqIEBwYXJhbSBjb25maWcgLSBPcHRpb25hbCBkZWNyeXB0aW9uIGNvbmZpZ3VyYXRpb25cbiAqIEByZXR1cm5zIEFycmF5IG9mIGRlY3J5cHRpb24gcmVzdWx0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjcnlwdEJhdGNoKFxuICBlbmNyeXB0ZWRWYWx1ZXM6IEFycmF5PHsgZGF0YTogc3RyaW5nOyB2ZXJzaW9uOiBzdHJpbmcgfT4sXG4gIGNvbmZpZz86IFBhcnRpYWw8RW5jcnlwdGlvbkNvbmZpZz5cbik6IERlY3J5cHRpb25SZXN1bHRbXSB7XG4gIHJldHVybiBlbmNyeXB0ZWRWYWx1ZXMubWFwKChpdGVtKSA9PiBkZWNyeXB0KGl0ZW0uZGF0YSwgaXRlbS52ZXJzaW9uLCBjb25maWcpKTtcbn1cblxuLyoqXG4gKiBSZS1lbmNyeXB0IGRhdGEgd2l0aCBhIG5ldyBrZXkgdmVyc2lvbiAoZm9yIGtleSByb3RhdGlvbilcbiAqXG4gKiBAcGFyYW0gZW5jcnlwdGVkRGF0YSAtIEN1cnJlbnRseSBlbmNyeXB0ZWQgZGF0YVxuICogQHBhcmFtIGN1cnJlbnRWZXJzaW9uIC0gQ3VycmVudCBrZXkgdmVyc2lvblxuICogQHBhcmFtIG5ld1ZlcnNpb24gLSBOZXcga2V5IHZlcnNpb24gdG8gdXNlXG4gKiBAcGFyYW0gb2xkQ29uZmlnIC0gQ29uZmlndXJhdGlvbiBmb3Igb2xkIGtleVxuICogQHBhcmFtIG5ld0NvbmZpZyAtIENvbmZpZ3VyYXRpb24gZm9yIG5ldyBrZXlcbiAqIEByZXR1cm5zIE5ldyBlbmNyeXB0aW9uIHJlc3VsdFxuICogQHRocm93cyB7RW5jcnlwdGlvbkVycm9yIHwgRGVjcnlwdGlvbkVycm9yfSBJZiByZS1lbmNyeXB0aW9uIGZhaWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZUVuY3J5cHQoXG4gIGVuY3J5cHRlZERhdGE6IHN0cmluZyxcbiAgY3VycmVudFZlcnNpb246IHN0cmluZyxcbiAgbmV3VmVyc2lvbjogc3RyaW5nLFxuICBvbGRDb25maWc/OiBQYXJ0aWFsPEVuY3J5cHRpb25Db25maWc+LFxuICBuZXdDb25maWc/OiBQYXJ0aWFsPEVuY3J5cHRpb25Db25maWc+XG4pOiBFbmNyeXB0aW9uUmVzdWx0IHtcbiAgLy8gRGVjcnlwdCB3aXRoIG9sZCBrZXlcbiAgY29uc3QgZGVjcnlwdGVkID0gZGVjcnlwdChlbmNyeXB0ZWREYXRhLCBjdXJyZW50VmVyc2lvbiwgb2xkQ29uZmlnKTtcblxuICAvLyBFbmNyeXB0IHdpdGggbmV3IGtleVxuICByZXR1cm4gZW5jcnlwdChkZWNyeXB0ZWQucGxhaW50ZXh0LCB7IC4uLm5ld0NvbmZpZywgdmVyc2lvbjogbmV3VmVyc2lvbiB9KTtcbn1cblxuLyoqXG4gKiBUZXN0IGVuY3J5cHRpb24vZGVjcnlwdGlvbiByb3VuZC10cmlwXG4gKlxuICogQHBhcmFtIHRlc3REYXRhIC0gVGVzdCBkYXRhIHRvIGVuY3J5cHQgYW5kIGRlY3J5cHRcbiAqIEByZXR1cm5zIFRydWUgaWYgcm91bmQtdHJpcCBzdWNjZXNzZnVsLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlc3RFbmNyeXB0aW9uKHRlc3REYXRhOiBzdHJpbmcgPSAndGVzdC1lbmNyeXB0aW9uLWRhdGEnKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZW5jcnlwdGVkID0gZW5jcnlwdCh0ZXN0RGF0YSk7XG4gICAgY29uc3QgZGVjcnlwdGVkID0gZGVjcnlwdChlbmNyeXB0ZWQuZW5jcnlwdGVkLCBlbmNyeXB0ZWQudmVyc2lvbik7XG4gICAgcmV0dXJuIGRlY3J5cHRlZC5wbGFpbnRleHQgPT09IHRlc3REYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0VuY3J5cHRpb24gdGVzdCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBlbmNyeXB0aW9uIHN5c3RlbSBzdGF0dXNcbiAqXG4gKiBAcmV0dXJucyBTdGF0dXMgaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVuY3J5cHRpb25TdGF0dXMoKToge1xuICBrZXlMb2FkZWQ6IGJvb2xlYW47XG4gIHZlcnNpb246IHN0cmluZztcbiAgYWxnb3JpdGhtOiBzdHJpbmc7XG4gIHRlc3RQYXNzZWQ6IGJvb2xlYW47XG59IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjb25maWcgPSBnZXRFbmNyeXB0aW9uQ29uZmlnKCk7XG4gICAgY29uc3QgdGVzdFBhc3NlZCA9IHRlc3RFbmNyeXB0aW9uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAga2V5TG9hZGVkOiB0cnVlLFxuICAgICAgdmVyc2lvbjogY29uZmlnLnZlcnNpb24sXG4gICAgICBhbGdvcml0aG06IGNvbmZpZy5hbGdvcml0aG0hLFxuICAgICAgdGVzdFBhc3NlZCxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlMb2FkZWQ6IGZhbHNlLFxuICAgICAgdmVyc2lvbjogJ3Vua25vd24nLFxuICAgICAgYWxnb3JpdGhtOiAndW5rbm93bicsXG4gICAgICB0ZXN0UGFzc2VkOiBmYWxzZSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ2xlYXIgc2Vuc2l0aXZlIGRhdGEgZnJvbSBtZW1vcnlcbiAqXG4gKiBAcGFyYW0gYnVmZmVyIC0gQnVmZmVyIGNvbnRhaW5pbmcgc2Vuc2l0aXZlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyQnVmZmVyKGJ1ZmZlcjogQnVmZmVyKTogdm9pZCB7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMoYnVmZmVyKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuY3J5cHQgd2l0aCBLTVMtbWFuYWdlZCBrZXkgKHJlY29tbWVuZGVkIGZvciBwcm9kdWN0aW9uKVxuICpcbiAqIEBwYXJhbSBwbGFpbnRleHQgLSBEYXRhIHRvIGVuY3J5cHRcbiAqIEBwYXJhbSB0ZW5hbnRJZCAtIFRlbmFudCBpZGVudGlmaWVyIGZvciBrZXkgcmV0cmlldmFsXG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgZW5jcnlwdGlvbiBjb25maWd1cmF0aW9uXG4gKiBAcmV0dXJucyBFbmNyeXB0aW9uIHJlc3VsdCB3aXRoIGVuY3J5cHRlZCBkYXRhIGFuZCBtZXRhZGF0YVxuICogQHRocm93cyB7RW5jcnlwdGlvbkVycm9yfSBJZiBlbmNyeXB0aW9uIGZhaWxzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNyeXB0V2l0aEtNUyhcbiAgcGxhaW50ZXh0OiBzdHJpbmcsXG4gIHRlbmFudElkOiBzdHJpbmcsXG4gIGNvbmZpZz86IFBhcnRpYWw8T21pdDxFbmNyeXB0aW9uQ29uZmlnLCAna2V5Jz4+XG4pOiBQcm9taXNlPEVuY3J5cHRpb25SZXN1bHQ+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCBsb2FkRW5jcnlwdGlvbktleVdpdGhLTVModGVuYW50SWQpO1xuICAgIHJldHVybiBlbmNyeXB0KHBsYWludGV4dCwgeyAuLi5jb25maWcsIGtleSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRW5jcnlwdGlvbkVycm9yKFxuICAgICAgJ0tNUyBlbmNyeXB0aW9uIGZhaWxlZCcsXG4gICAgICAnS01TX0VOQ1JZUFRJT05fRkFJTEVEJyxcbiAgICAgIHtcbiAgICAgICAgdGVuYW50SWQsXG4gICAgICAgIG9yaWdpbmFsRXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogRGVjcnlwdCB3aXRoIEtNUy1tYW5hZ2VkIGtleSAocmVjb21tZW5kZWQgZm9yIHByb2R1Y3Rpb24pXG4gKlxuICogQHBhcmFtIGVuY3J5cHRlZERhdGEgLSBCYXNlNjQgZW5jb2RlZCBlbmNyeXB0ZWQgZGF0YVxuICogQHBhcmFtIHZlcnNpb24gLSBLZXkgdmVyc2lvbiB1c2VkIGZvciBlbmNyeXB0aW9uXG4gKiBAcGFyYW0gdGVuYW50SWQgLSBUZW5hbnQgaWRlbnRpZmllciBmb3Iga2V5IHJldHJpZXZhbFxuICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIGRlY3J5cHRpb24gY29uZmlndXJhdGlvblxuICogQHJldHVybnMgRGVjcnlwdGlvbiByZXN1bHQgd2l0aCBwbGFpbnRleHQgYW5kIG1ldGFkYXRhXG4gKiBAdGhyb3dzIHtEZWNyeXB0aW9uRXJyb3J9IElmIGRlY3J5cHRpb24gZmFpbHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlY3J5cHRXaXRoS01TKFxuICBlbmNyeXB0ZWREYXRhOiBzdHJpbmcsXG4gIHZlcnNpb246IHN0cmluZyxcbiAgdGVuYW50SWQ6IHN0cmluZyxcbiAgY29uZmlnPzogUGFydGlhbDxPbWl0PEVuY3J5cHRpb25Db25maWcsICdrZXknPj5cbik6IFByb21pc2U8RGVjcnlwdGlvblJlc3VsdD4ge1xuICB0cnkge1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IGxvYWRFbmNyeXB0aW9uS2V5V2l0aEtNUyh0ZW5hbnRJZCk7XG4gICAgcmV0dXJuIGRlY3J5cHQoZW5jcnlwdGVkRGF0YSwgdmVyc2lvbiwgeyAuLi5jb25maWcsIGtleSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRGVjcnlwdGlvbkVycm9yKFxuICAgICAgJ0tNUyBkZWNyeXB0aW9uIGZhaWxlZCcsXG4gICAgICAnS01TX0RFQ1JZUFRJT05fRkFJTEVEJyxcbiAgICAgIHtcbiAgICAgICAgdGVuYW50SWQsXG4gICAgICAgIG9yaWdpbmFsRXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQmF0Y2ggZW5jcnlwdCB3aXRoIEtNUy1tYW5hZ2VkIGtleXNcbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gQXJyYXkgb2YgcGxhaW50ZXh0IHZhbHVlcyB0byBlbmNyeXB0XG4gKiBAcGFyYW0gdGVuYW50SWQgLSBUZW5hbnQgaWRlbnRpZmllclxuICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIGVuY3J5cHRpb24gY29uZmlndXJhdGlvblxuICogQHJldHVybnMgQXJyYXkgb2YgZW5jcnlwdGlvbiByZXN1bHRzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNyeXB0QmF0Y2hXaXRoS01TKFxuICB2YWx1ZXM6IHN0cmluZ1tdLFxuICB0ZW5hbnRJZDogc3RyaW5nLFxuICBjb25maWc/OiBQYXJ0aWFsPE9taXQ8RW5jcnlwdGlvbkNvbmZpZywgJ2tleSc+PlxuKTogUHJvbWlzZTxFbmNyeXB0aW9uUmVzdWx0W10+IHtcbiAgY29uc3Qga2V5ID0gYXdhaXQgbG9hZEVuY3J5cHRpb25LZXlXaXRoS01TKHRlbmFudElkKTtcbiAgcmV0dXJuIHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBlbmNyeXB0KHZhbHVlLCB7IC4uLmNvbmZpZywga2V5IH0pKTtcbn1cblxuLyoqXG4gKiBCYXRjaCBkZWNyeXB0IHdpdGggS01TLW1hbmFnZWQga2V5c1xuICpcbiAqIEBwYXJhbSBlbmNyeXB0ZWRWYWx1ZXMgLSBBcnJheSBvZiBlbmNyeXB0ZWQgdmFsdWVzXG4gKiBAcGFyYW0gdGVuYW50SWQgLSBUZW5hbnQgaWRlbnRpZmllclxuICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIGRlY3J5cHRpb24gY29uZmlndXJhdGlvblxuICogQHJldHVybnMgQXJyYXkgb2YgZGVjcnlwdGlvbiByZXN1bHRzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNyeXB0QmF0Y2hXaXRoS01TKFxuICBlbmNyeXB0ZWRWYWx1ZXM6IEFycmF5PHsgZGF0YTogc3RyaW5nOyB2ZXJzaW9uOiBzdHJpbmcgfT4sXG4gIHRlbmFudElkOiBzdHJpbmcsXG4gIGNvbmZpZz86IFBhcnRpYWw8T21pdDxFbmNyeXB0aW9uQ29uZmlnLCAna2V5Jz4+XG4pOiBQcm9taXNlPERlY3J5cHRpb25SZXN1bHRbXT4ge1xuICBjb25zdCBrZXkgPSBhd2FpdCBsb2FkRW5jcnlwdGlvbktleVdpdGhLTVModGVuYW50SWQpO1xuICByZXR1cm4gZW5jcnlwdGVkVmFsdWVzLm1hcCgoaXRlbSkgPT4gZGVjcnlwdChpdGVtLmRhdGEsIGl0ZW0udmVyc2lvbiwgeyAuLi5jb25maWcsIGtleSB9KSk7XG59XG5cbi8qKlxuICogRXhwb3J0IGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHlcbiAqIERPIE5PVCB1c2UgaW4gcHJvZHVjdGlvbiBjb2RlXG4gKi9cbmV4cG9ydCBjb25zdCBfX3Rlc3RpbmdfXyA9IHtcbiAgZ2VuZXJhdGVJVixcbiAgdmFsaWRhdGVDb25maWcsXG4gIERFRkFVTFRfQ09ORklHLFxufTtcbiJdLCJuYW1lcyI6WyJfX3Rlc3RpbmdfXyIsImNsZWFyQnVmZmVyIiwiZGVjcnlwdCIsImRlY3J5cHRCYXRjaCIsImRlY3J5cHRCYXRjaFdpdGhLTVMiLCJkZWNyeXB0V2l0aEtNUyIsImVuY3J5cHQiLCJlbmNyeXB0QmF0Y2giLCJlbmNyeXB0QmF0Y2hXaXRoS01TIiwiZW5jcnlwdFdpdGhLTVMiLCJnZW5lcmF0ZUlWIiwiZ2V0RW5jcnlwdGlvbkNvbmZpZyIsImdldEVuY3J5cHRpb25TdGF0dXMiLCJsb2FkRW5jcnlwdGlvbktleSIsImxvYWRFbmNyeXB0aW9uS2V5V2l0aEtNUyIsInJlRW5jcnlwdCIsInRlc3RFbmNyeXB0aW9uIiwidmFsaWRhdGVFbmNyeXB0ZWREYXRhIiwiREVGQVVMVF9DT05GSUciLCJhbGdvcml0aG0iLCJFTkNSWVBUSU9OX0NPTlNUQU5UUyIsIkFMR09SSVRITSIsInZlcnNpb24iLCJDVVJSRU5UX1ZFUlNJT04iLCJpdkxlbmd0aCIsIklWX1NJWkUiLCJhdXRoVGFnTGVuZ3RoIiwiQVVUSF9UQUdfU0laRSIsImtleUJhc2U2NCIsInByb2Nlc3MiLCJlbnYiLCJFTkNSWVBUSU9OX0tFWSIsIktleU1hbmFnZW1lbnRFcnJvciIsImhpbnQiLCJrZXkiLCJCdWZmZXIiLCJmcm9tIiwibGVuZ3RoIiwiS0VZX1NJWkUiLCJleHBlY3RlZCIsImFjdHVhbCIsImVycm9yIiwib3JpZ2luYWxFcnJvciIsInRlbmFudElkIiwidXNlS01TIiwiQVdTX0tNU19LRVlfSUQiLCJnZXRLZXlNYW5hZ2VyIiwia2V5TWFuYWdlciIsImdldEVuY3J5cHRpb25LZXkiLCJjb25zb2xlIiwiY3VzdG9tQ29uZmlnIiwiY3J5cHRvIiwicmFuZG9tQnl0ZXMiLCJ2YWxpZGF0ZUNvbmZpZyIsImNvbmZpZyIsImtleUxlbmd0aCIsInBsYWludGV4dCIsImZ1bGxDb25maWciLCJpdiIsImNpcGhlciIsImNyZWF0ZUNpcGhlcml2IiwiZW5jcnlwdGVkIiwidXBkYXRlIiwiU1RSSU5HX0VOQ09ESU5HIiwiRU5DT0RJTkciLCJmaW5hbCIsImF1dGhUYWciLCJnZXRBdXRoVGFnIiwiY29tYmluZWQiLCJjb25jYXQiLCJlbmNyeXB0ZWRCYXNlNjQiLCJ0b1N0cmluZyIsIkVuY3J5cHRpb25FcnJvciIsIkVycm9yIiwibWVzc2FnZSIsIlN0cmluZyIsInN0YWNrIiwidW5kZWZpbmVkIiwiZW5jcnlwdGVkRGF0YSIsIkRlY3J5cHRpb25FcnJvciIsImRhdGFMZW5ndGgiLCJtaW5pbXVtTGVuZ3RoIiwic3ViYXJyYXkiLCJjaXBoZXJ0ZXh0IiwiZGVjaXBoZXIiLCJjcmVhdGVEZWNpcGhlcml2Iiwic2V0QXV0aFRhZyIsImluY2x1ZGVzIiwicmVzdWx0IiwidmFsaWQiLCJkZXRhaWxzIiwiaGFzVmVyc2lvbiIsImhhc0VuY3J5cHRlZCIsImlzQmFzZTY0IiwiaGFzVmFsaWRTdHJ1Y3R1cmUiLCJidWZmZXIiLCJtaW5MZW5ndGgiLCJ2YWx1ZXMiLCJtYXAiLCJ2YWx1ZSIsImVuY3J5cHRlZFZhbHVlcyIsIml0ZW0iLCJkYXRhIiwiY3VycmVudFZlcnNpb24iLCJuZXdWZXJzaW9uIiwib2xkQ29uZmlnIiwibmV3Q29uZmlnIiwiZGVjcnlwdGVkIiwidGVzdERhdGEiLCJ0ZXN0UGFzc2VkIiwia2V5TG9hZGVkIiwicmFuZG9tRmlsbFN5bmMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQzs7Ozs7Ozs7Ozs7UUEwbEJZQTtlQUFBQTs7UUF4R0dDO2VBQUFBOztRQXBQQUM7ZUFBQUE7O1FBK0pBQztlQUFBQTs7UUFnTE1DO2VBQUFBOztRQTlDQUM7ZUFBQUE7O1FBclhOQztlQUFBQTs7UUFvT0FDO2VBQUFBOztRQThLTUM7ZUFBQUE7O1FBM0RBQztlQUFBQTs7UUF2WU5DO2VBQUFBOztRQWxCQUM7ZUFBQUE7O1FBMldBQztlQUFBQTs7UUFuYkFDO2VBQUFBOztRQThDTUM7ZUFBQUE7O1FBaVdOQztlQUFBQTs7UUFvQkFDO2VBQUFBOztRQXZHQUM7ZUFBQUE7OztnRUExVlE7dUJBVWpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFF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