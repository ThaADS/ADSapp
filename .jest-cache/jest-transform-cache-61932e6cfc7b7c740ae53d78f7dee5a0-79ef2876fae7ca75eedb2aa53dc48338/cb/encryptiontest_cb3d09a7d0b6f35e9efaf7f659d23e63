330d303088732d814f885d722435bca8
/**
 * Encryption Unit Tests
 *
 * Tests AES-256-GCM encryption/decryption, data integrity,
 * key derivation, and tenant-specific encryption contexts.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _crypto = /*#__PURE__*/ _interop_require_wildcard(require("crypto"));
const _encryption = require("../../../../src/lib/crypto/encryption");
const _types = require("../../../../src/lib/crypto/types");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('Encryption - AES-256-GCM', ()=>{
    // Set test encryption key
    const TEST_KEY = _crypto.randomBytes(_types.ENCRYPTION_CONSTANTS.KEY_SIZE);
    const TEST_KEY_BASE64 = TEST_KEY.toString('base64');
    beforeEach(()=>{
        // Set test environment variable
        process.env.ENCRYPTION_KEY = TEST_KEY_BASE64;
    });
    afterEach(()=>{
        // Clean up environment
        delete process.env.ENCRYPTION_KEY;
        jest.clearAllMocks();
    });
    describe('Encryption Operations', ()=>{
        it('should encrypt plaintext with AES-256-GCM successfully', ()=>{
            // Arrange
            const plaintext = '+1234567890'; // Sensitive phone number
            // Act
            const result = (0, _encryption.encrypt)(plaintext);
            // Assert
            expect(result).toBeDefined();
            expect(result.encrypted).toBeDefined();
            expect(typeof result.encrypted).toBe('string');
            expect(result.version).toBe(_types.ENCRYPTION_CONSTANTS.CURRENT_VERSION);
            expect(result.algorithm).toBe(_types.ENCRYPTION_CONSTANTS.ALGORITHM);
            expect(result.iv).toBeDefined();
            expect(result.authTag).toBeDefined();
            // Verify encrypted data is different from plaintext
            expect(result.encrypted).not.toContain(plaintext);
            // Verify encrypted data is valid base64
            expect(()=>Buffer.from(result.encrypted, 'base64')).not.toThrow();
        });
        it('should decrypt encrypted data back to original plaintext', ()=>{
            // Arrange
            const plaintext = 'sensitive-email@example.com';
            // Act
            const encrypted = (0, _encryption.encrypt)(plaintext);
            const decrypted = (0, _encryption.decrypt)(encrypted.encrypted, encrypted.version);
            // Assert
            expect(decrypted.plaintext).toBe(plaintext);
            expect(decrypted.version).toBe(encrypted.version);
            expect(decrypted.algorithm).toBe(encrypted.algorithm);
        });
        it('should fail authentication with corrupted ciphertext', ()=>{
            // Arrange
            const plaintext = 'secret-data';
            const encrypted = (0, _encryption.encrypt)(plaintext);
            // Corrupt the encrypted data (flip a bit in the middle)
            const buffer = Buffer.from(encrypted.encrypted, 'base64');
            buffer[buffer.length / 2] ^= 0xff;
            const corruptedData = buffer.toString('base64');
            // Act & Assert
            expect(()=>{
                (0, _encryption.decrypt)(corruptedData, encrypted.version);
            }).toThrow();
        });
    });
    describe('Data Integrity & Authentication', ()=>{
        it('should detect tampered authentication tag', ()=>{
            // Arrange
            const plaintext = 'critical-financial-data';
            const encrypted = (0, _encryption.encrypt)(plaintext);
            // Extract components
            const buffer = Buffer.from(encrypted.encrypted, 'base64');
            const ivLength = _types.ENCRYPTION_CONSTANTS.IV_SIZE;
            const authTagLength = _types.ENCRYPTION_CONSTANTS.AUTH_TAG_SIZE;
            // Tamper with the authentication tag
            const authTagStart = buffer.length - authTagLength;
            buffer[authTagStart] ^= 0xff;
            const tamperedData = buffer.toString('base64');
            // Act & Assert
            expect(()=>{
                (0, _encryption.decrypt)(tamperedData, encrypted.version);
            }).toThrow(/authentication|verification|tampered|corrupted/i);
        });
        it('should validate encrypted data structure correctly', ()=>{
            // Arrange
            const plaintext = 'test-data';
            const encrypted = (0, _encryption.encrypt)(plaintext);
            // Act
            const validationResult = (0, _encryption.validateEncryptedData)(encrypted.encrypted, encrypted.version);
            // Assert
            expect(validationResult.valid).toBe(true);
            expect(validationResult.details?.hasVersion).toBe(true);
            expect(validationResult.details?.hasEncrypted).toBe(true);
            expect(validationResult.details?.isBase64).toBe(true);
            expect(validationResult.details?.hasValidStructure).toBe(true);
            expect(validationResult.error).toBeUndefined();
        });
        it('should detect invalid encrypted data structure', ()=>{
            // Act
            const result1 = (0, _encryption.validateEncryptedData)('', 'v1');
            const result2 = (0, _encryption.validateEncryptedData)('invalid-base64!@#$', 'v1');
            const result3 = (0, _encryption.validateEncryptedData)('abc', 'v1'); // Too short
            // Assert
            expect(result1.valid).toBe(false);
            expect(result1.error).toContain('empty');
            expect(result2.valid).toBe(false);
            expect(result2.error).toContain('base64');
            expect(result3.valid).toBe(false);
            expect(result3.error).toContain('too short');
        });
    });
    describe('Batch Operations', ()=>{
        it('should encrypt multiple values in batch', ()=>{
            // Arrange
            const plaintexts = [
                'user1@example.com',
                '+1234567890',
                'Social Security Number: 123-45-6789',
                'Credit Card: 4532-1234-5678-9010'
            ];
            // Act
            const results = (0, _encryption.encryptBatch)(plaintexts);
            // Assert
            expect(results).toHaveLength(plaintexts.length);
            results.forEach((result, index)=>{
                expect(result.encrypted).toBeDefined();
                expect(result.encrypted).not.toContain(plaintexts[index]);
                expect(result.version).toBe(_types.ENCRYPTION_CONSTANTS.CURRENT_VERSION);
                // Verify each can be decrypted
                const decrypted = (0, _encryption.decrypt)(result.encrypted, result.version);
                expect(decrypted.plaintext).toBe(plaintexts[index]);
            });
        });
        it('should decrypt multiple values in batch', ()=>{
            // Arrange
            const plaintexts = [
                'value1',
                'value2',
                'value3'
            ];
            const encrypted = (0, _encryption.encryptBatch)(plaintexts);
            const encryptedValues = encrypted.map((e)=>({
                    data: e.encrypted,
                    version: e.version
                }));
            // Act
            const decrypted = (0, _encryption.decryptBatch)(encryptedValues);
            // Assert
            expect(decrypted).toHaveLength(plaintexts.length);
            decrypted.forEach((result, index)=>{
                expect(result.plaintext).toBe(plaintexts[index]);
            });
        });
    });
    describe('Key Rotation', ()=>{
        it('should re-encrypt data with new key version', ()=>{
            // Arrange
            const plaintext = 'data-to-rotate';
            const currentVersion = 'v1';
            const newVersion = 'v2';
            // Encrypt with current key
            const encrypted = (0, _encryption.encrypt)(plaintext, {
                version: currentVersion
            });
            // Create new key for v2
            const newKey = _crypto.randomBytes(_types.ENCRYPTION_CONSTANTS.KEY_SIZE);
            // Act
            const reEncrypted = (0, _encryption.reEncrypt)(encrypted.encrypted, currentVersion, newVersion, {
                key: TEST_KEY,
                version: currentVersion
            }, {
                key: newKey,
                version: newVersion
            });
            // Assert
            expect(reEncrypted.version).toBe(newVersion);
            expect(reEncrypted.encrypted).not.toBe(encrypted.encrypted);
            // Verify decryption with new key works
            const decrypted = (0, _encryption.decrypt)(reEncrypted.encrypted, newVersion, {
                key: newKey
            });
            expect(decrypted.plaintext).toBe(plaintext);
        });
    });
    describe('Encryption System Status', ()=>{
        it('should report encryption system as operational', ()=>{
            // Act
            const status = (0, _encryption.getEncryptionStatus)();
            // Assert
            expect(status.keyLoaded).toBe(true);
            expect(status.version).toBe(_types.ENCRYPTION_CONSTANTS.CURRENT_VERSION);
            expect(status.algorithm).toBe(_types.ENCRYPTION_CONSTANTS.ALGORITHM);
            expect(status.testPassed).toBe(true);
        });
        it('should pass round-trip encryption test', ()=>{
            // Arrange
            const testData = 'test-round-trip-data-12345';
            // Act
            const testResult = (0, _encryption.testEncryption)(testData);
            // Assert
            expect(testResult).toBe(true);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxBaSBQcm9qZWN0ZW5cXEFEU2FwcFxcdGVzdHNcXHVuaXRcXGxpYlxcc2VjdXJpdHlcXGVuY3J5cHRpb24udGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVuY3J5cHRpb24gVW5pdCBUZXN0c1xuICpcbiAqIFRlc3RzIEFFUy0yNTYtR0NNIGVuY3J5cHRpb24vZGVjcnlwdGlvbiwgZGF0YSBpbnRlZ3JpdHksXG4gKiBrZXkgZGVyaXZhdGlvbiwgYW5kIHRlbmFudC1zcGVjaWZpYyBlbmNyeXB0aW9uIGNvbnRleHRzLlxuICovXG5cbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHtcbiAgZW5jcnlwdCxcbiAgZGVjcnlwdCxcbiAgdmFsaWRhdGVFbmNyeXB0ZWREYXRhLFxuICBlbmNyeXB0QmF0Y2gsXG4gIGRlY3J5cHRCYXRjaCxcbiAgcmVFbmNyeXB0LFxuICB0ZXN0RW5jcnlwdGlvbixcbiAgZ2V0RW5jcnlwdGlvblN0YXR1cyxcbiAgX190ZXN0aW5nX18sXG59IGZyb20gJ0AvbGliL2NyeXB0by9lbmNyeXB0aW9uJztcbmltcG9ydCB7IEVOQ1JZUFRJT05fQ09OU1RBTlRTIH0gZnJvbSAnQC9saWIvY3J5cHRvL3R5cGVzJztcblxuZGVzY3JpYmUoJ0VuY3J5cHRpb24gLSBBRVMtMjU2LUdDTScsICgpID0+IHtcbiAgLy8gU2V0IHRlc3QgZW5jcnlwdGlvbiBrZXlcbiAgY29uc3QgVEVTVF9LRVkgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoRU5DUllQVElPTl9DT05TVEFOVFMuS0VZX1NJWkUpO1xuICBjb25zdCBURVNUX0tFWV9CQVNFNjQgPSBURVNUX0tFWS50b1N0cmluZygnYmFzZTY0Jyk7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgLy8gU2V0IHRlc3QgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgICBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWSA9IFRFU1RfS0VZX0JBU0U2NDtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAvLyBDbGVhbiB1cCBlbnZpcm9ubWVudFxuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWTtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0VuY3J5cHRpb24gT3BlcmF0aW9ucycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGVuY3J5cHQgcGxhaW50ZXh0IHdpdGggQUVTLTI1Ni1HQ00gc3VjY2Vzc2Z1bGx5JywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgcGxhaW50ZXh0ID0gJysxMjM0NTY3ODkwJzsgLy8gU2Vuc2l0aXZlIHBob25lIG51bWJlclxuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGVuY3J5cHQocGxhaW50ZXh0KTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lbmNyeXB0ZWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QodHlwZW9mIHJlc3VsdC5lbmNyeXB0ZWQpLnRvQmUoJ3N0cmluZycpO1xuICAgICAgZXhwZWN0KHJlc3VsdC52ZXJzaW9uKS50b0JlKEVOQ1JZUFRJT05fQ09OU1RBTlRTLkNVUlJFTlRfVkVSU0lPTik7XG4gICAgICBleHBlY3QocmVzdWx0LmFsZ29yaXRobSkudG9CZShFTkNSWVBUSU9OX0NPTlNUQU5UUy5BTEdPUklUSE0pO1xuICAgICAgZXhwZWN0KHJlc3VsdC5pdikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYXV0aFRhZykudG9CZURlZmluZWQoKTtcblxuICAgICAgLy8gVmVyaWZ5IGVuY3J5cHRlZCBkYXRhIGlzIGRpZmZlcmVudCBmcm9tIHBsYWludGV4dFxuICAgICAgZXhwZWN0KHJlc3VsdC5lbmNyeXB0ZWQpLm5vdC50b0NvbnRhaW4ocGxhaW50ZXh0KTtcblxuICAgICAgLy8gVmVyaWZ5IGVuY3J5cHRlZCBkYXRhIGlzIHZhbGlkIGJhc2U2NFxuICAgICAgZXhwZWN0KCgpID0+IEJ1ZmZlci5mcm9tKHJlc3VsdC5lbmNyeXB0ZWQsICdiYXNlNjQnKSkubm90LnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGVjcnlwdCBlbmNyeXB0ZWQgZGF0YSBiYWNrIHRvIG9yaWdpbmFsIHBsYWludGV4dCcsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHBsYWludGV4dCA9ICdzZW5zaXRpdmUtZW1haWxAZXhhbXBsZS5jb20nO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHQocGxhaW50ZXh0KTtcbiAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGRlY3J5cHQoZW5jcnlwdGVkLmVuY3J5cHRlZCwgZW5jcnlwdGVkLnZlcnNpb24pO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChkZWNyeXB0ZWQucGxhaW50ZXh0KS50b0JlKHBsYWludGV4dCk7XG4gICAgICBleHBlY3QoZGVjcnlwdGVkLnZlcnNpb24pLnRvQmUoZW5jcnlwdGVkLnZlcnNpb24pO1xuICAgICAgZXhwZWN0KGRlY3J5cHRlZC5hbGdvcml0aG0pLnRvQmUoZW5jcnlwdGVkLmFsZ29yaXRobSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZhaWwgYXV0aGVudGljYXRpb24gd2l0aCBjb3JydXB0ZWQgY2lwaGVydGV4dCcsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHBsYWludGV4dCA9ICdzZWNyZXQtZGF0YSc7XG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0KHBsYWludGV4dCk7XG5cbiAgICAgIC8vIENvcnJ1cHQgdGhlIGVuY3J5cHRlZCBkYXRhIChmbGlwIGEgYml0IGluIHRoZSBtaWRkbGUpXG4gICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShlbmNyeXB0ZWQuZW5jcnlwdGVkLCAnYmFzZTY0Jyk7XG4gICAgICBidWZmZXJbYnVmZmVyLmxlbmd0aCAvIDJdIF49IDB4ZmY7XG4gICAgICBjb25zdCBjb3JydXB0ZWREYXRhID0gYnVmZmVyLnRvU3RyaW5nKCdiYXNlNjQnKTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBkZWNyeXB0KGNvcnJ1cHRlZERhdGEsIGVuY3J5cHRlZC52ZXJzaW9uKTtcbiAgICAgIH0pLnRvVGhyb3coKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0RhdGEgSW50ZWdyaXR5ICYgQXV0aGVudGljYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBkZXRlY3QgdGFtcGVyZWQgYXV0aGVudGljYXRpb24gdGFnJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgcGxhaW50ZXh0ID0gJ2NyaXRpY2FsLWZpbmFuY2lhbC1kYXRhJztcbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHQocGxhaW50ZXh0KTtcblxuICAgICAgLy8gRXh0cmFjdCBjb21wb25lbnRzXG4gICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShlbmNyeXB0ZWQuZW5jcnlwdGVkLCAnYmFzZTY0Jyk7XG4gICAgICBjb25zdCBpdkxlbmd0aCA9IEVOQ1JZUFRJT05fQ09OU1RBTlRTLklWX1NJWkU7XG4gICAgICBjb25zdCBhdXRoVGFnTGVuZ3RoID0gRU5DUllQVElPTl9DT05TVEFOVFMuQVVUSF9UQUdfU0laRTtcblxuICAgICAgLy8gVGFtcGVyIHdpdGggdGhlIGF1dGhlbnRpY2F0aW9uIHRhZ1xuICAgICAgY29uc3QgYXV0aFRhZ1N0YXJ0ID0gYnVmZmVyLmxlbmd0aCAtIGF1dGhUYWdMZW5ndGg7XG4gICAgICBidWZmZXJbYXV0aFRhZ1N0YXJ0XSBePSAweGZmO1xuICAgICAgY29uc3QgdGFtcGVyZWREYXRhID0gYnVmZmVyLnRvU3RyaW5nKCdiYXNlNjQnKTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBkZWNyeXB0KHRhbXBlcmVkRGF0YSwgZW5jcnlwdGVkLnZlcnNpb24pO1xuICAgICAgfSkudG9UaHJvdygvYXV0aGVudGljYXRpb258dmVyaWZpY2F0aW9ufHRhbXBlcmVkfGNvcnJ1cHRlZC9pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgZW5jcnlwdGVkIGRhdGEgc3RydWN0dXJlIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHBsYWludGV4dCA9ICd0ZXN0LWRhdGEnO1xuICAgICAgY29uc3QgZW5jcnlwdGVkID0gZW5jcnlwdChwbGFpbnRleHQpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSB2YWxpZGF0ZUVuY3J5cHRlZERhdGEoZW5jcnlwdGVkLmVuY3J5cHRlZCwgZW5jcnlwdGVkLnZlcnNpb24pO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uUmVzdWx0LnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb25SZXN1bHQuZGV0YWlscz8uaGFzVmVyc2lvbikudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uUmVzdWx0LmRldGFpbHM/Lmhhc0VuY3J5cHRlZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uUmVzdWx0LmRldGFpbHM/LmlzQmFzZTY0KS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb25SZXN1bHQuZGV0YWlscz8uaGFzVmFsaWRTdHJ1Y3R1cmUpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvblJlc3VsdC5lcnJvcikudG9CZVVuZGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkZXRlY3QgaW52YWxpZCBlbmNyeXB0ZWQgZGF0YSBzdHJ1Y3R1cmUnLCAoKSA9PiB7XG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdDEgPSB2YWxpZGF0ZUVuY3J5cHRlZERhdGEoJycsICd2MScpO1xuICAgICAgY29uc3QgcmVzdWx0MiA9IHZhbGlkYXRlRW5jcnlwdGVkRGF0YSgnaW52YWxpZC1iYXNlNjQhQCMkJywgJ3YxJyk7XG4gICAgICBjb25zdCByZXN1bHQzID0gdmFsaWRhdGVFbmNyeXB0ZWREYXRhKCdhYmMnLCAndjEnKTsgLy8gVG9vIHNob3J0XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3VsdDEudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdDEuZXJyb3IpLnRvQ29udGFpbignZW1wdHknKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdDIudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdDIuZXJyb3IpLnRvQ29udGFpbignYmFzZTY0Jyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQzLnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQzLmVycm9yKS50b0NvbnRhaW4oJ3RvbyBzaG9ydCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQmF0Y2ggT3BlcmF0aW9ucycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGVuY3J5cHQgbXVsdGlwbGUgdmFsdWVzIGluIGJhdGNoJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgcGxhaW50ZXh0cyA9IFtcbiAgICAgICAgJ3VzZXIxQGV4YW1wbGUuY29tJyxcbiAgICAgICAgJysxMjM0NTY3ODkwJyxcbiAgICAgICAgJ1NvY2lhbCBTZWN1cml0eSBOdW1iZXI6IDEyMy00NS02Nzg5JyxcbiAgICAgICAgJ0NyZWRpdCBDYXJkOiA0NTMyLTEyMzQtNTY3OC05MDEwJyxcbiAgICAgIF07XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0cyA9IGVuY3J5cHRCYXRjaChwbGFpbnRleHRzKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzdWx0cykudG9IYXZlTGVuZ3RoKHBsYWludGV4dHMubGVuZ3RoKTtcbiAgICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0LCBpbmRleCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVuY3J5cHRlZCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lbmNyeXB0ZWQpLm5vdC50b0NvbnRhaW4ocGxhaW50ZXh0c1tpbmRleF0pO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZlcnNpb24pLnRvQmUoRU5DUllQVElPTl9DT05TVEFOVFMuQ1VSUkVOVF9WRVJTSU9OKTtcblxuICAgICAgICAvLyBWZXJpZnkgZWFjaCBjYW4gYmUgZGVjcnlwdGVkXG4gICAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGRlY3J5cHQocmVzdWx0LmVuY3J5cHRlZCwgcmVzdWx0LnZlcnNpb24pO1xuICAgICAgICBleHBlY3QoZGVjcnlwdGVkLnBsYWludGV4dCkudG9CZShwbGFpbnRleHRzW2luZGV4XSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGVjcnlwdCBtdWx0aXBsZSB2YWx1ZXMgaW4gYmF0Y2gnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBwbGFpbnRleHRzID0gWyd2YWx1ZTEnLCAndmFsdWUyJywgJ3ZhbHVlMyddO1xuICAgICAgY29uc3QgZW5jcnlwdGVkID0gZW5jcnlwdEJhdGNoKHBsYWludGV4dHMpO1xuICAgICAgY29uc3QgZW5jcnlwdGVkVmFsdWVzID0gZW5jcnlwdGVkLm1hcCgoZSkgPT4gKHtcbiAgICAgICAgZGF0YTogZS5lbmNyeXB0ZWQsXG4gICAgICAgIHZlcnNpb246IGUudmVyc2lvbixcbiAgICAgIH0pKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCBkZWNyeXB0ZWQgPSBkZWNyeXB0QmF0Y2goZW5jcnlwdGVkVmFsdWVzKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZGVjcnlwdGVkKS50b0hhdmVMZW5ndGgocGxhaW50ZXh0cy5sZW5ndGgpO1xuICAgICAgZGVjcnlwdGVkLmZvckVhY2goKHJlc3VsdCwgaW5kZXgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5wbGFpbnRleHQpLnRvQmUocGxhaW50ZXh0c1tpbmRleF0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdLZXkgUm90YXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZS1lbmNyeXB0IGRhdGEgd2l0aCBuZXcga2V5IHZlcnNpb24nLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBwbGFpbnRleHQgPSAnZGF0YS10by1yb3RhdGUnO1xuICAgICAgY29uc3QgY3VycmVudFZlcnNpb24gPSAndjEnO1xuICAgICAgY29uc3QgbmV3VmVyc2lvbiA9ICd2Mic7XG5cbiAgICAgIC8vIEVuY3J5cHQgd2l0aCBjdXJyZW50IGtleVxuICAgICAgY29uc3QgZW5jcnlwdGVkID0gZW5jcnlwdChwbGFpbnRleHQsIHsgdmVyc2lvbjogY3VycmVudFZlcnNpb24gfSk7XG5cbiAgICAgIC8vIENyZWF0ZSBuZXcga2V5IGZvciB2MlxuICAgICAgY29uc3QgbmV3S2V5ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKEVOQ1JZUFRJT05fQ09OU1RBTlRTLktFWV9TSVpFKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZUVuY3J5cHRlZCA9IHJlRW5jcnlwdChcbiAgICAgICAgZW5jcnlwdGVkLmVuY3J5cHRlZCxcbiAgICAgICAgY3VycmVudFZlcnNpb24sXG4gICAgICAgIG5ld1ZlcnNpb24sXG4gICAgICAgIHsga2V5OiBURVNUX0tFWSwgdmVyc2lvbjogY3VycmVudFZlcnNpb24gfSxcbiAgICAgICAgeyBrZXk6IG5ld0tleSwgdmVyc2lvbjogbmV3VmVyc2lvbiB9XG4gICAgICApO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZUVuY3J5cHRlZC52ZXJzaW9uKS50b0JlKG5ld1ZlcnNpb24pO1xuICAgICAgZXhwZWN0KHJlRW5jcnlwdGVkLmVuY3J5cHRlZCkubm90LnRvQmUoZW5jcnlwdGVkLmVuY3J5cHRlZCk7XG5cbiAgICAgIC8vIFZlcmlmeSBkZWNyeXB0aW9uIHdpdGggbmV3IGtleSB3b3Jrc1xuICAgICAgY29uc3QgZGVjcnlwdGVkID0gZGVjcnlwdChyZUVuY3J5cHRlZC5lbmNyeXB0ZWQsIG5ld1ZlcnNpb24sIHsga2V5OiBuZXdLZXkgfSk7XG4gICAgICBleHBlY3QoZGVjcnlwdGVkLnBsYWludGV4dCkudG9CZShwbGFpbnRleHQpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRW5jcnlwdGlvbiBTeXN0ZW0gU3RhdHVzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVwb3J0IGVuY3J5cHRpb24gc3lzdGVtIGFzIG9wZXJhdGlvbmFsJywgKCkgPT4ge1xuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCBzdGF0dXMgPSBnZXRFbmNyeXB0aW9uU3RhdHVzKCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHN0YXR1cy5rZXlMb2FkZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3Qoc3RhdHVzLnZlcnNpb24pLnRvQmUoRU5DUllQVElPTl9DT05TVEFOVFMuQ1VSUkVOVF9WRVJTSU9OKTtcbiAgICAgIGV4cGVjdChzdGF0dXMuYWxnb3JpdGhtKS50b0JlKEVOQ1JZUFRJT05fQ09OU1RBTlRTLkFMR09SSVRITSk7XG4gICAgICBleHBlY3Qoc3RhdHVzLnRlc3RQYXNzZWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHBhc3Mgcm91bmQtdHJpcCBlbmNyeXB0aW9uIHRlc3QnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0ZXN0RGF0YSA9ICd0ZXN0LXJvdW5kLXRyaXAtZGF0YS0xMjM0NSc7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgdGVzdFJlc3VsdCA9IHRlc3RFbmNyeXB0aW9uKHRlc3REYXRhKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QodGVzdFJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJkZXNjcmliZSIsIlRFU1RfS0VZIiwiY3J5cHRvIiwicmFuZG9tQnl0ZXMiLCJFTkNSWVBUSU9OX0NPTlNUQU5UUyIsIktFWV9TSVpFIiwiVEVTVF9LRVlfQkFTRTY0IiwidG9TdHJpbmciLCJiZWZvcmVFYWNoIiwicHJvY2VzcyIsImVudiIsIkVOQ1JZUFRJT05fS0VZIiwiYWZ0ZXJFYWNoIiwiamVzdCIsImNsZWFyQWxsTW9ja3MiLCJpdCIsInBsYWludGV4dCIsInJlc3VsdCIsImVuY3J5cHQiLCJleHBlY3QiLCJ0b0JlRGVmaW5lZCIsImVuY3J5cHRlZCIsInRvQmUiLCJ2ZXJzaW9uIiwiQ1VSUkVOVF9WRVJTSU9OIiwiYWxnb3JpdGhtIiwiQUxHT1JJVEhNIiwiaXYiLCJhdXRoVGFnIiwibm90IiwidG9Db250YWluIiwiQnVmZmVyIiwiZnJvbSIsInRvVGhyb3ciLCJkZWNyeXB0ZWQiLCJkZWNyeXB0IiwiYnVmZmVyIiwibGVuZ3RoIiwiY29ycnVwdGVkRGF0YSIsIml2TGVuZ3RoIiwiSVZfU0laRSIsImF1dGhUYWdMZW5ndGgiLCJBVVRIX1RBR19TSVpFIiwiYXV0aFRhZ1N0YXJ0IiwidGFtcGVyZWREYXRhIiwidmFsaWRhdGlvblJlc3VsdCIsInZhbGlkYXRlRW5jcnlwdGVkRGF0YSIsInZhbGlkIiwiZGV0YWlscyIsImhhc1ZlcnNpb24iLCJoYXNFbmNyeXB0ZWQiLCJpc0Jhc2U2NCIsImhhc1ZhbGlkU3RydWN0dXJlIiwiZXJyb3IiLCJ0b0JlVW5kZWZpbmVkIiwicmVzdWx0MSIsInJlc3VsdDIiLCJyZXN1bHQzIiwicGxhaW50ZXh0cyIsInJlc3VsdHMiLCJlbmNyeXB0QmF0Y2giLCJ0b0hhdmVMZW5ndGgiLCJmb3JFYWNoIiwiaW5kZXgiLCJlbmNyeXB0ZWRWYWx1ZXMiLCJtYXAiLCJlIiwiZGF0YSIsImRlY3J5cHRCYXRjaCIsImN1cnJlbnRWZXJzaW9uIiwibmV3VmVyc2lvbiIsIm5ld0tleSIsInJlRW5jcnlwdGVkIiwicmVFbmNyeXB0Iiwia2V5Iiwic3RhdHVzIiwiZ2V0RW5jcnlwdGlvblN0YXR1cyIsImtleUxvYWRlZCIsInRlc3RQYXNzZWQiLCJ0ZXN0RGF0YSIsInRlc3RSZXN1bHQiLCJ0ZXN0RW5jcnlwdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7Ozs7Z0VBRXVCOzRCQVdqQjt1QkFDOEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVyQ0EsU0FBUyw0QkFBNEI7SUFDbkMsMEJBQTBCO0lBQzFCLE1BQU1DLFdBQVdDLFFBQU9DLFdBQVcsQ0FBQ0MsMkJBQW9CLENBQUNDLFFBQVE7SUFDakUsTUFBTUMsa0JBQWtCTCxTQUFTTSxRQUFRLENBQUM7SUFFMUNDLFdBQVc7UUFDVCxnQ0FBZ0M7UUFDaENDLFFBQVFDLEdBQUcsQ0FBQ0MsY0FBYyxHQUFHTDtJQUMvQjtJQUVBTSxVQUFVO1FBQ1IsdUJBQXVCO1FBQ3ZCLE9BQU9ILFFBQVFDLEdBQUcsQ0FBQ0MsY0FBYztRQUNqQ0UsS0FBS0MsYUFBYTtJQUNwQjtJQUVBZCxTQUFTLHlCQUF5QjtRQUNoQ2UsR0FBRywwREFBMEQ7WUFDM0QsVUFBVTtZQUNWLE1BQU1DLFlBQVksZUFBZSx5QkFBeUI7WUFFMUQsTUFBTTtZQUNOLE1BQU1DLFNBQVNDLElBQUFBLG1CQUFPLEVBQUNGO1lBRXZCLFNBQVM7WUFDVEcsT0FBT0YsUUFBUUcsV0FBVztZQUMxQkQsT0FBT0YsT0FBT0ksU0FBUyxFQUFFRCxXQUFXO1lBQ3BDRCxPQUFPLE9BQU9GLE9BQU9JLFNBQVMsRUFBRUMsSUFBSSxDQUFDO1lBQ3JDSCxPQUFPRixPQUFPTSxPQUFPLEVBQUVE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