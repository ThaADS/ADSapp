838fc8ba6c08f97073b3f8b80d864617
/**
 * Encryption Unit Tests
 *
 * Tests AES-256-GCM encryption/decryption, data integrity,
 * key derivation, and tenant-specific encryption contexts.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _crypto = /*#__PURE__*/ _interop_require_wildcard(require("crypto"));
const _encryption = require("../../../../src/lib/crypto/encryption");
const _types = require("../../../../src/lib/crypto/types");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('Encryption - AES-256-GCM', ()=>{
    // Set test encryption key
    const TEST_KEY = _crypto.randomBytes(_types.ENCRYPTION_CONSTANTS.KEY_SIZE);
    const TEST_KEY_BASE64 = TEST_KEY.toString('base64');
    beforeEach(()=>{
        // Set test environment variable
        process.env.ENCRYPTION_KEY = TEST_KEY_BASE64;
    });
    afterEach(()=>{
        // Clean up environment
        delete process.env.ENCRYPTION_KEY;
        jest.clearAllMocks();
    });
    describe('Encryption Operations', ()=>{
        it('should encrypt plaintext with AES-256-GCM successfully', ()=>{
            // Arrange
            const plaintext = '+1234567890'; // Sensitive phone number
            // Act
            const result = (0, _encryption.encrypt)(plaintext);
            // Assert
            expect(result).toBeDefined();
            expect(result.encrypted).toBeDefined();
            expect(typeof result.encrypted).toBe('string');
            expect(result.version).toBe(_types.ENCRYPTION_CONSTANTS.CURRENT_VERSION);
            expect(result.algorithm).toBe(_types.ENCRYPTION_CONSTANTS.ALGORITHM);
            expect(result.iv).toBeDefined();
            expect(result.authTag).toBeDefined();
            // Verify encrypted data is different from plaintext
            expect(result.encrypted).not.toContain(plaintext);
            // Verify encrypted data is valid base64
            expect(()=>Buffer.from(result.encrypted, 'base64')).not.toThrow();
        });
        it('should decrypt encrypted data back to original plaintext', ()=>{
            // Arrange
            const plaintext = 'sensitive-email@example.com';
            // Act
            const encrypted = (0, _encryption.encrypt)(plaintext);
            const decrypted = (0, _encryption.decrypt)(encrypted.encrypted, encrypted.version);
            // Assert
            expect(decrypted.plaintext).toBe(plaintext);
            expect(decrypted.version).toBe(encrypted.version);
            expect(decrypted.algorithm).toBe(encrypted.algorithm);
        });
        it('should fail authentication with corrupted ciphertext', ()=>{
            // Arrange
            const plaintext = 'secret-data';
            const encrypted = (0, _encryption.encrypt)(plaintext);
            // Corrupt the encrypted data (flip a bit in the middle)
            const buffer = Buffer.from(encrypted.encrypted, 'base64');
            buffer[Math.floor(buffer.length / 2)] ^= 0xff;
            const corruptedData = buffer.toString('base64');
            // Act & Assert
            // Corrupting ciphertext causes auth tag verification to fail
            expect(()=>{
                (0, _encryption.decrypt)(corruptedData, encrypted.version);
            }).toThrow(/authentication|verification|failed|corrupted/i);
        });
    });
    describe('Data Integrity & Authentication', ()=>{
        it('should detect tampered authentication tag', ()=>{
            // Arrange
            const plaintext = 'critical-financial-data';
            const encrypted = (0, _encryption.encrypt)(plaintext);
            // Extract components
            const buffer = Buffer.from(encrypted.encrypted, 'base64');
            const ivLength = _types.ENCRYPTION_CONSTANTS.IV_SIZE;
            const authTagLength = _types.ENCRYPTION_CONSTANTS.AUTH_TAG_SIZE;
            // Tamper with the authentication tag
            const authTagStart = buffer.length - authTagLength;
            buffer[authTagStart] ^= 0xff;
            const tamperedData = buffer.toString('base64');
            // Act & Assert
            // Tampering with auth tag causes decryption to fail
            expect(()=>{
                (0, _encryption.decrypt)(tamperedData, encrypted.version);
            }).toThrow(/failed/i);
        });
        it('should validate encrypted data structure correctly', ()=>{
            // Arrange
            const plaintext = 'test-data';
            const encrypted = (0, _encryption.encrypt)(plaintext);
            // Act
            const validationResult = (0, _encryption.validateEncryptedData)(encrypted.encrypted, encrypted.version);
            // Assert
            expect(validationResult.valid).toBe(true);
            expect(validationResult.details?.hasVersion).toBe(true);
            expect(validationResult.details?.hasEncrypted).toBe(true);
            expect(validationResult.details?.isBase64).toBe(true);
            expect(validationResult.details?.hasValidStructure).toBe(true);
            expect(validationResult.error).toBeUndefined();
        });
        it('should detect invalid encrypted data structure', ()=>{
            // Act
            const result1 = (0, _encryption.validateEncryptedData)('', 'v1');
            const result2 = (0, _encryption.validateEncryptedData)('invalid-base64!@#$', 'v1');
            const result3 = (0, _encryption.validateEncryptedData)('abc', 'v1'); // Too short
            // Assert
            expect(result1.valid).toBe(false);
            expect(result1.error).toContain('empty');
            expect(result2.valid).toBe(false);
            // Invalid base64 characters still decode, but the result may be too short
            expect(result2.error).toBeDefined();
            expect(result3.valid).toBe(false);
            expect(result3.error).toContain('too short');
        });
    });
    describe('Batch Operations', ()=>{
        it('should encrypt multiple values in batch', ()=>{
            // Arrange
            const plaintexts = [
                'user1@example.com',
                '+1234567890',
                'Social Security Number: 123-45-6789',
                'Credit Card: 4532-1234-5678-9010'
            ];
            // Act
            const results = (0, _encryption.encryptBatch)(plaintexts);
            // Assert
            expect(results).toHaveLength(plaintexts.length);
            results.forEach((result, index)=>{
                expect(result.encrypted).toBeDefined();
                expect(result.encrypted).not.toContain(plaintexts[index]);
                expect(result.version).toBe(_types.ENCRYPTION_CONSTANTS.CURRENT_VERSION);
                // Verify each can be decrypted
                const decrypted = (0, _encryption.decrypt)(result.encrypted, result.version);
                expect(decrypted.plaintext).toBe(plaintexts[index]);
            });
        });
        it('should decrypt multiple values in batch', ()=>{
            // Arrange
            const plaintexts = [
                'value1',
                'value2',
                'value3'
            ];
            const encrypted = (0, _encryption.encryptBatch)(plaintexts);
            const encryptedValues = encrypted.map((e)=>({
                    data: e.encrypted,
                    version: e.version
                }));
            // Act
            const decrypted = (0, _encryption.decryptBatch)(encryptedValues);
            // Assert
            expect(decrypted).toHaveLength(plaintexts.length);
            decrypted.forEach((result, index)=>{
                expect(result.plaintext).toBe(plaintexts[index]);
            });
        });
    });
    describe('Key Rotation', ()=>{
        it('should re-encrypt data with new key version', ()=>{
            // Arrange
            const plaintext = 'data-to-rotate';
            const currentVersion = 'v1';
            const newVersion = 'v2';
            // Encrypt with current key
            const encrypted = (0, _encryption.encrypt)(plaintext, {
                version: currentVersion
            });
            // Create new key for v2
            const newKey = _crypto.randomBytes(_types.ENCRYPTION_CONSTANTS.KEY_SIZE);
            // Act
            const reEncrypted = (0, _encryption.reEncrypt)(encrypted.encrypted, currentVersion, newVersion, {
                key: TEST_KEY,
                version: currentVersion
            }, {
                key: newKey,
                version: newVersion
            });
            // Assert
            expect(reEncrypted.version).toBe(newVersion);
            expect(reEncrypted.encrypted).not.toBe(encrypted.encrypted);
            // Verify decryption with new key works
            const decrypted = (0, _encryption.decrypt)(reEncrypted.encrypted, newVersion, {
                key: newKey
            });
            expect(decrypted.plaintext).toBe(plaintext);
        });
    });
    describe('Encryption System Status', ()=>{
        it('should report encryption system as operational', ()=>{
            // Act
            const status = (0, _encryption.getEncryptionStatus)();
            // Assert
            expect(status.keyLoaded).toBe(true);
            expect(status.version).toBe(_types.ENCRYPTION_CONSTANTS.CURRENT_VERSION);
            expect(status.algorithm).toBe(_types.ENCRYPTION_CONSTANTS.ALGORITHM);
            expect(status.testPassed).toBe(true);
        });
        it('should pass round-trip encryption test', ()=>{
            // Arrange
            const testData = 'test-round-trip-data-12345';
            // Act
            const testResult = (0, _encryption.testEncryption)(testData);
            // Assert
            expect(testResult).toBe(true);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxBaSBQcm9qZWN0ZW5cXEFEU2FwcFxcdGVzdHNcXHVuaXRcXGxpYlxcc2VjdXJpdHlcXGVuY3J5cHRpb24udGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVuY3J5cHRpb24gVW5pdCBUZXN0c1xuICpcbiAqIFRlc3RzIEFFUy0yNTYtR0NNIGVuY3J5cHRpb24vZGVjcnlwdGlvbiwgZGF0YSBpbnRlZ3JpdHksXG4gKiBrZXkgZGVyaXZhdGlvbiwgYW5kIHRlbmFudC1zcGVjaWZpYyBlbmNyeXB0aW9uIGNvbnRleHRzLlxuICovXG5cbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHtcbiAgZW5jcnlwdCxcbiAgZGVjcnlwdCxcbiAgdmFsaWRhdGVFbmNyeXB0ZWREYXRhLFxuICBlbmNyeXB0QmF0Y2gsXG4gIGRlY3J5cHRCYXRjaCxcbiAgcmVFbmNyeXB0LFxuICB0ZXN0RW5jcnlwdGlvbixcbiAgZ2V0RW5jcnlwdGlvblN0YXR1cyxcbiAgX190ZXN0aW5nX18sXG59IGZyb20gJ0AvbGliL2NyeXB0by9lbmNyeXB0aW9uJztcbmltcG9ydCB7IEVOQ1JZUFRJT05fQ09OU1RBTlRTIH0gZnJvbSAnQC9saWIvY3J5cHRvL3R5cGVzJztcblxuZGVzY3JpYmUoJ0VuY3J5cHRpb24gLSBBRVMtMjU2LUdDTScsICgpID0+IHtcbiAgLy8gU2V0IHRlc3QgZW5jcnlwdGlvbiBrZXlcbiAgY29uc3QgVEVTVF9LRVkgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoRU5DUllQVElPTl9DT05TVEFOVFMuS0VZX1NJWkUpO1xuICBjb25zdCBURVNUX0tFWV9CQVNFNjQgPSBURVNUX0tFWS50b1N0cmluZygnYmFzZTY0Jyk7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgLy8gU2V0IHRlc3QgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgICBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWSA9IFRFU1RfS0VZX0JBU0U2NDtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAvLyBDbGVhbiB1cCBlbnZpcm9ubWVudFxuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWTtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0VuY3J5cHRpb24gT3BlcmF0aW9ucycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGVuY3J5cHQgcGxhaW50ZXh0IHdpdGggQUVTLTI1Ni1HQ00gc3VjY2Vzc2Z1bGx5JywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgcGxhaW50ZXh0ID0gJysxMjM0NTY3ODkwJzsgLy8gU2Vuc2l0aXZlIHBob25lIG51bWJlclxuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGVuY3J5cHQocGxhaW50ZXh0KTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lbmNyeXB0ZWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QodHlwZW9mIHJlc3VsdC5lbmNyeXB0ZWQpLnRvQmUoJ3N0cmluZycpO1xuICAgICAgZXhwZWN0KHJlc3VsdC52ZXJzaW9uKS50b0JlKEVOQ1JZUFRJT05fQ09OU1RBTlRTLkNVUlJFTlRfVkVSU0lPTik7XG4gICAgICBleHBlY3QocmVzdWx0LmFsZ29yaXRobSkudG9CZShFTkNSWVBUSU9OX0NPTlNUQU5UUy5BTEdPUklUSE0pO1xuICAgICAgZXhwZWN0KHJlc3VsdC5pdikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYXV0aFRhZykudG9CZURlZmluZWQoKTtcblxuICAgICAgLy8gVmVyaWZ5IGVuY3J5cHRlZCBkYXRhIGlzIGRpZmZlcmVudCBmcm9tIHBsYWludGV4dFxuICAgICAgZXhwZWN0KHJlc3VsdC5lbmNyeXB0ZWQpLm5vdC50b0NvbnRhaW4ocGxhaW50ZXh0KTtcblxuICAgICAgLy8gVmVyaWZ5IGVuY3J5cHRlZCBkYXRhIGlzIHZhbGlkIGJhc2U2NFxuICAgICAgZXhwZWN0KCgpID0+IEJ1ZmZlci5mcm9tKHJlc3VsdC5lbmNyeXB0ZWQsICdiYXNlNjQnKSkubm90LnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGVjcnlwdCBlbmNyeXB0ZWQgZGF0YSBiYWNrIHRvIG9yaWdpbmFsIHBsYWludGV4dCcsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHBsYWludGV4dCA9ICdzZW5zaXRpdmUtZW1haWxAZXhhbXBsZS5jb20nO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHQocGxhaW50ZXh0KTtcbiAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGRlY3J5cHQoZW5jcnlwdGVkLmVuY3J5cHRlZCwgZW5jcnlwdGVkLnZlcnNpb24pO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChkZWNyeXB0ZWQucGxhaW50ZXh0KS50b0JlKHBsYWludGV4dCk7XG4gICAgICBleHBlY3QoZGVjcnlwdGVkLnZlcnNpb24pLnRvQmUoZW5jcnlwdGVkLnZlcnNpb24pO1xuICAgICAgZXhwZWN0KGRlY3J5cHRlZC5hbGdvcml0aG0pLnRvQmUoZW5jcnlwdGVkLmFsZ29yaXRobSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZhaWwgYXV0aGVudGljYXRpb24gd2l0aCBjb3JydXB0ZWQgY2lwaGVydGV4dCcsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHBsYWludGV4dCA9ICdzZWNyZXQtZGF0YSc7XG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0KHBsYWludGV4dCk7XG5cbiAgICAgIC8vIENvcnJ1cHQgdGhlIGVuY3J5cHRlZCBkYXRhIChmbGlwIGEgYml0IGluIHRoZSBtaWRkbGUpXG4gICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShlbmNyeXB0ZWQuZW5jcnlwdGVkLCAnYmFzZTY0Jyk7XG4gICAgICBidWZmZXJbTWF0aC5mbG9vcihidWZmZXIubGVuZ3RoIC8gMildIF49IDB4ZmY7XG4gICAgICBjb25zdCBjb3JydXB0ZWREYXRhID0gYnVmZmVyLnRvU3RyaW5nKCdiYXNlNjQnKTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICAvLyBDb3JydXB0aW5nIGNpcGhlcnRleHQgY2F1c2VzIGF1dGggdGFnIHZlcmlmaWNhdGlvbiB0byBmYWlsXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBkZWNyeXB0KGNvcnJ1cHRlZERhdGEsIGVuY3J5cHRlZC52ZXJzaW9uKTtcbiAgICAgIH0pLnRvVGhyb3coL2F1dGhlbnRpY2F0aW9ufHZlcmlmaWNhdGlvbnxmYWlsZWR8Y29ycnVwdGVkL2kpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRGF0YSBJbnRlZ3JpdHkgJiBBdXRoZW50aWNhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGRldGVjdCB0YW1wZXJlZCBhdXRoZW50aWNhdGlvbiB0YWcnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBwbGFpbnRleHQgPSAnY3JpdGljYWwtZmluYW5jaWFsLWRhdGEnO1xuICAgICAgY29uc3QgZW5jcnlwdGVkID0gZW5jcnlwdChwbGFpbnRleHQpO1xuXG4gICAgICAvLyBFeHRyYWN0IGNvbXBvbmVudHNcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGVuY3J5cHRlZC5lbmNyeXB0ZWQsICdiYXNlNjQnKTtcbiAgICAgIGNvbnN0IGl2TGVuZ3RoID0gRU5DUllQVElPTl9DT05TVEFOVFMuSVZfU0laRTtcbiAgICAgIGNvbnN0IGF1dGhUYWdMZW5ndGggPSBFTkNSWVBUSU9OX0NPTlNUQU5UUy5BVVRIX1RBR19TSVpFO1xuXG4gICAgICAvLyBUYW1wZXIgd2l0aCB0aGUgYXV0aGVudGljYXRpb24gdGFnXG4gICAgICBjb25zdCBhdXRoVGFnU3RhcnQgPSBidWZmZXIubGVuZ3RoIC0gYXV0aFRhZ0xlbmd0aDtcbiAgICAgIGJ1ZmZlclthdXRoVGFnU3RhcnRdIF49IDB4ZmY7XG4gICAgICBjb25zdCB0YW1wZXJlZERhdGEgPSBidWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIC8vIFRhbXBlcmluZyB3aXRoIGF1dGggdGFnIGNhdXNlcyBkZWNyeXB0aW9uIHRvIGZhaWxcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGRlY3J5cHQodGFtcGVyZWREYXRhLCBlbmNyeXB0ZWQudmVyc2lvbik7XG4gICAgICB9KS50b1Rocm93KC9mYWlsZWQvaSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGVuY3J5cHRlZCBkYXRhIHN0cnVjdHVyZSBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBwbGFpbnRleHQgPSAndGVzdC1kYXRhJztcbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHQocGxhaW50ZXh0KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gdmFsaWRhdGVFbmNyeXB0ZWREYXRhKGVuY3J5cHRlZC5lbmNyeXB0ZWQsIGVuY3J5cHRlZC52ZXJzaW9uKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QodmFsaWRhdGlvblJlc3VsdC52YWxpZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uUmVzdWx0LmRldGFpbHM/Lmhhc1ZlcnNpb24pLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvblJlc3VsdC5kZXRhaWxzPy5oYXNFbmNyeXB0ZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvblJlc3VsdC5kZXRhaWxzPy5pc0Jhc2U2NCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uUmVzdWx0LmRldGFpbHM/Lmhhc1ZhbGlkU3RydWN0dXJlKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb25SZXN1bHQuZXJyb3IpLnRvQmVVbmRlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGV0ZWN0IGludmFsaWQgZW5jcnlwdGVkIGRhdGEgc3RydWN0dXJlJywgKCkgPT4ge1xuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQxID0gdmFsaWRhdGVFbmNyeXB0ZWREYXRhKCcnLCAndjEnKTtcbiAgICAgIGNvbnN0IHJlc3VsdDIgPSB2YWxpZGF0ZUVuY3J5cHRlZERhdGEoJ2ludmFsaWQtYmFzZTY0IUAjJCcsICd2MScpO1xuICAgICAgY29uc3QgcmVzdWx0MyA9IHZhbGlkYXRlRW5jcnlwdGVkRGF0YSgnYWJjJywgJ3YxJyk7IC8vIFRvbyBzaG9ydFxuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXN1bHQxLnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQxLmVycm9yKS50b0NvbnRhaW4oJ2VtcHR5Jyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQyLnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIC8vIEludmFsaWQgYmFzZTY0IGNoYXJhY3RlcnMgc3RpbGwgZGVjb2RlLCBidXQgdGhlIHJlc3VsdCBtYXkgYmUgdG9vIHNob3J0XG4gICAgICBleHBlY3QocmVzdWx0Mi5lcnJvcikudG9CZURlZmluZWQoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdDMudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdDMuZXJyb3IpLnRvQ29udGFpbigndG9vIHNob3J0Jyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdCYXRjaCBPcGVyYXRpb25zJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZW5jcnlwdCBtdWx0aXBsZSB2YWx1ZXMgaW4gYmF0Y2gnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBwbGFpbnRleHRzID0gW1xuICAgICAgICAndXNlcjFAZXhhbXBsZS5jb20nLFxuICAgICAgICAnKzEyMzQ1Njc4OTAnLFxuICAgICAgICAnU29jaWFsIFNlY3VyaXR5IE51bWJlcjogMTIzLTQ1LTY3ODknLFxuICAgICAgICAnQ3JlZGl0IENhcmQ6IDQ1MzItMTIzNC01Njc4LTkwMTAnLFxuICAgICAgXTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHRzID0gZW5jcnlwdEJhdGNoKHBsYWludGV4dHMpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXN1bHRzKS50b0hhdmVMZW5ndGgocGxhaW50ZXh0cy5sZW5ndGgpO1xuICAgICAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGluZGV4KSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZW5jcnlwdGVkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVuY3J5cHRlZCkubm90LnRvQ29udGFpbihwbGFpbnRleHRzW2luZGV4XSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmVyc2lvbikudG9CZShFTkNSWVBUSU9OX0NPTlNUQU5UUy5DVVJSRU5UX1ZFUlNJT04pO1xuXG4gICAgICAgIC8vIFZlcmlmeSBlYWNoIGNhbiBiZSBkZWNyeXB0ZWRcbiAgICAgICAgY29uc3QgZGVjcnlwdGVkID0gZGVjcnlwdChyZXN1bHQuZW5jcnlwdGVkLCByZXN1bHQudmVyc2lvbik7XG4gICAgICAgIGV4cGVjdChkZWNyeXB0ZWQucGxhaW50ZXh0KS50b0JlKHBsYWludGV4dHNbaW5kZXhdKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkZWNyeXB0IG11bHRpcGxlIHZhbHVlcyBpbiBiYXRjaCcsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHBsYWludGV4dHMgPSBbJ3ZhbHVlMScsICd2YWx1ZTInLCAndmFsdWUzJ107XG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0QmF0Y2gocGxhaW50ZXh0cyk7XG4gICAgICBjb25zdCBlbmNyeXB0ZWRWYWx1ZXMgPSBlbmNyeXB0ZWQubWFwKChlKSA9PiAoe1xuICAgICAgICBkYXRhOiBlLmVuY3J5cHRlZCxcbiAgICAgICAgdmVyc2lvbjogZS52ZXJzaW9uLFxuICAgICAgfSkpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGRlY3J5cHRCYXRjaChlbmNyeXB0ZWRWYWx1ZXMpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChkZWNyeXB0ZWQpLnRvSGF2ZUxlbmd0aChwbGFpbnRleHRzLmxlbmd0aCk7XG4gICAgICBkZWNyeXB0ZWQuZm9yRWFjaCgocmVzdWx0LCBpbmRleCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LnBsYWludGV4dCkudG9CZShwbGFpbnRleHRzW2luZGV4XSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0tleSBSb3RhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJlLWVuY3J5cHQgZGF0YSB3aXRoIG5ldyBrZXkgdmVyc2lvbicsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHBsYWludGV4dCA9ICdkYXRhLXRvLXJvdGF0ZSc7XG4gICAgICBjb25zdCBjdXJyZW50VmVyc2lvbiA9ICd2MSc7XG4gICAgICBjb25zdCBuZXdWZXJzaW9uID0gJ3YyJztcblxuICAgICAgLy8gRW5jcnlwdCB3aXRoIGN1cnJlbnQga2V5XG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0KHBsYWludGV4dCwgeyB2ZXJzaW9uOiBjdXJyZW50VmVyc2lvbiB9KTtcblxuICAgICAgLy8gQ3JlYXRlIG5ldyBrZXkgZm9yIHYyXG4gICAgICBjb25zdCBuZXdLZXkgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoRU5DUllQVElPTl9DT05TVEFOVFMuS0VZX1NJWkUpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlRW5jcnlwdGVkID0gcmVFbmNyeXB0KFxuICAgICAgICBlbmNyeXB0ZWQuZW5jcnlwdGVkLFxuICAgICAgICBjdXJyZW50VmVyc2lvbixcbiAgICAgICAgbmV3VmVyc2lvbixcbiAgICAgICAgeyBrZXk6IFRFU1RfS0VZLCB2ZXJzaW9uOiBjdXJyZW50VmVyc2lvbiB9LFxuICAgICAgICB7IGtleTogbmV3S2V5LCB2ZXJzaW9uOiBuZXdWZXJzaW9uIH1cbiAgICAgICk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlRW5jcnlwdGVkLnZlcnNpb24pLnRvQmUobmV3VmVyc2lvbik7XG4gICAgICBleHBlY3QocmVFbmNyeXB0ZWQuZW5jcnlwdGVkKS5ub3QudG9CZShlbmNyeXB0ZWQuZW5jcnlwdGVkKTtcblxuICAgICAgLy8gVmVyaWZ5IGRlY3J5cHRpb24gd2l0aCBuZXcga2V5IHdvcmtzXG4gICAgICBjb25zdCBkZWNyeXB0ZWQgPSBkZWNyeXB0KHJlRW5jcnlwdGVkLmVuY3J5cHRlZCwgbmV3VmVyc2lvbiwgeyBrZXk6IG5ld0tleSB9KTtcbiAgICAgIGV4cGVjdChkZWNyeXB0ZWQucGxhaW50ZXh0KS50b0JlKHBsYWludGV4dCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFbmNyeXB0aW9uIFN5c3RlbSBTdGF0dXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXBvcnQgZW5jcnlwdGlvbiBzeXN0ZW0gYXMgb3BlcmF0aW9uYWwnLCAoKSA9PiB7XG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHN0YXR1cyA9IGdldEVuY3J5cHRpb25TdGF0dXMoKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3Qoc3RhdHVzLmtleUxvYWRlZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChzdGF0dXMudmVyc2lvbikudG9CZShFTkNSWVBUSU9OX0NPTlNUQU5UUy5DVVJSRU5UX1ZFUlNJT04pO1xuICAgICAgZXhwZWN0KHN0YXR1cy5hbGdvcml0aG0pLnRvQmUoRU5DUllQVElPTl9DT05TVEFOVFMuQUxHT1JJVEhNKTtcbiAgICAgIGV4cGVjdChzdGF0dXMudGVzdFBhc3NlZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcGFzcyByb3VuZC10cmlwIGVuY3J5cHRpb24gdGVzdCcsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHRlc3REYXRhID0gJ3Rlc3Qtcm91bmQtdHJpcC1kYXRhLTEyMzQ1JztcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gdGVzdEVuY3J5cHRpb24odGVzdERhdGEpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdCh0ZXN0UmVzdWx0KS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImRlc2NyaWJlIiwiVEVTVF9LRVkiLCJjcnlwdG8iLCJyYW5kb21CeXRlcyIsIkVOQ1JZUFRJT05fQ09OU1RBTlRTIiwiS0VZX1NJWkUiLCJURVNUX0tFWV9CQVNFNjQiLCJ0b1N0cmluZyIsImJlZm9yZUVhY2giLCJwcm9jZXNzIiwiZW52IiwiRU5DUllQVElPTl9LRVkiLCJhZnRlckVhY2giLCJqZXN0IiwiY2xlYXJBbGxNb2NrcyIsIml0IiwicGxhaW50ZXh0IiwicmVzdWx0IiwiZW5jcnlwdCIsImV4cGVjdCIsInRvQmVEZWZpbmVkIiwiZW5jcnlwdGVkIiwidG9CZSIsInZlcnNpb24iLCJDVVJSRU5UX1ZFUlNJT04iLCJhbGdvcml0aG0iLCJBTEdPUklUSE0iLCJpdiIsImF1dGhUYWciLCJub3QiLCJ0b0NvbnRhaW4iLCJCdWZmZXIiLCJmcm9tIiwidG9UaHJvdyIsImRlY3J5cHRlZCIsImRlY3J5cHQiLCJidWZmZXIiLCJNYXRoIiwiZmxvb3IiLCJsZW5ndGgiLCJjb3JydXB0ZWREYXRhIiwiaXZMZW5ndGgiLCJJVl9TSVpFIiwiYXV0aFRhZ0xlbmd0aCIsIkFVVEhfVEFHX1NJWkUiLCJhdXRoVGFnU3RhcnQiLCJ0YW1wZXJlZERhdGEiLCJ2YWxpZGF0aW9uUmVzdWx0IiwidmFsaWRhdGVFbmNyeXB0ZWREYXRhIiwidmFsaWQiLCJkZXRhaWxzIiwiaGFzVmVyc2lvbiIsImhhc0VuY3J5cHRlZCIsImlzQmFzZTY0IiwiaGFzVmFsaWRTdHJ1Y3R1cmUiLCJlcnJvciIsInRvQmVVbmRlZmluZWQiLCJyZXN1bHQxIiwicmVzdWx0MiIsInJlc3VsdDMiLCJwbGFpbnRleHRzIiwicmVzdWx0cyIsImVuY3J5cHRCYXRjaCIsInRvSGF2ZUxlbmd0aCIsImZvckVhY2giLCJpbmRleCIsImVuY3J5cHRlZFZhbHVlcyIsIm1hcCIsImUiLCJkYXRhIiwiZGVjcnlwdEJhdGNoIiwiY3VycmVudFZlcnNpb24iLCJuZXdWZXJzaW9uIiwibmV3S2V5IiwicmVFbmNyeXB0ZWQiLCJyZUVuY3J5cHQiLCJrZXkiLCJzdGF0dXMiLCJnZXRFbmNyeXB0aW9uU3RhdHVzIiwia2V5TG9hZGVkIiwidGVzdFBhc3NlZCIsInRlc3REYXRhIiwidGVzdFJlc3VsdCIsInRlc3RFbmNyeXB0aW9uIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQzs7OztnRUFFdUI7NEJBV2pCO3VCQUM4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRXJDQSxTQUFTLDRCQUE0QjtJQUNuQywwQkFBMEI7SUFDMUIsTUFBTUMsV0FBV0MsUUFBT0MsV0FBVyxDQUFDQywyQkFBb0IsQ0FBQ0MsUUFBUTtJQUNqRSxNQUFNQyxrQkFBa0JMLFNBQVNNLFFBQVEsQ0FBQztJQUUxQ0MsV0FBVztRQUNULGdDQUFnQztRQUNoQ0MsUUFBUUMsR0FBRyxDQUFDQyxjQUFjLEdBQUdMO0lBQy9CO0lBRUFNLFVBQVU7UUFDUix1QkFBdUI7UUFDdkIsT0FBT0gsUUFBUUMsR0FBRyxDQUFDQyxjQUFjO1FBQ2pDRSxLQUFLQyxhQUFhO0lBQ3BCO0lBRUFkLFNBQVMseUJBQXlCO1FBQ2hDZSxH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