c956a3e5366a007ef705c4c0956b2654
/**
 * Integration Tests for Encryption Flow
 *
 * End-to-end tests for field-level encryption integrated with
 * the database, API routes, and business logic.
 *
 * @module tests/integration/encryption-flow
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _crypto = /*#__PURE__*/ _interop_require_wildcard(require("crypto"));
const _fieldencryptor = require("../../src/lib/crypto/field-encryptor");
const _dbhelpers = require("../../src/lib/crypto/db-helpers");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('Encryption Integration Flow', ()=>{
    let encryptor;
    beforeAll(()=>{
        // Set up test encryption key
        const testKey = _crypto.randomBytes(32).toString('base64');
        process.env.ENCRYPTION_KEY = testKey;
        encryptor = new _fieldencryptor.FieldEncryptor({
            enableAuditLogging: true
        });
    });
    afterAll(()=>{
        // Clean up
        delete process.env.ENCRYPTION_KEY;
    });
    describe('Field Encryptor', ()=>{
        test('should encrypt a single field value', ()=>{
            const plaintext = '+1234567890';
            const encrypted = encryptor.encryptField(plaintext, 'phone_number');
            expect(encrypted).not.toBeNull();
            expect(encrypted).not.toBe(plaintext);
            expect(typeof encrypted).toBe('string');
        });
        test('should decrypt a field value', ()=>{
            const plaintext = 'user@example.com';
            const encrypted = encryptor.encryptField(plaintext, 'email');
            const decrypted = encryptor.decryptField(encrypted, 'email');
            expect(decrypted).toBe(plaintext);
        });
        test('should handle null values gracefully', ()=>{
            const encrypted = encryptor.encryptField(null, 'phone_number');
            expect(encrypted).toBeNull();
            const decrypted = encryptor.decryptField(null, 'phone_number');
            expect(decrypted).toBeNull();
        });
        test('should handle undefined values gracefully', ()=>{
            const encrypted = encryptor.encryptField(undefined, 'email');
            expect(encrypted).toBeNull();
            const decrypted = encryptor.decryptField(undefined, 'email');
            expect(decrypted).toBeNull();
        });
        test('should handle empty strings', ()=>{
            const encrypted = encryptor.encryptField('', 'field');
            expect(encrypted).toBeNull();
            const decrypted = encryptor.decryptField('', 'field');
            expect(decrypted).toBeNull();
        });
        test('should maintain audit logs', ()=>{
            encryptor.clearAuditLogs();
            encryptor.encryptField('test1', 'field1');
            encryptor.decryptField('encrypted', 'field2');
            encryptor.encryptField('test2', 'field3');
            const logs = encryptor.getAuditLogs();
            expect(logs.length).toBeGreaterThanOrEqual(2); // At least 2 successful operations
        });
    });
    describe('Record Encryption', ()=>{
        test('should encrypt contact record', ()=>{
            const contact = {
                id: '123',
                phone_number: '+1234567890',
                whatsapp_id: 'whatsapp:+1234567890',
                name: 'John Doe'
            };
            const encrypted = encryptor.encryptContact(contact);
            expect(encrypted.phone_number).not.toBe(contact.phone_number);
            expect(encrypted.whatsapp_id).not.toBe(contact.whatsapp_id);
            expect(encrypted.name).toBe(contact.name); // Not encrypted
            expect(encrypted.id).toBe(contact.id); // Not encrypted
        });
        test('should decrypt contact record', ()=>{
            const original = {
                id: '456',
                phone_number: '+9876543210',
                whatsapp_id: 'whatsapp:+9876543210',
                name: 'Jane Smith'
            };
            const encrypted = encryptor.encryptContact(original);
            const decrypted = encryptor.decryptContact(encrypted);
            expect(decrypted.phone_number).toBe(original.phone_number);
            expect(decrypted.whatsapp_id).toBe(original.whatsapp_id);
            expect(decrypted.name).toBe(original.name);
            expect(decrypted.id).toBe(original.id);
        });
        test('should encrypt profile record', ()=>{
            const profile = {
                id: '789',
                email: 'user@example.com',
                full_name: 'Test User',
                role: 'admin'
            };
            const encrypted = encryptor.encryptProfile(profile);
            expect(encrypted.email).not.toBe(profile.email);
            expect(encrypted.full_name).toBe(profile.full_name); // Not encrypted
            expect(encrypted.role).toBe(profile.role); // Not encrypted
        });
        test('should decrypt profile record', ()=>{
            const original = {
                id: '101',
                email: 'admin@example.com',
                full_name: 'Admin User'
            };
            const encrypted = encryptor.encryptProfile(original);
            const decrypted = encryptor.decryptProfile(encrypted);
            expect(decrypted.email).toBe(original.email);
            expect(decrypted.full_name).toBe(original.full_name);
        });
        test('should handle records with null PII fields', ()=>{
            const contact = {
                id: '111',
                phone_number: null,
                whatsapp_id: null,
                name: 'No Phone'
            };
            const encrypted = encryptor.encryptContact(contact);
            expect(encrypted.phone_number).toBeNull();
            expect(encrypted.whatsapp_id).toBeNull();
            const decrypted = encryptor.decryptContact(encrypted);
            expect(decrypted.phone_number).toBeNull();
            expect(decrypted.whatsapp_id).toBeNull();
        });
    });
    describe('Batch Operations', ()=>{
        test('should batch encrypt multiple records', ()=>{
            const requests = [
                {
                    id: '1',
                    field: 'phone',
                    value: '+1111111111'
                },
                {
                    id: '2',
                    field: 'phone',
                    value: '+2222222222'
                },
                {
                    id: '3',
                    field: 'phone',
                    value: '+3333333333'
                }
            ];
            const results = encryptor.batchEncrypt(requests);
            expect(results).toHaveLength(3);
            results.forEach((result, index)=>{
                expect(result.success).toBe(true);
                expect(result.encrypted).not.toBeNull();
                expect(result.encrypted).not.toBe(requests[index].value);
            });
        });
        test('should batch decrypt multiple records', ()=>{
            const originalValues = [
                '+1111111111',
                '+2222222222',
                '+3333333333'
            ];
            const encrypted = originalValues.map((value, index)=>({
                    id: String(index + 1),
                    field: 'phone',
                    value
                }));
            const encryptedResults = encryptor.batchEncrypt(encrypted);
            const decryptRequests = encryptedResults.map((result)=>({
                    id: result.id,
                    field: result.field,
                    encrypted: result.encrypted
                }));
            const decryptedResults = encryptor.batchDecrypt(decryptRequests);
            expect(decryptedResults).toHaveLength(3);
            decryptedResults.forEach((result, index)=>{
                expect(result.success).toBe(true);
                expect(result.decrypted).toBe(originalValues[index]);
            });
        });
        test('should handle batch operations with failures gracefully', ()=>{
            const requests = [
                {
                    id: '1',
                    field: 'phone',
                    value: '+1111111111'
                },
                {
                    id: '2',
                    field: 'phone',
                    value: null
                },
                {
                    id: '3',
                    field: 'phone',
                    value: '+3333333333'
                }
            ];
            const results = encryptor.batchEncrypt(requests);
            expect(results).toHaveLength(3);
            expect(results[0].success).toBe(true);
            expect(results[1].success).toBe(true);
            expect(results[1].encrypted).toBeNull();
            expect(results[2].success).toBe(true);
        });
    });
    describe('Database Helpers', ()=>{
        test('should encrypt before write for contacts', ()=>{
            const contact = {
                phone_number: '+1234567890',
                whatsapp_id: 'whatsapp:+1234567890',
                name: 'Test Contact'
            };
            const encrypted = (0, _dbhelpers.encryptBeforeWrite)('contacts', contact);
            expect(encrypted.phone_number).not.toBe(contact.phone_number);
            expect(encrypted.whatsapp_id).not.toBe(contact.whatsapp_id);
            expect(encrypted.name).toBe(contact.name);
        });
        test('should decrypt after read for contacts', ()=>{
            const original = {
                phone_number: '+9876543210',
                whatsapp_id: 'whatsapp:+9876543210',
                name: 'Test Contact'
            };
            const encrypted = (0, _dbhelpers.encryptBeforeWrite)('contacts', original);
            const decrypted = (0, _dbhelpers.decryptAfterRead)('contacts', encrypted);
            expect(decrypted.phone_number).toBe(original.phone_number);
            expect(decrypted.whatsapp_id).toBe(original.whatsapp_id);
        });
        test('should encrypt multiple records', ()=>{
            const contacts = [
                {
                    phone_number: '+1111111111',
                    whatsapp_id: 'wa:1'
                },
                {
                    phone_number: '+2222222222',
                    whatsapp_id: 'wa:2'
                }
            ];
            const encrypted = (0, _dbhelpers.encryptRecords)('contacts', contacts);
            expect(encrypted).toHaveLength(2);
            encrypted.forEach((record, index)=>{
                expect(record.phone_number).not.toBe(contacts[index].phone_number);
                expect(record.whatsapp_id).not.toBe(contacts[index].whatsapp_id);
            });
        });
        test('should decrypt multiple records', ()=>{
            const contacts = [
                {
                    phone_number: '+1111111111',
                    whatsapp_id: 'wa:1'
                },
                {
                    phone_number: '+2222222222',
                    whatsapp_id: 'wa:2'
                }
            ];
            const encrypted = (0, _dbhelpers.encryptRecords)('contacts', contacts);
            const decrypted = (0, _dbhelpers.decryptRecords)('contacts', encrypted);
            expect(decrypted).toHaveLength(2);
            decrypted.forEach((record, index)=>{
                expect(record.phone_number).toBe(contacts[index].phone_number);
                expect(record.whatsapp_id).toBe(contacts[index].whatsapp_id);
            });
        });
    });
    describe('Convenience Functions', ()=>{
        test('should use encryptContact convenience function', ()=>{
            const contact = {
                phone_number: '+1234567890',
                whatsapp_id: 'wa:123'
            };
            const encrypted = (0, _fieldencryptor.encryptContact)(contact);
            expect(encrypted.phone_number).not.toBe(contact.phone_number);
            expect(encrypted.whatsapp_id).not.toBe(contact.whatsapp_id);
        });
        test('should use decryptContact convenience function', ()=>{
            const original = {
                phone_number: '+9876543210',
                whatsapp_id: 'wa:987'
            };
            const encrypted = (0, _fieldencryptor.encryptContact)(original);
            const decrypted = (0, _fieldencryptor.decryptContact)(encrypted);
            expect(decrypted.phone_number).toBe(original.phone_number);
            expect(decrypted.whatsapp_id).toBe(original.whatsapp_id);
        });
        test('should use encryptProfile convenience function', ()=>{
            const profile = {
                email: 'user@example.com'
            };
            const encrypted = (0, _fieldencryptor.encryptProfile)(profile);
            expect(encrypted.email).not.toBe(profile.email);
        });
        test('should use decryptProfile convenience function', ()=>{
            const original = {
                email: 'admin@example.com'
            };
            const encrypted = (0, _fieldencryptor.encryptProfile)(original);
            const decrypted = (0, _fieldencryptor.decryptProfile)(encrypted);
            expect(decrypted.email).toBe(original.email);
        });
    });
    describe('Audit and Statistics', ()=>{
        test('should track encryption statistics', ()=>{
            const testEncryptor = new _fieldencryptor.FieldEncryptor({
                enableAuditLogging: true
            });
            testEncryptor.clearAuditLogs();
            // Perform various operations
            testEncryptor.encryptField('value1', 'field1');
            testEncryptor.encryptField('value2', 'field2');
            testEncryptor.decryptField('encrypted', 'field3');
            const stats = testEncryptor.getStatistics();
            expect(stats.totalOperations).toBeGreaterThan(0);
            expect(stats.successfulOperations).toBeGreaterThan(0);
            expect(stats.successRate).toBeGreaterThan(0);
            expect(stats.operationsByType).toBeDefined();
        });
        test('should filter audit logs', ()=>{
            const testEncryptor = new _fieldencryptor.FieldEncryptor({
                enableAuditLogging: true
            });
            testEncryptor.clearAuditLogs();
            testEncryptor.encryptField('value1', 'phone');
            testEncryptor.encryptField('value2', 'email');
            testEncryptor.decryptField('encrypted', 'phone');
            const phoneLogs = testEncryptor.getFilteredAuditLogs({
                field: 'phone'
            });
            const emailLogs = testEncryptor.getFilteredAuditLogs({
                field: 'email'
            });
            expect(phoneLogs.length).toBeGreaterThan(0);
            expect(emailLogs.length).toBeGreaterThan(0);
            phoneLogs.forEach((log)=>expect(log.field).toBe('phone'));
            emailLogs.forEach((log)=>expect(log.field).toBe('email'));
        });
        test('should export audit logs as JSON', ()=>{
            const testEncryptor = new _fieldencryptor.FieldEncryptor({
                enableAuditLogging: true
            });
            testEncryptor.clearAuditLogs();
            testEncryptor.encryptField('value', 'field');
            const exported = testEncryptor.exportAuditLogs();
            expect(typeof exported).toBe('string');
            expect(()=>JSON.parse(exported)).not.toThrow();
            const parsed = JSON.parse(exported);
            expect(Array.isArray(parsed)).toBe(true);
        });
    });
    describe('System Verification', ()=>{
        test('should verify encryption system is healthy', ()=>{
            const verification = _fieldencryptor.FieldEncryptor.verifyEncryption();
            expect(verification.healthy).toBe(true);
            expect(verification.status.keyLoaded).toBe(true);
            expect(verification.status.testPassed).toBe(true);
            expect(verification.message).toContain('operational');
        });
        test('should verify database encryption configuration', ()=>{
            const verification = (0, _dbhelpers.verifyDatabaseEncryption)();
            expect(verification.configured).toBe(true);
            expect(verification.tablesConfigured).toContain('contacts');
            expect(verification.tablesConfigured).toContain('profiles');
            expect(verification.fieldsConfigured.contacts).toContain('phone_number');
            expect(verification.fieldsConfigured.contacts).toContain('whatsapp_id');
            expect(verification.fieldsConfigured.profiles).toContain('email');
        });
        test('should get encrypted fields for table', ()=>{
            const contactFields = encryptor.getEncryptedFieldsForTable('contacts');
            const profileFields = encryptor.getEncryptedFieldsForTable('profiles');
            expect(contactFields).toContain('phone_number');
            expect(contactFields).toContain('whatsapp_id');
            expect(profileFields).toContain('email');
        });
        test('should check if field should be encrypted', ()=>{
            expect(encryptor.shouldEncryptField('contacts', 'phone_number')).toBe(true);
            expect(encryptor.shouldEncryptField('contacts', 'whatsapp_id')).toBe(true);
            expect(encryptor.shouldEncryptField('contacts', 'name')).toBe(false);
            expect(encryptor.shouldEncryptField('profiles', 'email')).toBe(true);
            expect(encryptor.shouldEncryptField('profiles', 'full_name')).toBe(false);
        });
    });
    describe('Error Recovery', ()=>{
        test('should handle encryption errors gracefully', ()=>{
            const testEncryptor = new _fieldencryptor.FieldEncryptor({
                enableAuditLogging: true
            });
            testEncryptor.clearAuditLogs();
            // Try to encrypt with invalid configuration (simulate error)
            const originalKey = process.env.ENCRYPTION_KEY;
            delete process.env.ENCRYPTION_KEY;
            expect(()=>{
                testEncryptor.encryptField('value', 'field');
            }).toThrow();
            process.env.ENCRYPTION_KEY = originalKey;
        });
        test('should handle decryption errors gracefully', ()=>{
            const testEncryptor = new _fieldencryptor.FieldEncryptor({
                enableAuditLogging: true
            });
            expect(()=>{
                testEncryptor.decryptField('invalid-encrypted-data', 'field');
            }).toThrow();
        });
        test('should log failed operations', ()=>{
            const testEncryptor = new _fieldencryptor.FieldEncryptor({
                enableAuditLogging: true
            });
            testEncryptor.clearAuditLogs();
            const originalKey = process.env.ENCRYPTION_KEY;
            delete process.env.ENCRYPTION_KEY;
            try {
                testEncryptor.encryptField('value', 'field');
            } catch (error) {
            // Expected to throw
            }
            process.env.ENCRYPTION_KEY = originalKey;
            const logs = testEncryptor.getAuditLogs();
            const failedLogs = logs.filter((log)=>!log.success);
            expect(failedLogs.length).toBeGreaterThan(0);
        });
    });
    describe('End-to-End Workflow', ()=>{
        test('should complete full contact encryption workflow', ()=>{
            // Step 1: Create plaintext contact
            const contact = {
                id: 'e2e-001',
                organization_id: 'org-123',
                phone_number: '+1234567890',
                whatsapp_id: 'whatsapp:+1234567890',
                name: 'End to End Test',
                created_at: new Date().toISOString()
            };
            // Step 2: Encrypt before database insert
            const encrypted = (0, _dbhelpers.encryptBeforeWrite)('contacts', contact);
            expect(encrypted.phone_number).not.toBe(contact.phone_number);
            expect(encrypted.whatsapp_id).not.toBe(contact.whatsapp_id);
            // Step 3: Simulate database storage (encrypted data)
            // In real scenario, this would be stored in Supabase
            // Step 4: Decrypt after database read
            const decrypted = (0, _dbhelpers.decryptAfterRead)('contacts', encrypted);
            expect(decrypted.phone_number).toBe(contact.phone_number);
            expect(decrypted.whatsapp_id).toBe(contact.whatsapp_id);
            expect(decrypted.name).toBe(contact.name);
        });
        test('should complete full profile encryption workflow', ()=>{
            // Step 1: Create plaintext profile
            const profile = {
                id: 'e2e-002',
                organization_id: 'org-123',
                email: 'e2e@example.com',
                full_name: 'E2E Test User',
                role: 'agent'
            };
            // Step 2: Encrypt before database insert
            const encrypted = (0, _dbhelpers.encryptBeforeWrite)('profiles', profile);
            expect(encrypted.email).not.toBe(profile.email);
            expect(encrypted.full_name).toBe(profile.full_name);
            // Step 3: Decrypt after database read
            const decrypted = (0, _dbhelpers.decryptAfterRead)('profiles', encrypted);
            expect(decrypted.email).toBe(profile.email);
            expect(decrypted.full_name).toBe(profile.full_name);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxBaSBQcm9qZWN0ZW5cXEFEU2FwcFxcdGVzdHNcXGludGVncmF0aW9uXFxlbmNyeXB0aW9uLWZsb3cudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEludGVncmF0aW9uIFRlc3RzIGZvciBFbmNyeXB0aW9uIEZsb3dcbiAqXG4gKiBFbmQtdG8tZW5kIHRlc3RzIGZvciBmaWVsZC1sZXZlbCBlbmNyeXB0aW9uIGludGVncmF0ZWQgd2l0aFxuICogdGhlIGRhdGFiYXNlLCBBUEkgcm91dGVzLCBhbmQgYnVzaW5lc3MgbG9naWMuXG4gKlxuICogQG1vZHVsZSB0ZXN0cy9pbnRlZ3JhdGlvbi9lbmNyeXB0aW9uLWZsb3dcbiAqL1xuXG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7XG4gIEZpZWxkRW5jcnlwdG9yLFxuICBlbmNyeXB0Q29udGFjdCxcbiAgZGVjcnlwdENvbnRhY3QsXG4gIGVuY3J5cHRQcm9maWxlLFxuICBkZWNyeXB0UHJvZmlsZSxcbn0gZnJvbSAnLi4vLi4vc3JjL2xpYi9jcnlwdG8vZmllbGQtZW5jcnlwdG9yJztcbmltcG9ydCB7XG4gIGVuY3J5cHRCZWZvcmVXcml0ZSxcbiAgZGVjcnlwdEFmdGVyUmVhZCxcbiAgZW5jcnlwdFJlY29yZHMsXG4gIGRlY3J5cHRSZWNvcmRzLFxuICB2ZXJpZnlEYXRhYmFzZUVuY3J5cHRpb24sXG59IGZyb20gJy4uLy4uL3NyYy9saWIvY3J5cHRvL2RiLWhlbHBlcnMnO1xuaW1wb3J0IHsgRU5DUllQVEVEX0ZJRUxEUyB9IGZyb20gJy4uLy4uL3NyYy9saWIvY3J5cHRvL3R5cGVzJztcblxuZGVzY3JpYmUoJ0VuY3J5cHRpb24gSW50ZWdyYXRpb24gRmxvdycsICgpID0+IHtcbiAgbGV0IGVuY3J5cHRvcjogRmllbGRFbmNyeXB0b3I7XG5cbiAgYmVmb3JlQWxsKCgpID0+IHtcbiAgICAvLyBTZXQgdXAgdGVzdCBlbmNyeXB0aW9uIGtleVxuICAgIGNvbnN0IHRlc3RLZXkgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMzIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWSA9IHRlc3RLZXk7XG5cbiAgICBlbmNyeXB0b3IgPSBuZXcgRmllbGRFbmNyeXB0b3IoeyBlbmFibGVBdWRpdExvZ2dpbmc6IHRydWUgfSk7XG4gIH0pO1xuXG4gIGFmdGVyQWxsKCgpID0+IHtcbiAgICAvLyBDbGVhbiB1cFxuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ZpZWxkIEVuY3J5cHRvcicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgZW5jcnlwdCBhIHNpbmdsZSBmaWVsZCB2YWx1ZScsICgpID0+IHtcbiAgICAgIGNvbnN0IHBsYWludGV4dCA9ICcrMTIzNDU2Nzg5MCc7XG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0b3IuZW5jcnlwdEZpZWxkKHBsYWludGV4dCwgJ3Bob25lX251bWJlcicpO1xuXG4gICAgICBleHBlY3QoZW5jcnlwdGVkKS5ub3QudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChlbmNyeXB0ZWQpLm5vdC50b0JlKHBsYWludGV4dCk7XG4gICAgICBleHBlY3QodHlwZW9mIGVuY3J5cHRlZCkudG9CZSgnc3RyaW5nJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZGVjcnlwdCBhIGZpZWxkIHZhbHVlJywgKCkgPT4ge1xuICAgICAgY29uc3QgcGxhaW50ZXh0ID0gJ3VzZXJAZXhhbXBsZS5jb20nO1xuICAgICAgY29uc3QgZW5jcnlwdGVkID0gZW5jcnlwdG9yLmVuY3J5cHRGaWVsZChwbGFpbnRleHQsICdlbWFpbCcpO1xuICAgICAgY29uc3QgZGVjcnlwdGVkID0gZW5jcnlwdG9yLmRlY3J5cHRGaWVsZChlbmNyeXB0ZWQhLCAnZW1haWwnKTtcblxuICAgICAgZXhwZWN0KGRlY3J5cHRlZCkudG9CZShwbGFpbnRleHQpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBudWxsIHZhbHVlcyBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgZW5jcnlwdGVkID0gZW5jcnlwdG9yLmVuY3J5cHRGaWVsZChudWxsLCAncGhvbmVfbnVtYmVyJyk7XG4gICAgICBleHBlY3QoZW5jcnlwdGVkKS50b0JlTnVsbCgpO1xuXG4gICAgICBjb25zdCBkZWNyeXB0ZWQgPSBlbmNyeXB0b3IuZGVjcnlwdEZpZWxkKG51bGwsICdwaG9uZV9udW1iZXInKTtcbiAgICAgIGV4cGVjdChkZWNyeXB0ZWQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIHVuZGVmaW5lZCB2YWx1ZXMgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHRvci5lbmNyeXB0RmllbGQodW5kZWZpbmVkLCAnZW1haWwnKTtcbiAgICAgIGV4cGVjdChlbmNyeXB0ZWQpLnRvQmVOdWxsKCk7XG5cbiAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGVuY3J5cHRvci5kZWNyeXB0RmllbGQodW5kZWZpbmVkLCAnZW1haWwnKTtcbiAgICAgIGV4cGVjdChkZWNyeXB0ZWQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGVtcHR5IHN0cmluZ3MnLCAoKSA9PiB7XG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0b3IuZW5jcnlwdEZpZWxkKCcnLCAnZmllbGQnKTtcbiAgICAgIGV4cGVjdChlbmNyeXB0ZWQpLnRvQmVOdWxsKCk7XG5cbiAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGVuY3J5cHRvci5kZWNyeXB0RmllbGQoJycsICdmaWVsZCcpO1xuICAgICAgZXhwZWN0KGRlY3J5cHRlZCkudG9CZU51bGwoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBtYWludGFpbiBhdWRpdCBsb2dzJywgKCkgPT4ge1xuICAgICAgZW5jcnlwdG9yLmNsZWFyQXVkaXRMb2dzKCk7XG5cbiAgICAgIGVuY3J5cHRvci5lbmNyeXB0RmllbGQoJ3Rlc3QxJywgJ2ZpZWxkMScpO1xuICAgICAgZW5jcnlwdG9yLmRlY3J5cHRGaWVsZCgnZW5jcnlwdGVkJywgJ2ZpZWxkMicpO1xuICAgICAgZW5jcnlwdG9yLmVuY3J5cHRGaWVsZCgndGVzdDInLCAnZmllbGQzJyk7XG5cbiAgICAgIGNvbnN0IGxvZ3MgPSBlbmNyeXB0b3IuZ2V0QXVkaXRMb2dzKCk7XG4gICAgICBleHBlY3QobG9ncy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMik7IC8vIEF0IGxlYXN0IDIgc3VjY2Vzc2Z1bCBvcGVyYXRpb25zXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZWNvcmQgRW5jcnlwdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgZW5jcnlwdCBjb250YWN0IHJlY29yZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhY3QgPSB7XG4gICAgICAgIGlkOiAnMTIzJyxcbiAgICAgICAgcGhvbmVfbnVtYmVyOiAnKzEyMzQ1Njc4OTAnLFxuICAgICAgICB3aGF0c2FwcF9pZDogJ3doYXRzYXBwOisxMjM0NTY3ODkwJyxcbiAgICAgICAgbmFtZTogJ0pvaG4gRG9lJyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHRvci5lbmNyeXB0Q29udGFjdChjb250YWN0KTtcblxuICAgICAgZXhwZWN0KGVuY3J5cHRlZC5waG9uZV9udW1iZXIpLm5vdC50b0JlKGNvbnRhY3QucGhvbmVfbnVtYmVyKTtcbiAgICAgIGV4cGVjdChlbmNyeXB0ZWQud2hhdHNhcHBfaWQpLm5vdC50b0JlKGNvbnRhY3Qud2hhdHNhcHBfaWQpO1xuICAgICAgZXhwZWN0KGVuY3J5cHRlZC5uYW1lKS50b0JlKGNvbnRhY3QubmFtZSk7IC8vIE5vdCBlbmNyeXB0ZWRcbiAgICAgIGV4cGVjdChlbmNyeXB0ZWQuaWQpLnRvQmUoY29udGFjdC5pZCk7IC8vIE5vdCBlbmNyeXB0ZWRcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBkZWNyeXB0IGNvbnRhY3QgcmVjb3JkJywgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWwgPSB7XG4gICAgICAgIGlkOiAnNDU2JyxcbiAgICAgICAgcGhvbmVfbnVtYmVyOiAnKzk4NzY1NDMyMTAnLFxuICAgICAgICB3aGF0c2FwcF9pZDogJ3doYXRzYXBwOis5ODc2NTQzMjEwJyxcbiAgICAgICAgbmFtZTogJ0phbmUgU21pdGgnLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgZW5jcnlwdGVkID0gZW5jcnlwdG9yLmVuY3J5cHRDb250YWN0KG9yaWdpbmFsKTtcbiAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGVuY3J5cHRvci5kZWNyeXB0Q29udGFjdChlbmNyeXB0ZWQpO1xuXG4gICAgICBleHBlY3QoZGVjcnlwdGVkLnBob25lX251bWJlcikudG9CZShvcmlnaW5hbC5waG9uZV9udW1iZXIpO1xuICAgICAgZXhwZWN0KGRlY3J5cHRlZC53aGF0c2FwcF9pZCkudG9CZShvcmlnaW5hbC53aGF0c2FwcF9pZCk7XG4gICAgICBleHBlY3QoZGVjcnlwdGVkLm5hbWUpLnRvQmUob3JpZ2luYWwubmFtZSk7XG4gICAgICBleHBlY3QoZGVjcnlwdGVkLmlkKS50b0JlKG9yaWdpbmFsLmlkKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBlbmNyeXB0IHByb2ZpbGUgcmVjb3JkJywgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvZmlsZSA9IHtcbiAgICAgICAgaWQ6ICc3ODknLFxuICAgICAgICBlbWFpbDogJ3VzZXJAZXhhbXBsZS5jb20nLFxuICAgICAgICBmdWxsX25hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICByb2xlOiAnYWRtaW4nIGFzIGNvbnN0LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgZW5jcnlwdGVkID0gZW5jcnlwdG9yLmVuY3J5cHRQcm9maWxlKHByb2ZpbGUpO1xuXG4gICAgICBleHBlY3QoZW5jcnlwdGVkLmVtYWlsKS5ub3QudG9CZShwcm9maWxlLmVtYWlsKTtcbiAgICAgIGV4cGVjdChlbmNyeXB0ZWQuZnVsbF9uYW1lKS50b0JlKHByb2ZpbGUuZnVsbF9uYW1lKTsgLy8gTm90IGVuY3J5cHRlZFxuICAgICAgZXhwZWN0KGVuY3J5cHRlZC5yb2xlKS50b0JlKHByb2ZpbGUucm9sZSk7IC8vIE5vdCBlbmNyeXB0ZWRcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBkZWNyeXB0IHByb2ZpbGUgcmVjb3JkJywgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWwgPSB7XG4gICAgICAgIGlkOiAnMTAxJyxcbiAgICAgICAgZW1haWw6ICdhZG1pbkBleGFtcGxlLmNvbScsXG4gICAgICAgIGZ1bGxfbmFtZTogJ0FkbWluIFVzZXInLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgZW5jcnlwdGVkID0gZW5jcnlwdG9yLmVuY3J5cHRQcm9maWxlKG9yaWdpbmFsKTtcbiAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGVuY3J5cHRvci5kZWNyeXB0UHJvZmlsZShlbmNyeXB0ZWQpO1xuXG4gICAgICBleHBlY3QoZGVjcnlwdGVkLmVtYWlsKS50b0JlKG9yaWdpbmFsLmVtYWlsKTtcbiAgICAgIGV4cGVjdChkZWNyeXB0ZWQuZnVsbF9uYW1lKS50b0JlKG9yaWdpbmFsLmZ1bGxfbmFtZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIHJlY29yZHMgd2l0aCBudWxsIFBJSSBmaWVsZHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb250YWN0ID0ge1xuICAgICAgICBpZDogJzExMScsXG4gICAgICAgIHBob25lX251bWJlcjogbnVsbCxcbiAgICAgICAgd2hhdHNhcHBfaWQ6IG51bGwsXG4gICAgICAgIG5hbWU6ICdObyBQaG9uZScsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0b3IuZW5jcnlwdENvbnRhY3QoY29udGFjdCk7XG4gICAgICBleHBlY3QoZW5jcnlwdGVkLnBob25lX251bWJlcikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChlbmNyeXB0ZWQud2hhdHNhcHBfaWQpLnRvQmVOdWxsKCk7XG5cbiAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGVuY3J5cHRvci5kZWNyeXB0Q29udGFjdChlbmNyeXB0ZWQpO1xuICAgICAgZXhwZWN0KGRlY3J5cHRlZC5waG9uZV9udW1iZXIpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoZGVjcnlwdGVkLndoYXRzYXBwX2lkKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQmF0Y2ggT3BlcmF0aW9ucycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgYmF0Y2ggZW5jcnlwdCBtdWx0aXBsZSByZWNvcmRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdHMgPSBbXG4gICAgICAgIHsgaWQ6ICcxJywgZmllbGQ6ICdwaG9uZScsIHZhbHVlOiAnKzExMTExMTExMTEnIH0sXG4gICAgICAgIHsgaWQ6ICcyJywgZmllbGQ6ICdwaG9uZScsIHZhbHVlOiAnKzIyMjIyMjIyMjInIH0sXG4gICAgICAgIHsgaWQ6ICczJywgZmllbGQ6ICdwaG9uZScsIHZhbHVlOiAnKzMzMzMzMzMzMzMnIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gZW5jcnlwdG9yLmJhdGNoRW5jcnlwdChyZXF1ZXN0cyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHRzKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICByZXN1bHRzLmZvckVhY2goKHJlc3VsdCwgaW5kZXgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVuY3J5cHRlZCkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZW5jcnlwdGVkKS5ub3QudG9CZShyZXF1ZXN0c1tpbmRleF0udmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgYmF0Y2ggZGVjcnlwdCBtdWx0aXBsZSByZWNvcmRzJywgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxWYWx1ZXMgPSBbJysxMTExMTExMTExJywgJysyMjIyMjIyMjIyJywgJyszMzMzMzMzMzMzJ107XG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSBvcmlnaW5hbFZhbHVlcy5tYXAoKHZhbHVlLCBpbmRleCkgPT4gKHtcbiAgICAgICAgaWQ6IFN0cmluZyhpbmRleCArIDEpLFxuICAgICAgICBmaWVsZDogJ3Bob25lJyxcbiAgICAgICAgdmFsdWUsXG4gICAgICB9KSk7XG5cbiAgICAgIGNvbnN0IGVuY3J5cHRlZFJlc3VsdHMgPSBlbmNyeXB0b3IuYmF0Y2hFbmNyeXB0KGVuY3J5cHRlZCk7XG5cbiAgICAgIGNvbnN0IGRlY3J5cHRSZXF1ZXN0cyA9IGVuY3J5cHRlZFJlc3VsdHMubWFwKHJlc3VsdCA9PiAoe1xuICAgICAgICBpZDogcmVzdWx0LmlkLFxuICAgICAgICBmaWVsZDogcmVzdWx0LmZpZWxkLFxuICAgICAgICBlbmNyeXB0ZWQ6IHJlc3VsdC5lbmNyeXB0ZWQhLFxuICAgICAgfSkpO1xuXG4gICAgICBjb25zdCBkZWNyeXB0ZWRSZXN1bHRzID0gZW5jcnlwdG9yLmJhdGNoRGVjcnlwdChkZWNyeXB0UmVxdWVzdHMpO1xuXG4gICAgICBleHBlY3QoZGVjcnlwdGVkUmVzdWx0cykudG9IYXZlTGVuZ3RoKDMpO1xuICAgICAgZGVjcnlwdGVkUmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGluZGV4KSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kZWNyeXB0ZWQpLnRvQmUob3JpZ2luYWxWYWx1ZXNbaW5kZXhdKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBiYXRjaCBvcGVyYXRpb25zIHdpdGggZmFpbHVyZXMgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RzID0gW1xuICAgICAgICB7IGlkOiAnMScsIGZpZWxkOiAncGhvbmUnLCB2YWx1ZTogJysxMTExMTExMTExJyB9LFxuICAgICAgICB7IGlkOiAnMicsIGZpZWxkOiAncGhvbmUnLCB2YWx1ZTogbnVsbCB9LCAvLyBXaWxsIHN1Y2NlZWQgd2l0aCBudWxsXG4gICAgICAgIHsgaWQ6ICczJywgZmllbGQ6ICdwaG9uZScsIHZhbHVlOiAnKzMzMzMzMzMzMzMnIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gZW5jcnlwdG9yLmJhdGNoRW5jcnlwdChyZXF1ZXN0cyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHRzKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICBleHBlY3QocmVzdWx0c1swXS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdHNbMV0uc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzWzFdLmVuY3J5cHRlZCkudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzWzJdLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdEYXRhYmFzZSBIZWxwZXJzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBlbmNyeXB0IGJlZm9yZSB3cml0ZSBmb3IgY29udGFjdHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb250YWN0ID0ge1xuICAgICAgICBwaG9uZV9udW1iZXI6ICcrMTIzNDU2Nzg5MCcsXG4gICAgICAgIHdoYXRzYXBwX2lkOiAnd2hhdHNhcHA6KzEyMzQ1Njc4OTAnLFxuICAgICAgICBuYW1lOiAnVGVzdCBDb250YWN0JyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHRCZWZvcmVXcml0ZSgnY29udGFjdHMnLCBjb250YWN0KTtcblxuICAgICAgZXhwZWN0KGVuY3J5cHRlZC5waG9uZV9udW1iZXIpLm5vdC50b0JlKGNvbnRhY3QucGhvbmVfbnVtYmVyKTtcbiAgICAgIGV4cGVjdChlbmNyeXB0ZWQud2hhdHNhcHBfaWQpLm5vdC50b0JlKGNvbnRhY3Qud2hhdHNhcHBfaWQpO1xuICAgICAgZXhwZWN0KGVuY3J5cHRlZC5uYW1lKS50b0JlKGNvbnRhY3QubmFtZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZGVjcnlwdCBhZnRlciByZWFkIGZvciBjb250YWN0cycsICgpID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsID0ge1xuICAgICAgICBwaG9uZV9udW1iZXI6ICcrOTg3NjU0MzIxMCcsXG4gICAgICAgIHdoYXRzYXBwX2lkOiAnd2hhdHNhcHA6Kzk4NzY1NDMyMTAnLFxuICAgICAgICBuYW1lOiAnVGVzdCBDb250YWN0JyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHRCZWZvcmVXcml0ZSgnY29udGFjdHMnLCBvcmlnaW5hbCk7XG4gICAgICBjb25zdCBkZWNyeXB0ZWQgPSBkZWNyeXB0QWZ0ZXJSZWFkKCdjb250YWN0cycsIGVuY3J5cHRlZCk7XG5cbiAgICAgIGV4cGVjdChkZWNyeXB0ZWQucGhvbmVfbnVtYmVyKS50b0JlKG9yaWdpbmFsLnBob25lX251bWJlcik7XG4gICAgICBleHBlY3QoZGVjcnlwdGVkLndoYXRzYXBwX2lkKS50b0JlKG9yaWdpbmFsLndoYXRzYXBwX2lkKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBlbmNyeXB0IG11bHRpcGxlIHJlY29yZHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb250YWN0cyA9IFtcbiAgICAgICAgeyBwaG9uZV9udW1iZXI6ICcrMTExMTExMTExMScsIHdoYXRzYXBwX2lkOiAnd2E6MScgfSxcbiAgICAgICAgeyBwaG9uZV9udW1iZXI6ICcrMjIyMjIyMjIyMicsIHdoYXRzYXBwX2lkOiAnd2E6MicgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHRSZWNvcmRzKCdjb250YWN0cycsIGNvbnRhY3RzKTtcblxuICAgICAgZXhwZWN0KGVuY3J5cHRlZCkudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgZW5jcnlwdGVkLmZvckVhY2goKHJlY29yZCwgaW5kZXgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlY29yZC5waG9uZV9udW1iZXIpLm5vdC50b0JlKGNvbnRhY3RzW2luZGV4XS5waG9uZV9udW1iZXIpO1xuICAgICAgICBleHBlY3QocmVjb3JkLndoYXRzYXBwX2lkKS5ub3QudG9CZShjb250YWN0c1tpbmRleF0ud2hhdHNhcHBfaWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZGVjcnlwdCBtdWx0aXBsZSByZWNvcmRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgY29udGFjdHMgPSBbXG4gICAgICAgIHsgcGhvbmVfbnVtYmVyOiAnKzExMTExMTExMTEnLCB3aGF0c2FwcF9pZDogJ3dhOjEnIH0sXG4gICAgICAgIHsgcGhvbmVfbnVtYmVyOiAnKzIyMjIyMjIyMjInLCB3aGF0c2FwcF9pZDogJ3dhOjInIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0UmVjb3JkcygnY29udGFjdHMnLCBjb250YWN0cyk7XG4gICAgICBjb25zdCBkZWNyeXB0ZWQgPSBkZWNyeXB0UmVjb3JkcygnY29udGFjdHMnLCBlbmNyeXB0ZWQpO1xuXG4gICAgICBleHBlY3QoZGVjcnlwdGVkKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBkZWNyeXB0ZWQuZm9yRWFjaCgocmVjb3JkLCBpbmRleCkgPT4ge1xuICAgICAgICBleHBlY3QocmVjb3JkLnBob25lX251bWJlcikudG9CZShjb250YWN0c1tpbmRleF0ucGhvbmVfbnVtYmVyKTtcbiAgICAgICAgZXhwZWN0KHJlY29yZC53aGF0c2FwcF9pZCkudG9CZShjb250YWN0c1tpbmRleF0ud2hhdHNhcHBfaWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb252ZW5pZW5jZSBGdW5jdGlvbnMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHVzZSBlbmNyeXB0Q29udGFjdCBjb252ZW5pZW5jZSBmdW5jdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhY3QgPSB7XG4gICAgICAgIHBob25lX251bWJlcjogJysxMjM0NTY3ODkwJyxcbiAgICAgICAgd2hhdHNhcHBfaWQ6ICd3YToxMjMnLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgZW5jcnlwdGVkID0gZW5jcnlwdENvbnRhY3QoY29udGFjdCk7XG5cbiAgICAgIGV4cGVjdChlbmNyeXB0ZWQucGhvbmVfbnVtYmVyKS5ub3QudG9CZShjb250YWN0LnBob25lX251bWJlcik7XG4gICAgICBleHBlY3QoZW5jcnlwdGVkLndoYXRzYXBwX2lkKS5ub3QudG9CZShjb250YWN0LndoYXRzYXBwX2lkKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB1c2UgZGVjcnlwdENvbnRhY3QgY29udmVuaWVuY2UgZnVuY3Rpb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbCA9IHtcbiAgICAgICAgcGhvbmVfbnVtYmVyOiAnKzk4NzY1NDMyMTAnLFxuICAgICAgICB3aGF0c2FwcF9pZDogJ3dhOjk4NycsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0Q29udGFjdChvcmlnaW5hbCk7XG4gICAgICBjb25zdCBkZWNyeXB0ZWQgPSBkZWNyeXB0Q29udGFjdChlbmNyeXB0ZWQpO1xuXG4gICAgICBleHBlY3QoZGVjcnlwdGVkLnBob25lX251bWJlcikudG9CZShvcmlnaW5hbC5waG9uZV9udW1iZXIpO1xuICAgICAgZXhwZWN0KGRlY3J5cHRlZC53aGF0c2FwcF9pZCkudG9CZShvcmlnaW5hbC53aGF0c2FwcF9pZCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdXNlIGVuY3J5cHRQcm9maWxlIGNvbnZlbmllbmNlIGZ1bmN0aW9uJywgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvZmlsZSA9IHtcbiAgICAgICAgZW1haWw6ICd1c2VyQGV4YW1wbGUuY29tJyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHRQcm9maWxlKHByb2ZpbGUpO1xuXG4gICAgICBleHBlY3QoZW5jcnlwdGVkLmVtYWlsKS5ub3QudG9CZShwcm9maWxlLmVtYWlsKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB1c2UgZGVjcnlwdFByb2ZpbGUgY29udmVuaWVuY2UgZnVuY3Rpb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbCA9IHtcbiAgICAgICAgZW1haWw6ICdhZG1pbkBleGFtcGxlLmNvbScsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0UHJvZmlsZShvcmlnaW5hbCk7XG4gICAgICBjb25zdCBkZWNyeXB0ZWQgPSBkZWNyeXB0UHJvZmlsZShlbmNyeXB0ZWQpO1xuXG4gICAgICBleHBlY3QoZGVjcnlwdGVkLmVtYWlsKS50b0JlKG9yaWdpbmFsLmVtYWlsKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0F1ZGl0IGFuZCBTdGF0aXN0aWNzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCB0cmFjayBlbmNyeXB0aW9uIHN0YXRpc3RpY3MnLCAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0RW5jcnlwdG9yID0gbmV3IEZpZWxkRW5jcnlwdG9yKHsgZW5hYmxlQXVkaXRMb2dnaW5nOiB0cnVlIH0pO1xuICAgICAgdGVzdEVuY3J5cHRvci5jbGVhckF1ZGl0TG9ncygpO1xuXG4gICAgICAvLyBQZXJmb3JtIHZhcmlvdXMgb3BlcmF0aW9uc1xuICAgICAgdGVzdEVuY3J5cHRvci5lbmNyeXB0RmllbGQoJ3ZhbHVlMScsICdmaWVsZDEnKTtcbiAgICAgIHRlc3RFbmNyeXB0b3IuZW5jcnlwdEZpZWxkKCd2YWx1ZTInLCAnZmllbGQyJyk7XG4gICAgICB0ZXN0RW5jcnlwdG9yLmRlY3J5cHRGaWVsZCgnZW5jcnlwdGVkJywgJ2ZpZWxkMycpO1xuXG4gICAgICBjb25zdCBzdGF0cyA9IHRlc3RFbmNyeXB0b3IuZ2V0U3RhdGlzdGljcygpO1xuXG4gICAgICBleHBlY3Qoc3RhdHMudG90YWxPcGVyYXRpb25zKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3Qoc3RhdHMuc3VjY2Vzc2Z1bE9wZXJhdGlvbnMpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChzdGF0cy5zdWNjZXNzUmF0ZSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KHN0YXRzLm9wZXJhdGlvbnNCeVR5cGUpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZmlsdGVyIGF1ZGl0IGxvZ3MnLCAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0RW5jcnlwdG9yID0gbmV3IEZpZWxkRW5jcnlwdG9yKHsgZW5hYmxlQXVkaXRMb2dnaW5nOiB0cnVlIH0pO1xuICAgICAgdGVzdEVuY3J5cHRvci5jbGVhckF1ZGl0TG9ncygpO1xuXG4gICAgICB0ZXN0RW5jcnlwdG9yLmVuY3J5cHRGaWVsZCgndmFsdWUxJywgJ3Bob25lJyk7XG4gICAgICB0ZXN0RW5jcnlwdG9yLmVuY3J5cHRGaWVsZCgndmFsdWUyJywgJ2VtYWlsJyk7XG4gICAgICB0ZXN0RW5jcnlwdG9yLmRlY3J5cHRGaWVsZCgnZW5jcnlwdGVkJywgJ3Bob25lJyk7XG5cbiAgICAgIGNvbnN0IHBob25lTG9ncyA9IHRlc3RFbmNyeXB0b3IuZ2V0RmlsdGVyZWRBdWRpdExvZ3Moe1xuICAgICAgICBmaWVsZDogJ3Bob25lJyxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBlbWFpbExvZ3MgPSB0ZXN0RW5jcnlwdG9yLmdldEZpbHRlcmVkQXVkaXRMb2dzKHtcbiAgICAgICAgZmllbGQ6ICdlbWFpbCcsXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHBob25lTG9ncy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChlbWFpbExvZ3MubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBwaG9uZUxvZ3MuZm9yRWFjaChsb2cgPT4gZXhwZWN0KGxvZy5maWVsZCkudG9CZSgncGhvbmUnKSk7XG4gICAgICBlbWFpbExvZ3MuZm9yRWFjaChsb2cgPT4gZXhwZWN0KGxvZy5maWVsZCkudG9CZSgnZW1haWwnKSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZXhwb3J0IGF1ZGl0IGxvZ3MgYXMgSlNPTicsICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RFbmNyeXB0b3IgPSBuZXcgRmllbGRFbmNyeXB0b3IoeyBlbmFibGVBdWRpdExvZ2dpbmc6IHRydWUgfSk7XG4gICAgICB0ZXN0RW5jcnlwdG9yLmNsZWFyQXVkaXRMb2dzKCk7XG5cbiAgICAgIHRlc3RFbmNyeXB0b3IuZW5jcnlwdEZpZWxkKCd2YWx1ZScsICdmaWVsZCcpO1xuXG4gICAgICBjb25zdCBleHBvcnRlZCA9IHRlc3RFbmNyeXB0b3IuZXhwb3J0QXVkaXRMb2dzKCk7XG5cbiAgICAgIGV4cGVjdCh0eXBlb2YgZXhwb3J0ZWQpLnRvQmUoJ3N0cmluZycpO1xuICAgICAgZXhwZWN0KCgpID0+IEpTT04ucGFyc2UoZXhwb3J0ZWQpKS5ub3QudG9UaHJvdygpO1xuXG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGV4cG9ydGVkKTtcbiAgICAgIGV4cGVjdChBcnJheS5pc0FycmF5KHBhcnNlZCkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTeXN0ZW0gVmVyaWZpY2F0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCB2ZXJpZnkgZW5jcnlwdGlvbiBzeXN0ZW0gaXMgaGVhbHRoeScsICgpID0+IHtcbiAgICAgIGNvbnN0IHZlcmlmaWNhdGlvbiA9IEZpZWxkRW5jcnlwdG9yLnZlcmlmeUVuY3J5cHRpb24oKTtcblxuICAgICAgZXhwZWN0KHZlcmlmaWNhdGlvbi5oZWFsdGh5KS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZlcmlmaWNhdGlvbi5zdGF0dXMua2V5TG9hZGVkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZlcmlmaWNhdGlvbi5zdGF0dXMudGVzdFBhc3NlZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh2ZXJpZmljYXRpb24ubWVzc2FnZSkudG9Db250YWluKCdvcGVyYXRpb25hbCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHZlcmlmeSBkYXRhYmFzZSBlbmNyeXB0aW9uIGNvbmZpZ3VyYXRpb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCB2ZXJpZmljYXRpb24gPSB2ZXJpZnlEYXRhYmFzZUVuY3J5cHRpb24oKTtcblxuICAgICAgZXhwZWN0KHZlcmlmaWNhdGlvbi5jb25maWd1cmVkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZlcmlmaWNhdGlvbi50YWJsZXNDb25maWd1cmVkKS50b0NvbnRhaW4oJ2NvbnRhY3RzJyk7XG4gICAgICBleHBlY3QodmVyaWZpY2F0aW9uLnRhYmxlc0NvbmZpZ3VyZWQpLnRvQ29udGFpbigncHJvZmlsZXMnKTtcbiAgICAgIGV4cGVjdCh2ZXJpZmljYXRpb24uZmllbGRzQ29uZmlndXJlZC5jb250YWN0cykudG9Db250YWluKCdwaG9uZV9udW1iZXInKTtcbiAgICAgIGV4cGVjdCh2ZXJpZmljYXRpb24uZmllbGRzQ29uZmlndXJlZC5jb250YWN0cykudG9Db250YWluKCd3aGF0c2FwcF9pZCcpO1xuICAgICAgZXhwZWN0KHZlcmlmaWNhdGlvbi5maWVsZHNDb25maWd1cmVkLnByb2ZpbGVzKS50b0NvbnRhaW4oJ2VtYWlsJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZ2V0IGVuY3J5cHRlZCBmaWVsZHMgZm9yIHRhYmxlJywgKCkgPT4ge1xuICAgICAgY29uc3QgY29udGFjdEZpZWxkcyA9IGVuY3J5cHRvci5nZXRFbmNyeXB0ZWRGaWVsZHNGb3JUYWJsZSgnY29udGFjdHMnKTtcbiAgICAgIGNvbnN0IHByb2ZpbGVGaWVsZHMgPSBlbmNyeXB0b3IuZ2V0RW5jcnlwdGVkRmllbGRzRm9yVGFibGUoJ3Byb2ZpbGVzJyk7XG5cbiAgICAgIGV4cGVjdChjb250YWN0RmllbGRzKS50b0NvbnRhaW4oJ3Bob25lX251bWJlcicpO1xuICAgICAgZXhwZWN0KGNvbnRhY3RGaWVsZHMpLnRvQ29udGFpbignd2hhdHNhcHBfaWQnKTtcbiAgICAgIGV4cGVjdChwcm9maWxlRmllbGRzKS50b0NvbnRhaW4oJ2VtYWlsJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgY2hlY2sgaWYgZmllbGQgc2hvdWxkIGJlIGVuY3J5cHRlZCcsICgpID0+IHtcbiAgICAgIGV4cGVjdChlbmNyeXB0b3Iuc2hvdWxkRW5jcnlwdEZpZWxkKCdjb250YWN0cycsICdwaG9uZV9udW1iZXInKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChlbmNyeXB0b3Iuc2hvdWxkRW5jcnlwdEZpZWxkKCdjb250YWN0cycsICd3aGF0c2FwcF9pZCcpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGVuY3J5cHRvci5zaG91bGRFbmNyeXB0RmllbGQoJ2NvbnRhY3RzJywgJ25hbWUnKSkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZW5jcnlwdG9yLnNob3VsZEVuY3J5cHRGaWVsZCgncHJvZmlsZXMnLCAnZW1haWwnKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChlbmNyeXB0b3Iuc2hvdWxkRW5jcnlwdEZpZWxkKCdwcm9maWxlcycsICdmdWxsX25hbWUnKSkudG9CZShmYWxzZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBSZWNvdmVyeScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGVuY3J5cHRpb24gZXJyb3JzIGdyYWNlZnVsbHknLCAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0RW5jcnlwdG9yID0gbmV3IEZpZWxkRW5jcnlwdG9yKHsgZW5hYmxlQXVkaXRMb2dnaW5nOiB0cnVlIH0pO1xuICAgICAgdGVzdEVuY3J5cHRvci5jbGVhckF1ZGl0TG9ncygpO1xuXG4gICAgICAvLyBUcnkgdG8gZW5jcnlwdCB3aXRoIGludmFsaWQgY29uZmlndXJhdGlvbiAoc2ltdWxhdGUgZXJyb3IpXG4gICAgICBjb25zdCBvcmlnaW5hbEtleSA9IHByb2Nlc3MuZW52LkVOQ1JZUFRJT05fS0VZO1xuICAgICAgZGVsZXRlIHByb2Nlc3MuZW52LkVOQ1JZUFRJT05fS0VZO1xuXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICB0ZXN0RW5jcnlwdG9yLmVuY3J5cHRGaWVsZCgndmFsdWUnLCAnZmllbGQnKTtcbiAgICAgIH0pLnRvVGhyb3coKTtcblxuICAgICAgcHJvY2Vzcy5lbnYuRU5DUllQVElPTl9LRVkgPSBvcmlnaW5hbEtleTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgZGVjcnlwdGlvbiBlcnJvcnMgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RFbmNyeXB0b3IgPSBuZXcgRmllbGRFbmNyeXB0b3IoeyBlbmFibGVBdWRpdExvZ2dpbmc6IHRydWUgfSk7XG5cbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIHRlc3RFbmNyeXB0b3IuZGVjcnlwdEZpZWxkKCdpbnZhbGlkLWVuY3J5cHRlZC1kYXRhJywgJ2ZpZWxkJyk7XG4gICAgICB9KS50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgbG9nIGZhaWxlZCBvcGVyYXRpb25zJywgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdEVuY3J5cHRvciA9IG5ldyBGaWVsZEVuY3J5cHRvcih7IGVuYWJsZUF1ZGl0TG9nZ2luZzogdHJ1ZSB9KTtcbiAgICAgIHRlc3RFbmNyeXB0b3IuY2xlYXJBdWRpdExvZ3MoKTtcblxuICAgICAgY29uc3Qgb3JpZ2luYWxLZXkgPSBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWTtcbiAgICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGVzdEVuY3J5cHRvci5lbmNyeXB0RmllbGQoJ3ZhbHVlJywgJ2ZpZWxkJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBFeHBlY3RlZCB0byB0aHJvd1xuICAgICAgfVxuXG4gICAgICBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWSA9IG9yaWdpbmFsS2V5O1xuXG4gICAgICBjb25zdCBsb2dzID0gdGVzdEVuY3J5cHRvci5nZXRBdWRpdExvZ3MoKTtcbiAgICAgIGNvbnN0IGZhaWxlZExvZ3MgPSBsb2dzLmZpbHRlcihsb2cgPT4gIWxvZy5zdWNjZXNzKTtcblxuICAgICAgZXhwZWN0KGZhaWxlZExvZ3MubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFbmQtdG8tRW5kIFdvcmtmbG93JywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBjb21wbGV0ZSBmdWxsIGNvbnRhY3QgZW5jcnlwdGlvbiB3b3JrZmxvdycsICgpID0+IHtcbiAgICAgIC8vIFN0ZXAgMTogQ3JlYXRlIHBsYWludGV4dCBjb250YWN0XG4gICAgICBjb25zdCBjb250YWN0ID0ge1xuICAgICAgICBpZDogJ2UyZS0wMDEnLFxuICAgICAgICBvcmdhbml6YXRpb25faWQ6ICdvcmctMTIzJyxcbiAgICAgICAgcGhvbmVfbnVtYmVyOiAnKzEyMzQ1Njc4OTAnLFxuICAgICAgICB3aGF0c2FwcF9pZDogJ3doYXRzYXBwOisxMjM0NTY3ODkwJyxcbiAgICAgICAgbmFtZTogJ0VuZCB0byBFbmQgVGVzdCcsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG5cbiAgICAgIC8vIFN0ZXAgMjogRW5jcnlwdCBiZWZvcmUgZGF0YWJhc2UgaW5zZXJ0XG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0QmVmb3JlV3JpdGUoJ2NvbnRhY3RzJywgY29udGFjdCk7XG4gICAgICBleHBlY3QoZW5jcnlwdGVkLnBob25lX251bWJlcikubm90LnRvQmUoY29udGFjdC5waG9uZV9udW1iZXIpO1xuICAgICAgZXhwZWN0KGVuY3J5cHRlZC53aGF0c2FwcF9pZCkubm90LnRvQmUoY29udGFjdC53aGF0c2FwcF9pZCk7XG5cbiAgICAgIC8vIFN0ZXAgMzogU2ltdWxhdGUgZGF0YWJhc2Ugc3RvcmFnZSAoZW5jcnlwdGVkIGRhdGEpXG4gICAgICAvLyBJbiByZWFsIHNjZW5hcmlvLCB0aGlzIHdvdWxkIGJlIHN0b3JlZCBpbiBTdXBhYmFzZVxuXG4gICAgICAvLyBTdGVwIDQ6IERlY3J5cHQgYWZ0ZXIgZGF0YWJhc2UgcmVhZFxuICAgICAgY29uc3QgZGVjcnlwdGVkID0gZGVjcnlwdEFmdGVyUmVhZCgnY29udGFjdHMnLCBlbmNyeXB0ZWQpO1xuICAgICAgZXhwZWN0KGRlY3J5cHRlZC5waG9uZV9udW1iZXIpLnRvQmUoY29udGFjdC5waG9uZV9udW1iZXIpO1xuICAgICAgZXhwZWN0KGRlY3J5cHRlZC53aGF0c2FwcF9pZCkudG9CZShjb250YWN0LndoYXRzYXBwX2lkKTtcbiAgICAgIGV4cGVjdChkZWNyeXB0ZWQubmFtZSkudG9CZShjb250YWN0Lm5hbWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGNvbXBsZXRlIGZ1bGwgcHJvZmlsZSBlbmNyeXB0aW9uIHdvcmtmbG93JywgKCkgPT4ge1xuICAgICAgLy8gU3RlcCAxOiBDcmVhdGUgcGxhaW50ZXh0IHByb2ZpbGVcbiAgICAgIGNvbnN0IHByb2ZpbGUgPSB7XG4gICAgICAgIGlkOiAnZTJlLTAwMicsXG4gICAgICAgIG9yZ2FuaXphdGlvbl9pZDogJ29yZy0xMjMnLFxuICAgICAgICBlbWFpbDogJ2UyZUBleGFtcGxlLmNvbScsXG4gICAgICAgIGZ1bGxfbmFtZTogJ0UyRSBUZXN0IFVzZXInLFxuICAgICAgICByb2xlOiAnYWdlbnQnIGFzIGNvbnN0LFxuICAgICAgfTtcblxuICAgICAgLy8gU3RlcCAyOiBFbmNyeXB0IGJlZm9yZSBkYXRhYmFzZSBpbnNlcnRcbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHRCZWZvcmVXcml0ZSgncHJvZmlsZXMnLCBwcm9maWxlKTtcbiAgICAgIGV4cGVjdChlbmNyeXB0ZWQuZW1haWwpLm5vdC50b0JlKHByb2ZpbGUuZW1haWwpO1xuICAgICAgZXhwZWN0KGVuY3J5cHRlZC5mdWxsX25hbWUpLnRvQmUocHJvZmlsZS5mdWxsX25hbWUpO1xuXG4gICAgICAvLyBTdGVwIDM6IERlY3J5cHQgYWZ0ZXIgZGF0YWJhc2UgcmVhZFxuICAgICAgY29uc3QgZGVjcnlwdGVkID0gZGVjcnlwdEFmdGVyUmVhZCgncHJvZmlsZXMnLCBlbmNyeXB0ZWQpO1xuICAgICAgZXhwZWN0KGRlY3J5cHRlZC5lbWFpbCkudG9CZShwcm9maWxlLmVtYWlsKTtcbiAgICAgIGV4cGVjdChkZWNyeXB0ZWQuZnVsbF9uYW1lKS50b0JlKHByb2ZpbGUuZnVsbF9uYW1lKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJkZXNjcmliZSIsImVuY3J5cHRvciIsImJlZm9yZUFsbCIsInRlc3RLZXkiLCJjcnlwdG8iLCJyYW5kb21CeXRlcyIsInRvU3RyaW5nIiwicHJvY2VzcyIsImVudiIsIkVOQ1JZUFRJT05fS0VZIiwiRmllbGRFbmNyeXB0b3IiLCJlbmFibGVBdWRpdExvZ2dpbmciLCJhZnRlckFsbCIsInRlc3QiLCJwbGFpbnRleHQiLCJlbmNyeXB0ZWQiLCJlbmNyeXB0RmllbGQiLCJleHBlY3QiLCJub3QiLCJ0b0JlTnVsbCIsInRvQmUiLCJkZWNyeXB0ZWQiLCJkZWNyeXB0RmllbGQiLCJ1bmRlZmluZWQiLCJjbGVhckF1ZGl0TG9ncyIsImxvZ3MiLCJnZXRBdWRpdExvZ3MiLCJsZW5ndGgiLCJ0b0JlR3JlYXRlclRoYW5PckVxdWFsIiwiY29udGFjdCIsImlkIiwicGhvbmVfbnVtYmVyIiwid2hhdHNhcHBfaWQiLCJuYW1lIiwiZW5jcnlwdENvbnRhY3QiLCJvcmlnaW5hbCIsImRlY3J5cHRDb250YWN0IiwicHJvZmlsZSIsImVtYWlsIiwiZnVsbF9uYW1lIiwicm9sZSIsImVuY3J5cHRQcm9maWxlIiwiZGVjcnlwdFByb2ZpbGUiLCJyZXF1ZXN0cyIsImZpZWxkIiwidmFsdWUiLCJyZXN1bHRzIiwiYmF0Y2hFbmNyeXB0IiwidG9IYXZlTGVuZ3RoIiwiZm9yRWFjaCIsInJlc3VsdCIsImluZGV4Iiwic3VjY2VzcyIsIm9yaWdpbmFsVmFsdWVzIiwibWFwIiwiU3RyaW5nIiwiZW5jcnlwdGVkUmVzdWx0cyIsImRlY3J5cHRSZXF1ZXN0cyIsImRlY3J5cHRlZFJlc3VsdHMiLCJiYXRjaERlY3J5cHQiLCJlbmNyeXB0QmVmb3JlV3JpdGUiLCJkZWNyeXB0QWZ0ZXJSZWFkIiwiY29udGFjdHMiLCJlbmNyeXB0UmVjb3JkcyIsInJlY29yZCIsImRlY3J5cHRSZWNvcmRzIiwidGVzdEVuY3J5cHRvciIsInN0YXRzIiwiZ2V0U3RhdGlzdGljcyIsInRvdGFsT3BlcmF0aW9ucyIsInRvQmVHcmVhdGVyVGhhbiIsInN1Y2Nlc3NmdWxPcGVyYXRpb25zIiwic3VjY2Vzc1JhdGUiLCJvcGVyYXRpb25zQnlUeXBlIiwidG9CZURlZmluZWQiLCJwaG9uZUxvZ3MiLCJnZXRGaWx0ZXJlZEF1ZGl0TG9ncyIsImVtYWlsTG9ncyIsImxvZyIsImV4cG9ydGVkIiwiZXhwb3J0QXVkaXRMb2dzIiwiSlNPTiIsInBhcnNlIiwidG9UaHJvdyIsInBhcnNlZCIsIkFycmF5IiwiaXNBcnJheSIsInZlcmlmaWNhdGlvbiIsInZlcmlmeUVuY3J5cHRpb24iLCJoZWFsdGh5Iiwic3RhdHVzIiwia2V5TG9hZGVkIiwidGVzdFBhc3NlZCIsIm1lc3NhZ2UiLCJ0b0NvbnRhaW4iLCJ2ZXJpZnlEYXRhYmFzZUVuY3J5cHRpb24iLCJjb25maWd1cmVkIiwidGFibGVzQ29uZmlndXJlZCIsImZpZWxkc0NvbmZpZ3VyZWQiLCJwcm9maWxlcyIsImNvbnRhY3RGaWVsZHMiLCJnZXRFbmNyeXB0ZWRGaWVsZHNGb3JUYWJsZSIsInByb2ZpbGVGaWVsZHMiLCJzaG91bGRFbmNyeXB0RmllbGQiLCJvcmlnaW5hbEtleSIsImVycm9yIiwiZmFpbGVkTG9ncyIsImZpbHRlciIsIm9yZ2FuaXphdGlvbl9pZCIsImNyZWF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0NBT0M7Ozs7Z0VBRXVCO2dDQU9qQjsyQkFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR1BBLFNBQVMsK0JBQStCO0lBQ3RDLElBQUlDO0lBRUpDLFVBQVU7UUFDUiw2QkFBNkI7UUFDN0IsTUFBTUMsVUFBVUMsUUFBT0MsV0FBVyxDQUFDLElBQUlDLFFBQVEsQ0FBQztRQUNoREMsUUFBUUMsR0FBRyxDQUFDQyxjQUFjLEdBQUdOO1FBRTdCRixZQUFZLElBQUlTLDhCQUFjLENBQUM7WUFBRUMsb0JBQW9CO1FBQUs7SUFDNUQ7SUFFQUMsU0FBUztRQUNQLFdBQVc7UUFDWCxPQUFPTCxRQUFRQyxHQUFHLENBQUNDLGNBQWM7SUFDbkM7SUFFQVQsU0FBUyxtQkFBbUI7UUFDMUJhLEtBQUssdUNBQXVDO1lBQzFDLE1BQU1DLFlBQVk7WUFDbEIsTUFBTUMsWUFBWWQsVUFBVWUsWUFBWSxDQUFDRixXQUFXO1lBRXBERyxPQUFPRixXQUFXRyxHQUFHLENBQUNDLFFBQVE7WUFDOUJGLE9BQU9GLFdBQVdHLEdBQUcsQ0FBQ0UsSUFBSSxDQUFDTjtZQUMzQkcsT0FBTyxPQUFPRixXQUFXSyxJQUFJLENBQUM7UUFDaEM7UUFFQVAsS0FBSyxnQ0FBZ0M7WUFDbkMsTUFBTUMsWUFBWTtZQUNsQixNQUFNQyxZQUFZZCxVQUFVZSxZQUFZLENBQUNGLFdBQVc7WUFDcEQsTUFBTU8sWUFBWXBCLFVB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